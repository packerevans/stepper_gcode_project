<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Packers Sand Pro (Final)</title>
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>
    <style>
        :root { --primary: #d2b48c; --panel: #fff; --text: #333; --accent: #2ecc71; }
        body[data-theme='dark'] { --panel: #1e1e1e; --text: #e0e0e0; }
        body { font-family: sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; background: #f4f4f4; color: var(--text); overflow: hidden; }
        .app-container { display: flex; flex: 1; padding: 10px; gap: 10px; overflow: hidden; }
        .panel { background: var(--panel); border-radius: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); padding: 15px; overflow-y: auto; }
        .canvas-wrap { flex: 2; display: flex; justify-content: center; align-items: center; background: #222; border-radius: 12px; }
        canvas { border-radius: 50%; border: 3px solid var(--primary); background: #fff; width: 90vmin; height: 90vmin; }
        body[data-theme='dark'] canvas { background: #222; border-color: #555; }
        .controls { flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 12px; }
        button { padding: 12px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; background: var(--primary); color: white; }
        button:hover { filter: brightness(1.1); }
        button.action { background: var(--accent); color: #000; }
        .row { display: flex; justify-content: space-between; align-items: center; }
        input[type=range] { width: 100%; accent-color: var(--primary); }
    </style>
</head>
<body data-theme="light">
    <div style="padding:10px; background:var(--panel); display:flex; justify-content:space-between;">
        <h3 style="margin:0;">Sand Controller (Center Safe)</h3>
        <button style="width:auto; padding:5px 15px;" onclick="document.body.setAttribute('data-theme', document.body.getAttribute('data-theme')==='dark'?'light':'dark')">üåó</button>
    </div>

    <div class="app-container">
        <div class="canvas-wrap">
            <canvas id="cvs"></canvas>
        </div>
        <div class="panel controls">
            <div class="row" style="gap:5px;">
                <button onclick="setTool('draw')">‚úèÔ∏è Draw</button>
                <button onclick="setTool('erase')">üßº Erase</button>
                <button onclick="undo()">‚Ü∂ Undo</button>
                <button onclick="clearCvs()" style="background:#e74c3c;">‚úñ</button>
            </div>
            
            <input type="file" id="upl" hidden onchange="handleImg(this)">
            <button onclick="document.getElementById('upl').click()" style="background:#3498db;">üì∑ Trace Image</button>

            <hr style="width:100%; border:0; border-top:1px solid #ccc;">

            <label>Simulation: <span id="simVal">100%</span></label>
            <input type="range" id="sim" min="0" max="100" value="100" oninput="render()">
            
            <label>Symmetry: <span id="symVal">1x</span></label>
            <input type="range" id="sym" min="1" max="12" value="1" step="1" oninput="updateUI()">

            <button class="action" onclick="generate()">‚öôÔ∏è Prepare Path</button>
            <div style="text-align:center; font-size:12px; color:gray;" id="status">Ready</div>

            <div class="row" style="background:rgba(0,0,0,0.05); padding:5px; border-radius:5px;">
                <small>Auto-Clear Table?</small>
                <input type="checkbox" id="autoClear" checked>
            </div>
            <div class="row" style="gap:5px;">
                <button onclick="send()">üöÄ Run</button>
                <button onclick="dl()">üíæ Save</button>
            </div>

            <details>
                <summary>Machine Settings</summary>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px; margin-top:5px;">
                    <label>Rad</label><input id="rad" type="number" value="202.6">
                    <label>Spd</label><input id="spd" type="number" value="500">
                    <label>Rim</label><input id="rim" type="number" value="3000">
                    <label>Arm</label><input id="arm" type="number" value="101.3">
                </div>
            </details>
        </div>
    </div>

    <script>
        let raw = [], path = [], hist = [], tool = 'draw', scale = 1;
        const cvs = document.getElementById('cvs'), ctx = cvs.getContext('2d');
        let gcode = "";

        // INIT
        window.onresize = resize;
        setTimeout(resize, 100);
        
        // INPUT HANDLERS
        cvs.onpointerdown = e => {
            cvs.setPointerCapture(e.pointerId);
            hist.push(JSON.stringify(raw));
            if(tool==='draw') raw.push({type:'break'});
            track(e);
            cvs.onpointermove = track;
            cvs.onpointerup = () => { cvs.onpointermove=null; render(); };
        };

        function track(e) {
            const rect = cvs.getBoundingClientRect();
            const x = (e.clientX - rect.left - rect.width/2) / scale;
            const y = -(e.clientY - rect.top - rect.height/2) / scale;
            if(tool==='draw') raw.push({x, y, type:'point'});
            else raw = raw.filter(p => p.type==='break' || Math.hypot(p.x-x, p.y-y) > 10);
            render();
        }

        // RENDERER
        function render() {
            const w = cvs.width, h = cvs.height;
            ctx.clearRect(0,0,w,h);
            ctx.save(); ctx.translate(w/2, h/2);
            
            const r = parseFloat(document.getElementById('rad').value);
            const dark = document.body.getAttribute('data-theme')==='dark';
            
            // Table
            ctx.beginPath(); ctx.arc(0,0,r*scale,0,7); 
            ctx.strokeStyle=dark?'#444':'#ddd'; ctx.lineWidth=2; ctx.stroke();

            // Data
            const showFinal = path.length > 0;
            const pts = showFinal ? path : raw;
            const pct = parseInt(document.getElementById('sim').value)/100;
            const limit = Math.floor(pts.length * pct);
            const sym = parseInt(document.getElementById('sym').value);

            ctx.lineWidth = 1.5;
            const loop = showFinal ? 1 : sym; // Final path already has symmetry baked

            for(let s=0; s<loop; s++) {
                ctx.save();
                if(!showFinal) ctx.rotate(s * (Math.PI*2/sym));
                
                ctx.beginPath();
                ctx.strokeStyle = showFinal ? '#e74c3c' : (dark?'cyan':'#2980b9');
                
                let move = true;
                for(let i=0; i<limit; i++) {
                    const p = pts[i];
                    if(p.type === 'break') { move=true; continue; }
                    const px = p.x*scale, py = -p.y*scale;
                    if(move) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                    move = false;
                }
                ctx.stroke();
                ctx.restore();
            }
            ctx.restore();
            document.getElementById('simVal').innerText = Math.round(pct*100) + "%";
        }

        // --- CORE LOGIC: PREPARE PATH ---
        function generate() {
            const r = parseFloat(document.getElementById('rad').value);
            const sym = parseInt(document.getElementById('sym').value);
            if(raw.length===0) return alert("Draw something!");

            // 1. Expand Symmetry & Shapes
            let shapes = [], cur = [];
            raw.forEach(p => {
                if(p.type==='break') { if(cur.length) shapes.push(cur); cur=[]; }
                else cur.push(p);
            });
            if(cur.length) shapes.push(cur);

            let pool = [];
            for(let s=0; s<sym; s++) {
                const ang = s * (Math.PI*2/sym);
                const c = Math.cos(ang), si = Math.sin(ang);
                shapes.forEach(sh => {
                    pool.push(sh.map(p => ({ x: p.x*c - p.y*si, y: p.x*si + p.y*c, type: 'point' })));
                });
            }

            // 2. Optimization (Perimeter Rider + TSP)
            let sorted = [], pos = {x:r, y:0}; // Start at Rim
            
            // Find closest start
            let bestI=-1, minD=Infinity, bestPt=0;
            pool.forEach((s, i) => {
                s.forEach((p, j) => {
                    const d = Math.hypot(p.x-r, p.y); // Distance to (R,0)
                    if(d < minD) { minD=d; bestI=i; bestPt=j; }
                });
            });

            // Re-order Start Shape
            let first = pool[bestI];
            pool.splice(bestI, 1);
            // If closed loop, rotate to start at bestPt
            if(Math.hypot(first[0].x-first[first.length-1].x, first[0].y-first[first.length-1].y) < 5) {
                first = first.slice(bestPt).concat(first.slice(0, bestPt));
                first.push(first[0]);
            } else if (bestPt > first.length/2) first.reverse(); // Open line optimization
            
            sorted.push(first);
            pos = first[first.length-1];

            // Sort rest
            while(pool.length) {
                let bi=-1, bd=Infinity, rev=false;
                pool.forEach((s, i) => {
                    const d1 = Math.hypot(s[0].x-pos.x, s[0].y-pos.y);
                    const d2 = Math.hypot(s[s.length-1].x-pos.x, s[s.length-1].y-pos.y);
                    if(d1<bd) { bd=d1; bi=i; rev=false; }
                    if(d2<bd) { bd=d2; bi=i; rev=true; }
                });
                let win = pool[bi];
                if(rev) win.reverse();
                sorted.push(win);
                pos = win[win.length-1];
                pool.splice(bi, 1);
            }

            // 3. Construct Path with Entry/Exit
            path = [];
            
            // Entry Line
            const p0 = sorted[0][0];
            const ang0 = Math.atan2(p0.y, p0.x);
            path.push({x: r*Math.cos(ang0), y: r*Math.sin(ang0), type:'point'});

            // Add Shapes & Travel
            sorted.forEach((s, i) => {
                if(i > 0) {
                    // Travel Line (Interpolated)
                    const prev = sorted[i-1][sorted[i-1].length-1];
                    const curr = s[0];
                    interp(prev, curr).forEach(p => path.push(p));
                }
                s.forEach(p => path.push(p));
            });

            // Exit Line
            const last = path[path.length-1];
            const angL = Math.atan2(last.y, last.x);
            // IMPORTANT: Mark as EXIT for M0
            path.push({x: r*Math.cos(angL), y: r*Math.sin(angL), type:'exit'});

            // 4. Kinematics & GCode
            calcGCode();
            document.getElementById('status').innerText = "Path Ready (Red)";
            document.getElementById('status').style.color = "green";
            document.getElementById('sim').value = 0;
            render();
        }

        // --- MATH & KINEMATICS ---
        function interp(p1, p2) {
            const d = Math.hypot(p2.x-p1.x, p2.y-p1.y);
            const steps = Math.ceil(d/1.0); // 1mm res
            let pts = [];
            for(let i=1; i<=steps; i++) {
                const t = i/steps;
                pts.push({ x: p1.x+(p2.x-p1.x)*t, y: p1.y+(p2.y-p1.y)*t, type:'point' });
            }
            return pts;
        }

        function calcGCode() {
            const arm = parseFloat(document.getElementById('arm').value);
            const gear = 1.125;
            const rad = parseFloat(document.getElementById('rad').value);
            const spdC = parseInt(document.getElementById('spd').value);
            const spdR = parseInt(document.getElementById('rim').value);
            const SPR = 8.888888 * (180/Math.PI); // Steps per Rad

            let cmds = [];
            // Init at Start (Assume machine is homed or we sync to first point)
            // Ideally we assume machine starts at 0,0 angle. 
            // We calculate the very first move from 0,0 to Path[0]
            let prevB = 0, prevE = 0; 
            
            // To be safe, we calculate IK for the first point and assume we travel there
            let start = getIK(path[0].x, path[0].y, 0, 0, arm, gear, SPR);
            prevB = start.b; prevE = start.e;
            // Note: We don't output this jump, we assume user manually homed or cleared table

            // Process Path
            for(let i=0; i<path.length-1; i++) {
                const p1 = path[i];
                const p2 = path[i+1];
                
                // M0 CHECK
                if(p2.type === 'exit') cmds.push("M0");

                // Interpolate segment for smoothness & CENTER SAFETY
                const segs = interp(p1, p2);
                
                segs.forEach(pt => {
                    const ik = getIK(pt.x, pt.y, prevB, prevE, arm, gear, SPR);
                    const db = Math.round(ik.b - prevB);
                    const de = Math.round(ik.e - prevE);

                    if(db || de) {
                        // Speed
                        const r = Math.hypot(pt.x, pt.y)/rad;
                        const delay = Math.round(spdC + (spdR-spdC)*r);
                        cmds.push(`G1 ${de} ${db} ${delay}`);
                        prevB += db; prevE += de;
                    }
                });
            }
            gcode = cmds.join('\n');
        }

        function getIK(x, y, lb, le, L, gr, spr) {
            let d = Math.hypot(x, y);
            const max = L*2;
            if(d > max) { x = x/d*max; y = y/d*max; d=max; }

            // --- CENTER SINGULARITY FIX ---
            // If we are crossing or very near center, DO NOT ROTATE BASE.
            // Just fold the elbow.
            if(d < 5.0) {
                // Keep base exactly where it was
                // Calculate elbow steps to match distance 'd'
                // Actually, just fold to 180 (fully in) or near it.
                // Math: Elbow angle relative to base needs to be PI (180 deg)
                // StepsE = -(PI + gr * BaseAngle) * spr
                const curBaseAng = -lb / spr;
                const targetE = -(Math.PI + gr * curBaseAng) * spr;
                return { b: lb, e: targetE };
            }

            // Normal IK
            const curBaseAng = -lb / spr;
            const c = (d*d - L*L - L*L) / (2*L*L);
            const bend = Math.acos(Math.max(-1, Math.min(1, c)));
            
            // Solution 1
            const k1a = L + L*Math.cos(bend);
            const k2a = L*Math.sin(bend);
            const t1 = norm(Math.atan2(y, x) - Math.atan2(k2a, k1a), curBaseAng);
            
            // Solution 2
            const k1b = L + L*Math.cos(-bend);
            const k2b = L*Math.sin(-bend);
            const t2 = norm(Math.atan2(y, x) - Math.atan2(k2b, k1b), curBaseAng);

            // Convert to steps
            const b1 = -t1 * spr;
            const e1 = -(bend + gr*t1) * spr;
            const b2 = -t2 * spr;
            const e2 = -(-bend + gr*t2) * spr;

            // Pick closest to current
            const cost1 = Math.abs(b1-lb) + Math.abs(e1-le);
            const cost2 = Math.abs(b2-lb) + Math.abs(e2-le);
            
            return (cost1 < cost2) ? {b:b1, e:e1} : {b:b2, e:e2};
        }

        function norm(a, ref) {
            const d = a - ref;
            return a - Math.round(d/(2*Math.PI))*2*Math.PI;
        }

        // UTILS
        function resize() {
            const r = cvs.parentElement.getBoundingClientRect();
            cvs.width = r.width; cvs.height = r.height;
            scale = r.width/2 / (parseFloat(document.getElementById('rad').value)*1.1);
            render();
        }
        function undo() { raw = JSON.parse(hist.pop()||"[]"); render(); }
        function clearCvs() { hist.push(JSON.stringify(raw)); raw=[]; path=[]; render(); }
        function setTool(t) { tool = t; }
        function handleImg(el) {
            const f = el.files[0]; if(!f) return;
            const r = new FileReader();
            r.onload = e => {
                ImageTracer.imageToSVG(e.target.result, svg => {
                    const p = new DOMParser().parseFromString(svg, "image/svg+xml");
                    raw=[];
                    const paths = p.getElementsByTagName('path');
                    for(let i=0; i<paths.length; i++) {
                        const len = paths[i].getTotalLength();
                        if(len<10) continue;
                        raw.push({type:'break'});
                        for(let d=0; d<len; d+=2) {
                            const pt = paths[i].getPointAtLength(d);
                            // Simple auto-center/scale logic omitted for brevity, 
                            // relies on user drawing or advanced logic from previous if needed.
                            // Mapping raw SVG coords to canvas center roughly:
                            raw.push({x: pt.x-100, y: pt.y-100, type:'point'}); 
                        }
                    }
                    generate(); // Auto-trigger for convenience
                });
            };
            r.readAsDataURL(f);
        }
        function dl() {
            const b = new Blob([gcode], {type:'text/plain'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(b); a.download = 'sand.txt'; a.click();
        }
        function send() {
            if(!gcode) return alert("Prepare path first");
            let final = gcode;
            if(document.getElementById('autoClear').checked) {
                // In real app, fetch clear.txt content. Here we simulate.
                // fetch('designs/clear.txt').then(r=>r.text()).then(t => ...);
                // For now, we assume user handles file on Pi or we just append.
                // We'll append a comment for Pi to intercept if needed.
                // Or user can manually load clear file.
            }
            fetch(window.location.origin + '/send_gcode_block', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({gcode: final, speed_override: null})
            }).then(r=>r.json()).then(d=>alert(d.success?"Sent":"Error"));
        }
        function updateUI() { document.getElementById('symVal').innerText = document.getElementById('sym').value + 'x'; render(); }
    </script>
</body>
</html>
