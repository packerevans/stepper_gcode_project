<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sand Controller Pro</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

    <style>
        :root {
            --primary: #d2b48c; 
            --secondary: #b08d5c; 
            --bg: #f4f4f4; 
            --panel: #ffffff; 
            --text: #333;
            --accent: #2ecc71;
            --danger: #e74c3c;
            --btn-text: #fff;
        }
        body[data-theme='dark'] {
            --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --btn-text: #000;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--bg); color: var(--text);
            margin: 0; padding: 0; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
        }

        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--panel);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100;
        }
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background-color: var(--primary); overflow-x: hidden;
            transition: 0.3s; padding-top: 60px; z-index: 2000;
            box-shadow: 4px 0 10px rgba(0,0,0,0.3);
        }
        .sidebar a {
            padding: 15px 24px; text-decoration: none; font-size: 18px;
            color: #fff; display: block; font-weight: 500;
        }

        .app-container {
            display: flex; flex-direction: column; height: 100%; width: 100%;
            padding: 10px; box-sizing: border-box; gap: 10px; overflow-y: auto;
        }
        @media (min-width: 768px) {
            .app-container { flex-direction: row; overflow: hidden; }
            .drawing-panel { flex: 2; border-radius: 16px; background: var(--panel); position: relative; }
            .controls-panel { flex: 1; max-width: 400px; border-radius: 16px; background: var(--panel); padding: 20px; overflow-y: auto; }
        }
        @media (max-width: 767px) {
            .drawing-panel { width: 100%; aspect-ratio: 1/1; border-radius: 16px; background: var(--panel); flex-shrink: 0; }
            .controls-panel { flex: 1; border-radius: 16px; background: var(--panel); padding: 15px; }
        }

        .canvas-wrapper {
            position: relative; width: 95%; height: 95%; margin: auto;
            aspect-ratio: 1/1; border-radius: 50%;
            border: 4px solid var(--primary); background: #fff;
            touch-action: none; cursor: crosshair; overflow: hidden;
            top: 50%; transform: translateY(-50%);
        }
        body[data-theme='dark'] .canvas-wrapper { background: #222; border-color: var(--secondary); }
        canvas { display: block; width: 100%; height: 100%; border-radius: 50%; }

        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: var(--secondary); text-align: center; }
        .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
        button {
            background: var(--primary); color: var(--btn-text); border: none;
            padding: 12px; border-radius: 8px; font-weight: 600; cursor: pointer;
            flex: 1; transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        button.secondary { background: transparent; border: 1px solid var(--text); color: var(--text); }
        button.active { background: var(--secondary); border: 2px solid var(--text); }
        button.action { background: var(--accent); color: #000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .slider-row { margin-bottom: 15px; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; font-weight: bold; }
        input[type="range"] { width: 100%; accent-color: var(--secondary); }
        
        #progressSlider {
            -webkit-appearance: none; width: 100%; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none;
        }
        #progressSlider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--secondary); cursor: pointer;
        }

        details { background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; }
        summary { cursor: pointer; font-weight: bold; font-size: 13px; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        input[type="number"] { width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; font-family: monospace;}

        #status-toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 3000;
        }
        .success { background: var(--accent) !important; color: #000 !important; }
        .error { background: var(--danger) !important; color: #fff !important; }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 0 5px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-tog { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-tog:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-tog { background-color: var(--secondary); }
        input:checked + .slider-tog:before { transform: translateX(18px); }

        #toolSettingsArea {
            background: rgba(0,0,0,0.03);
            border: 1px dashed var(--secondary);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 12px;
            display: none;
        }
        .tool-setting-group { display: none; }
        .tool-setting-group.active { display: block; }
        .tool-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--secondary); margin-bottom: 5px; display:block;}

        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .stamp-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 8px; }
        .stamp-btn { font-size: 18px; padding: 5px; background: rgba(0,0,0,0.05); border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); }
        .stamp-btn:hover { background: var(--secondary); color: white; }

    </style>
</head>
<body data-theme="light">

    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Designs</a> 
        <a href="/ai_builder">AI Builder</a>
        <a href="/led_controls">LED Controls</a>
        <a href="/terminal">Terminal</a>
    </div>

    <div class="nav-bar">
        <button style="flex:0; background:none; font-size:24px; color:var(--text); padding:0;" onclick="openNav()">‚ò∞</button>
        <h1 style="margin:0; font-size:1.2rem;">Sand Controller</h1>
        <button style="flex:0; background:none; font-size:20px;" onclick="toggleTheme()">‚òÄÔ∏è</button>
    </div>

    <div class="app-container">
        <div class="drawing-panel">
            <div class="canvas-wrapper" id="canvasContainer">
                <canvas id="drawCanvas"></canvas>
            </div>
            <div id="coordDisplay" style="position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none;">X:0 Y:0</div>
        </div>

        <div class="controls-panel">
            <div id="designPhaseControls">
                <h2>Tools</h2>
                
                <div class="toggle-row">
                    <span style="font-weight:600; font-size:13px;">üñãÔ∏è Smart Pen Mode</span>
                    <label class="switch">
                        <input type="checkbox" id="smartPenMode" checked>
                        <span class="slider-tog"></span>
                    </label>
                </div>

                <div id="toolSettingsArea">
                    <div id="set-pen" class="tool-setting-group">
                        <div class="toggle-row" style="margin:0;">
                            <span style="font-size:13px;">„Ä∞Ô∏è Strong Smoothing</span>
                            <label class="switch">
                                <input type="checkbox" id="smoothDrawMode" checked>
                                <span class="slider-tog"></span>
                            </label>
                        </div>
                        <div style="margin-top:10px;">
                            <span class="tool-label">Add Stamps</span>
                            <div class="stamp-grid">
                                <button class="stamp-btn" onclick="addShape('circle')">‚≠ï</button>
                                <button class="stamp-btn" onclick="addShape('square')">‚¨ú</button>
                                <button class="stamp-btn" onclick="addShape('triangle')">üî∫</button>
                                <button class="stamp-btn" onclick="addShape('star')">‚≠ê</button>
                                <button class="stamp-btn" onclick="addShape('spiral')">üåÄ</button>
                            </div>
                        </div>
                    </div>

                    <div id="set-erase" class="tool-setting-group">
                        <span class="tool-label">Eraser Size: <span id="eraseSizeVal">10px</span></span>
                        <input type="range" min="2" max="50" value="10" oninput="updateToolSettings()" id="eraserSizeSlider">
                    </div>

                    <div id="set-fill" class="tool-setting-group">
                        <span class="tool-label">Line Spacing: <span id="fillGapVal">5.0</span></span>
                        <input type="range" min="1.0" max="15.0" step="0.5" value="5.0" oninput="updateToolSettings()" id="fillGapSlider">
                    </div>

                    <div id="set-select" class="tool-setting-group">
                        <span class="tool-label">Rotate Live</span>
                        <input type="range" min="-180" max="180" value="0" step="1" id="liveRotSlider" 
                               oninput="liveRotate(this.value)" onchange="endLiveTransform(this)">
                        <div style="text-align:right; font-size:10px; color:#666;" id="liveRotVal">0¬∞</div>
                        
                        <span class="tool-label" style="margin-top:10px;">Resize Live</span>
                        <input type="range" min="10" max="200" value="100" step="1" id="liveScaleSlider" 
                               oninput="liveScale(this.value)" onchange="endLiveTransform(this)">
                        <div style="text-align:right; font-size:10px; color:#666;" id="liveScaleVal">100%</div>
                        
                        <div style="clear:both; padding-top:5px; font-size:11px; color:#666; font-style:italic;">
                            Sliders apply instantly and reset on release.
                        </div>
                    </div>

                    <div id="set-sandify" class="tool-setting-group">
                        <span class="tool-label">Start Size (Enlarged)</span>
                        <input type="range" min="1.1" max="4.0" step="0.1" value="2.0" 
                               oninput="document.getElementById('sandStartVal').innerText=this.value+'x'; applySandify();" id="sandScaleInput">
                        <div style="text-align:right; font-size:10px; margin-bottom:5px;" id="sandStartVal">2.0x</div>
                        
                        <span class="tool-label">Zoom Interval</span>
                        <input type="range" min="0.01" max="0.2" step="0.01" value="0.05" oninput="applySandify()" id="sandZoomInput">
                        
                        <span class="tool-label">Rotation Interval</span>
                        <input type="range" min="0" max="45" step="1" value="5" oninput="applySandify()" id="sandRotInput">

                        <span class="tool-label">Shift Interval (Left/Right)</span>
                        <input type="range" min="-50" max="50" step="1" value="0" oninput="applySandify()" id="sandShiftInput">
                        
                        <div style="font-size:11px; color:#666; margin-top:5px;"><i>Adjust sliders to update pattern live.</i></div>
                    </div>
                </div>

                <div class="btn-group">
                    <button id="btnDraw" onclick="setTool('draw')" class="active">‚úèÔ∏è Draw</button>
                    <button id="btnErase" onclick="setTool('erase')" class="secondary">üßº Erase</button>
                </div>

                <div class="btn-group">
                    <button id="btnSelect" onclick="setTool('select')" class="secondary">‚úã Move</button>
                    <button id="btnSandify" onclick="setTool('sandify')" class="secondary">üåÄ Sandify</button>
                </div>

                <div class="btn-group">
                    <button id="btnFill" onclick="setTool('fill')" class="secondary">üåä Dune Fill</button>
                    <input type="file" id="imgUpload" accept="image/*" style="display:none" onchange="handleImageUpload(this)">
                    <button class="secondary" onclick="document.getElementById('imgUpload').click()">‚ú® Trace</button>
                </div>

                <div class="btn-group">
                    <button onclick="undo()" class="secondary">‚Ü∂ Undo</button>
                    <button onclick="clearCanvas()" class="secondary" style="color:var(--danger); border-color:var(--danger);">‚úñ Clear</button>
                </div>

                <hr style="border:0; border-top:1px solid #ddd; margin: 15px 0;">
                
                <div class="slider-row">
                    <div class="slider-header"><span>SYMMETRY</span> <span id="symVal">1x</span></div>
                    <input type="range" id="symSlider" min="1" max="12" value="1" step="1" oninput="updateUI()">
                </div>

                <button class="action" onclick="prepareGCode()" style="margin-bottom:15px; font-size:1.1em;">‚öôÔ∏è Prepare Path</button>
            </div>
            
            <div id="productionPhaseControls" style="display:none; margin-bottom:15px;">
                <button class="secondary" onclick="returnToEditing()" style="width:100%; border:2px dashed #999; color:#444; background: rgba(0,0,0,0.05);">
                    ‚úèÔ∏è Back to Edit
                </button>
            </div>

            <div class="slider-row">
                <div class="slider-header"><span>SIMULATION</span> <span id="progVal">100%</span></div>
                <input type="range" id="progressSlider" min="0" max="100" value="100" oninput="render()">
            </div>

            <div style="text-align:center; font-size:12px; margin-bottom:10px; color:#666;">
                Status: <span id="statusTxt" style="font-weight:bold; color:var(--primary);">Drawing Mode</span>
            </div>

            <div class="toggle-row" style="background:rgba(0,0,0,0.03); padding:8px; border-radius:8px; margin-bottom:10px;">
                <span style="font-weight:600; font-size:13px;">‚ú® Auto-Clear Before Run</span>
                <label class="switch">
                    <input type="checkbox" id="autoClearMode" checked>
                    <span class="slider-tog"></span>
                </label>
            </div>

            <div class="btn-group">
                <button onclick="sendToTable()" class="active">üöÄ Run</button>
                <button onclick="saveToServer()" class="secondary">üíæ Save to Pi</button>
            </div>

            <details>
                <summary>‚öôÔ∏è Machine Settings</summary>
                <div class="settings-grid">
                    <div><label>Radius</label><input type="number" id="cfgRadius" value="202.6" onchange="resizeCanvas()"></div>
                    <div><label>Center Speed</label><input type="number" id="cfgCenterDelay" value="500"></div>
                    <div><label>Rim Speed</label><input type="number" id="cfgPerimDelay" value="3000"></div>
                    <div><label>Steps/Deg</label><input type="number" id="cfgStepsPerDeg" value="8.888888"></div>
                    <div><label>Arm 1</label><input type="number" id="cfgL1" value="101.3"></div>
                    <div><label>Arm 2</label><input type="number" id="cfgL2" value="101.3"></div>
                </div>
            </details>
        </div>
    </div>

    <div id="status-toast"></div>

    <script>
        let rawPoints = []; 
        let processedPoints = []; 
        let historyStack = [];
        let isDrawing = false;
        let currentTool = 'draw';
        let origin = {x:0, y:0};
        let scale = 1;
        let generatedGCode = null;

        // Tool Settings State
        let eraserRadius = 10;
        let fillGap = 5.0;

        // Sandify Base State (to prevent degradation on live updates)
        let sandBasePoints = null;

        // Live Transform State
        let lastRotVal = 0;
        let lastScaleVal = 100;

        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_URL = window.location.origin;

        // =====================================================
        // === 1. CORE MATH & GEOMETRY HELPERS ===
        // =====================================================

        function distSq(p1, p2) { return (p1.x-p2.x)**2 + (p1.y-p2.y)**2; }
        function dist(p1, p2) { return Math.sqrt(distSq(p1, p2)); }
        function isPointInPolygon(p, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i].x, yi = polygon[i].y;
                let xj = polygon[j].x, yj = polygon[j].y;
                let intersect = ((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        function getBounds(shape) {
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            shape.forEach(p => {
                if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
            });
            return { minX, maxX, minY, maxY, area: (maxX-minX)*(maxY-minY), w: maxX-minX, h: maxY-minY, cx: (minX+maxX)/2, cy: (minY+maxY)/2 };
        }
        function getIntersection(A, B, C, D) {
            const det = (B.x - A.x) * (D.y - C.y) - (D.x - C.x) * (B.y - A.y);
            if (det === 0) return null; 
            const lambda = ((D.y - C.y) * (D.x - A.x) + (C.x - D.x) * (D.y - A.y)) / det;
            const gamma = ((A.y - B.y) * (D.x - A.x) + (B.x - A.x) * (D.y - A.y)) / det;
            if (lambda > 0.001 && lambda < 0.999 && gamma > 0.001 && gamma < 0.999) {
                return { x: A.x + lambda * (B.x - A.x), y: A.y + lambda * (B.y - A.y) };
            }
            return null;
        }
        function distToPoly(pt, poly) {
            let minD = Infinity;
            for(let i=0; i<poly.length; i++) {
                let d = Math.hypot(poly[i].x - pt.x, poly[i].y - pt.y);
                if(d < minD) minD = d;
            }
            return minD;
        }
        function findClosestIndex(pt, poly) {
            let minD = Infinity, idx = -1;
            for(let i=0; i<poly.length; i++) {
                let d = distSq(pt, poly[i]);
                if(d < minD) { minD = d; idx = i; }
            }
            return idx;
        }
        function findClosestPoly(pt, target, holes) {
            let bestPoly = null;
            let minD = 5.0; 
            if(distToPoly(pt, target) < minD) return target;
            for(let h of holes) {
                if(distToPoly(pt, h) < minD) return h;
            }
            return null;
        }
        function getPerimeterPath(idx1, idx2, poly) {
            if(idx1 === -1 || idx2 === -1) return [];
            if(idx1 === idx2) return [poly[idx1]];
            let isClosed = dist(poly[0], poly[poly.length-1]) < 2.0;
            if (!isClosed) {
                let path = [];
                let step = (idx1 < idx2) ? 1 : -1;
                for(let i=idx1; i !== idx2; i+=step) path.push(poly[i]);
                path.push(poly[idx2]);
                return path;
            }
            let len = poly.length;
            let cwDist = 0, ccwDist = 0;
            let curr = idx1;
            while(curr !== idx2) {
                let next = (curr + 1) % len;
                cwDist += dist(poly[curr], poly[next]);
                curr = next;
            }
            curr = idx1;
            while(curr !== idx2) {
                let next = (curr - 1 + len) % len;
                ccwDist += dist(poly[curr], poly[next]);
                curr = next;
            }
            let path = [];
            if(cwDist < ccwDist) {
                curr = idx1;
                while(curr !== idx2) {
                    let next = (curr + 1) % len;
                    path.push(poly[next]);
                    curr = next;
                }
            } else {
                curr = idx1;
                while(curr !== idx2) {
                    let next = (curr - 1 + len) % len;
                    path.push(poly[next]);
                    curr = next;
                }
            }
            path.push(poly[idx2]);
            return path;
        }
        function routeConnect(start, end, shapes, depth=0) {
            if (depth > 5) return [end]; 
            let collision = null;
            let minD = Infinity;
            for (let sIdx = 0; sIdx < shapes.length; sIdx++) {
                let poly = shapes[sIdx];
                let isClosed = dist(poly[0], poly[poly.length-1]) < 2.0;
                let limit = isClosed ? poly.length : poly.length - 1;
                for (let i = 0; i < limit; i++) {
                    let p1 = poly[i];
                    let p2 = poly[(i+1)%poly.length];
                    if (dist(start, p1) < 0.1 || dist(start, p2) < 0.1) continue;
                    let hit = getIntersection(start, end, p1, p2);
                    if (hit) {
                        let d = dist(start, hit);
                        if (d < minD) { minD = d; collision = { pt: hit, poly: poly, idx: i }; }
                    }
                }
            }
            if (!collision) return [end];
            let obstacle = collision.poly;
            let exitIdx = -1, minExitD = Infinity;
            for(let i=0; i<obstacle.length; i++) {
                let d = dist(obstacle[i], end);
                if(d < minExitD) { minExitD = d; exitIdx = i; }
            }
            let entryIdx = -1, minEntryD = Infinity;
            for(let i=0; i<obstacle.length; i++) {
                let d = dist(obstacle[i], collision.pt);
                if(d < minEntryD) { minEntryD = d; entryIdx = i; }
            }
            let surfPath = getPerimeterPath(entryIdx, exitIdx, obstacle);
            let exitPoint = obstacle[exitIdx];
            let remainingPath = routeConnect(exitPoint, end, shapes, depth+1);
            return surfPath.concat(remainingPath);
        }

        const Noise = {
            p: [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
                190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,
                125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,
                105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,
                135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,
                82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,
                153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,
                251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,
                157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,
                78,66,215,61,156,180],
            perm: new Array(512),
            grad3: [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],
            init: function() {
                for(let i=0; i<256; i++) this.perm[i] = this.perm[i+256] = this.p[i];
            },
            dot: function(g, x, y) { return g[0]*x + g[1]*y; },
            mix: function(a, b, t) { return (1-t)*a + t*b; },
            fade: function(t) { return t*t*t*(t*(t*6-15)+10); },
            eval: function(x, y) {
                if(!this.perm[0]) this.init();
                var X = Math.floor(x), Y = Math.floor(y);
                x -= X; y -= Y;
                X = X & 255; Y = Y & 255;
                var n00 = this.dot(this.grad3[this.perm[X+this.perm[Y]] % 12], x, y);
                var n01 = this.dot(this.grad3[this.perm[X+this.perm[Y+1]] % 12], x, y-1);
                var n10 = this.dot(this.grad3[this.perm[X+1+this.perm[Y]] % 12], x-1, y);
                var n11 = this.dot(this.grad3[this.perm[X+1+this.perm[Y+1]] % 12], x-1, y-1);
                var u = this.fade(x), v = this.fade(y);
                return this.mix(this.mix(n00, n10, u), this.mix(n01, n11, u), v);
            }
        };

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('pointerdown', startDraw);
            canvas.addEventListener('pointermove', moveDraw);
            canvas.addEventListener('pointerup', endDraw);
            canvas.addEventListener('pointerleave', endDraw);
            canvas.style.touchAction = "none";
            updateUI();
            updateToolSettings();
        }

        let dragStart = null;

        // --- DRAWING LOGIC ---
        function startDraw(e) {
            e.preventDefault();
            if(generatedGCode) return;
            if(currentTool === 'fill') { handleFillClick(e); return; }

            const smart = document.getElementById('smartPenMode').checked;
            if(smart && currentTool !== 'select' && currentTool !== 'sandify') {
                if(e.pointerType === 'pen') setTool('draw');
                else if(e.pointerType === 'touch') setTool('erase');
            }

            if(currentTool === 'select') {
                isDrawing = true;
                dragStart = getPos(e);
                canvas.setPointerCapture(e.pointerId);
                return;
            }
            if(currentTool === 'sandify') return;

            saveState();
            isDrawing = true;
            canvas.setPointerCapture(e.pointerId);
            processPointer(e);
            resetStatus();
        }

        function moveDraw(e) {
            e.preventDefault();
            const pos = getPos(e);
            document.getElementById('coordDisplay').textContent = `X:${pos.x.toFixed(0)} Y:${pos.y.toFixed(0)}`;
            
            if(!isDrawing) { render(); drawCursor(pos); return; }

            if(currentTool === 'select' && dragStart) {
                const dx = pos.x - dragStart.x;
                const dy = pos.y - dragStart.y;
                rawPoints.forEach(p => {
                    if(p.type === 'point') {
                        p.x += dx;
                        p.y += dy;
                    }
                });
                dragStart = pos; 
                render();
                return;
            }
            processPointer(e);
        }

        function endDraw(e) {
            if(!isDrawing) return;
            isDrawing = false;
            canvas.releasePointerCapture(e.pointerId);
            if(currentTool === 'select') {
                dragStart = null;
                saveState(); 
                return;
            }
            if(currentTool === 'draw') {
                if(document.getElementById('smoothDrawMode').checked) {
                    smoothLastStroke();
                }
                rawPoints.push({type:'break'});
            }
            render();
        }

        function smoothLastStroke() {
            let lastBreak = -1;
            for(let i=rawPoints.length-1; i>=0; i--) {
                if(rawPoints[i].type === 'break' || rawPoints[i].type === 'cmd') {
                    lastBreak = i;
                    break;
                }
            }
            let stroke = [];
            let startIndex = lastBreak + 1;
            for(let i=startIndex; i<rawPoints.length; i++) stroke.push(rawPoints[i]);
            if(stroke.length < 3) return;

            // STRONGER SMOOTHING: 4 Passes
            for(let pass=0; pass<4; pass++) {
                let smooth = [];
                smooth.push(stroke[0]);
                for(let i=0; i<stroke.length-1; i++) {
                    let p0 = stroke[i];
                    let p1 = stroke[i+1];
                    smooth.push({
                        x: 0.75 * p0.x + 0.25 * p1.x,
                        y: 0.75 * p0.y + 0.25 * p1.y,
                        type: 'point'
                    });
                    smooth.push({
                        x: 0.25 * p0.x + 0.75 * p1.x,
                        y: 0.25 * p0.y + 0.75 * p1.y,
                        type: 'point'
                    });
                }
                smooth.push(stroke[stroke.length-1]);
                stroke = smooth;
            }
            rawPoints.splice(startIndex, rawPoints.length - startIndex, ...stroke);
        }

        // --- SHAPE STAMPS ---
        function addShape(type) {
            saveState();
            const r = 50; 
            let pts = [];
            
            if(type==='circle') {
                for(let i=0; i<=36; i++) {
                    const a = (i/36)*Math.PI*2;
                    pts.push({x: Math.cos(a)*r, y: Math.sin(a)*r});
                }
            } else if(type==='square') {
                pts = [{x:-r,y:-r}, {x:r,y:-r}, {x:r,y:r}, {x:-r,y:r}, {x:-r,y:-r}];
            } else if(type==='triangle') {
                pts = [{x:0,y:r}, {x:r*0.86,y:-r/2}, {x:-r*0.86,y:-r/2}, {x:0,y:r}];
            } else if(type==='star') {
                 for(let i=0; i<=10; i++) {
                    const a = (i/10)*Math.PI*2 + Math.PI/2;
                    const rad = (i%2===0) ? r : r*0.4;
                    pts.push({x: Math.cos(a)*rad, y: Math.sin(a)*rad});
                }
            } else if(type==='spiral') {
                for(let i=0; i<100; i++) {
                    const a = i * 0.3;
                    const rad = (i/100)*r;
                    pts.push({x: Math.cos(a)*rad, y: Math.sin(a)*rad});
                }
            }

            if(rawPoints.length > 0 && rawPoints[rawPoints.length-1].type !== 'break') rawPoints.push({type:'break'});
            pts.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'}));
            rawPoints.push({type:'break'});
            render();
            showToast("Added " + type, "success");
        }

        function getPos(e) {
            return {
                x: (e.offsetX - origin.x) / scale,
                y: -(e.offsetY - origin.y) / scale
            };
        }

        function processPointer(e) {
            const p = getPos(e);
            if(currentTool === 'draw') {
                rawPoints.push({x: p.x, y: p.y, type: 'point'});
            } else if (currentTool === 'erase') {
                const r = eraserRadius; 
                rawPoints = rawPoints.filter(pt => {
                    if(pt.type === 'break') return true;
                    return Math.hypot(pt.x - p.x, pt.y - p.y) > r;
                });
            }
            render();
            if(currentTool==='erase') drawCursor(p);
        }

        function drawCursor(p) {
            if(generatedGCode) return;
            const r = (currentTool === 'erase' ? eraserRadius : 10) * scale;
            const px = origin.x + p.x * scale;
            const py = origin.y - p.y * scale;
            if(currentTool === 'erase') {
                ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2);
                ctx.strokeStyle = "#999"; ctx.fillStyle = "rgba(200,200,200,0.3)";
                ctx.stroke(); ctx.fill();
            } else if (currentTool === 'fill') {
                ctx.font = "20px Arial"; ctx.fillStyle = "black"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("üåä", px, py);
            } else if (currentTool === 'select') {
                ctx.font = "20px Arial"; ctx.fillStyle = "black"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("‚úã", px, py);
            } else if (currentTool === 'sandify') {
                ctx.font = "20px Arial"; ctx.fillStyle = "black"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("üåÄ", px, py);
            }
        }

        // --- LIVE TRANSFORM HELPERS ---
        function liveRotate(val) {
            if(rawPoints.length === 0) return;
            const diff = val - lastRotVal;
            if(diff === 0) return;
            
            // Apply delta rotation
            const rad = (diff * Math.PI) / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            let hasPoints = false;
            rawPoints.forEach(p => {
                if(p.type === 'point') {
                    if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                    if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
                    hasPoints = true;
                }
            });
            if(!hasPoints) return;
            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;

            rawPoints.forEach(p => {
                if(p.type === 'point') {
                    let tx = p.x - cx;
                    let ty = p.y - cy;
                    p.x = cx + (tx * cos - ty * sin);
                    p.y = cy + (tx * sin + ty * cos);
                }
            });

            lastRotVal = val;
            document.getElementById('liveRotVal').innerText = val + "¬∞";
            render();
        }

        function liveScale(val) {
             if(rawPoints.length === 0) return;
             const factor = val / lastScaleVal;
             if(factor === 1) return;

             let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
             let hasPoints = false;
             rawPoints.forEach(p => {
                if(p.type === 'point') {
                    if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                    if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
                    hasPoints = true;
                }
            });
            if(!hasPoints) return;
            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;

            rawPoints.forEach(p => {
                if(p.type === 'point') {
                    p.x = cx + (p.x - cx) * factor;
                    p.y = cy + (p.y - cy) * factor;
                }
            });

            lastScaleVal = val;
            document.getElementById('liveScaleVal').innerText = val + "%";
            render();
        }

        function endLiveTransform(slider) {
            saveState(); // Commit the change
            // Reset logic to avoid range limits
            if(slider.id === 'liveRotSlider') {
                slider.value = 0;
                lastRotVal = 0;
                document.getElementById('liveRotVal').innerText = "0¬∞";
            }
            if(slider.id === 'liveScaleSlider') {
                slider.value = 100;
                lastScaleVal = 100;
                document.getElementById('liveScaleVal').innerText = "100%";
            }
        }

        // --- SANDIFY LOGIC ---
        function applySandify() {
            if(!sandBasePoints || sandBasePoints.length === 0) return;
            
            // Read from slider
            const startScale = parseFloat(document.getElementById('sandScaleInput').value);
            const zoomStep = parseFloat(document.getElementById('sandZoomInput').value);
            const rotStep = parseFloat(document.getElementById('sandRotInput').value);
            const shiftStep = parseFloat(document.getElementById('sandShiftInput').value);
            
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            let pointsFound = false;
            
            // Use base points for calculation source
            let baseShape = JSON.parse(JSON.stringify(sandBasePoints));
            
            baseShape.forEach(p => {
                if(p.type === 'point') {
                    if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                    if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
                    pointsFound = true;
                }
            });

            if(!pointsFound) return;
            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;

            let newPattern = [];
            let currentScale = startScale;
            let currentRot = 0;
            let currentShift = 0;
            
            while(currentScale >= 1.0) {
                const rad = (currentRot * Math.PI) / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                
                baseShape.forEach(p => {
                    if(p.type === 'point') {
                        let tx = p.x - cx;
                        let ty = p.y - cy;
                        tx *= currentScale;
                        ty *= currentScale;
                        let rx = tx * cos - ty * sin;
                        let ry = tx * sin + ty * cos;
                        rx += currentShift; 
                        newPattern.push({ x: cx + rx, y: cy + ry, type: 'point' });
                    } else {
                        newPattern.push({type: p.type});
                    }
                });
                
                if(newPattern.length > 0 && newPattern[newPattern.length-1].type !== 'break') {
                    newPattern.push({type: 'break'});
                }

                currentScale -= zoomStep;
                currentRot += rotStep;
                currentShift += shiftStep;
            }

            // Update global rawPoints for display/Gcode
            rawPoints = newPattern;
            resetStatus();
            render();
        }


        // --- MASTER DUNE FILL ---
        function handleFillClick(e) {
            const clickPos = getPos(e);
            const DENSITY = fillGap; 
            const NOISE_SCALE = 0.05;
            const WAVE_AMP = 3.0; 
            const MAX_JUMP = 30.0; 

            let shapes = [];
            let currentShape = [];
            
            rawPoints.forEach(p => {
                if(p.type === 'break' || p.type === 'cmd') {
                    if(currentShape.length > 2) shapes.push(currentShape); 
                    currentShape = [];
                } else {
                    if(currentShape.length > 0) {
                        let last = currentShape[currentShape.length-1];
                        let dist = Math.hypot(p.x - last.x, p.y - last.y);
                        if(dist > MAX_JUMP) {
                             if(currentShape.length > 2) shapes.push(currentShape);
                             currentShape = [];
                        }
                    }
                    currentShape.push(p);
                }
            });
            if(currentShape.length > 2) shapes.push(currentShape);

            let candidates = [];
            for(let i=0; i<shapes.length; i++) {
                if(isPointInPolygon(clickPos, shapes[i])) {
                    let bounds = getBounds(shapes[i]);
                    candidates.push({ id: i, area: bounds.area, shape: shapes[i], bounds: bounds });
                }
            }

            if(candidates.length === 0) {
                showToast("Click inside a closed shape", "error");
                return;
            }

            candidates.sort((a,b) => a.area - b.area);
            const target = candidates[0]; 
            
            let holes = [];
            shapes.forEach((s, idx) => {
                if(idx === target.id) return; 
                if(isPointInPolygon(s[0], target.shape)) {
                     let sBounds = getBounds(s);
                     if(sBounds.area < target.area) {
                        holes.push(s);
                     }
                }
            });

            showToast("Generating Smart Trace...", "info");
            saveState();

            const fillAngle = Math.random() * Math.PI; 
            const rotatePt = (x, y, rad) => ({ x: x * Math.cos(rad) - y * Math.sin(rad), y: x * Math.sin(rad) + y * Math.cos(rad) });

            const rotTarget = target.shape.map(p => rotatePt(p.x, p.y, -fillAngle));
            const rotHoles = holes.map(h => h.map(p => rotatePt(p.x, p.y, -fillAngle)));
            const rotBounds = getBounds(rotTarget);
            
            let y = rotBounds.minY + DENSITY;
            let direction = 1;
            
            rawPoints.push({type: 'break'});

            let lastFilledPointRot = null;

            while(y < rotBounds.maxY) {
                let cutPoints = [];
                const addIntersections = (poly, polyId) => {
                    for(let i=0; i<poly.length; i++) {
                        let p1 = poly[i];
                        let p2 = poly[(i+1)%poly.length];
                        if((p1.y <= y && p2.y > y) || (p1.y > y && p2.y <= y)) {
                            let x = p1.x + (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
                            cutPoints.push({x:x, polyIndex: polyId}); 
                        }
                    }
                };
                addIntersections(rotTarget, -1); 
                rotHoles.forEach((h, idx) => addIntersections(h, idx));
                cutPoints.sort((a,b) => a.x - b.x);

                for(let k=0; k<cutPoints.length; k++) {
                     if(k+1 >= cutPoints.length) break;
                     let startCut = cutPoints[k];
                     let endCut = cutPoints[k+1];
                     let midX = (startCut.x + endCut.x) / 2;
                     let pMid = {x: midX, y: y};
                     let isInsideTarget = isPointInPolygon(pMid, rotTarget);
                     let isInsideHole = false;
                     for(let rh of rotHoles) { if(isPointInPolygon(pMid, rh)) { isInsideHole = true; break; } }

                     if(isInsideTarget && !isInsideHole) {
                        let segPoints = [];
                        const step = 2.0; 
                        let xStart = startCut.x;
                        let xEnd = endCut.x;
                        if(direction === 1) {
                            for(let x=xStart; x<=xEnd; x+=step) segPoints.push(x);
                            if(segPoints[segPoints.length-1] !== xEnd) segPoints.push(xEnd);
                        } else {
                            for(let x=xEnd; x>=xStart; x-=step) segPoints.push(x);
                            if(segPoints[segPoints.length-1] !== xStart) segPoints.push(xStart);
                        }
                        let segmentStartPointRot = {x: segPoints[0], y:y};
                        if(lastFilledPointRot) {
                            let startPoly = findClosestPoly(lastFilledPointRot, rotTarget, rotHoles);
                            let endPoly = findClosestPoly(segmentStartPointRot, rotTarget, rotHoles);
                            if(startPoly && endPoly && startPoly === endPoly) {
                                let idx1 = findClosestIndex(lastFilledPointRot, startPoly);
                                let idx2 = findClosestIndex(segmentStartPointRot, startPoly);
                                let trace = getPerimeterPath(idx1, idx2, startPoly);
                                trace.forEach(tp => {
                                    let rp = rotatePt(tp.x, tp.y, fillAngle);
                                    rawPoints.push({x:rp.x, y:rp.y, type:'point'});
                                });
                            } else {
                                if(rawPoints.length>0 && rawPoints[rawPoints.length-1].type!=='break') {
                                    rawPoints.push({type:'break'});
                                }
                            }
                        } else { rawPoints.push({type:'break'}); }

                        for(let px of segPoints) {
                            let noiseVal = Noise.eval(px * NOISE_SCALE, y * NOISE_SCALE);
                            let py = y + (noiseVal * WAVE_AMP);
                            let realPt = rotatePt(px, py, fillAngle);
                            let safe = isPointInPolygon(realPt, target.shape);
                            if(safe) { for(let h of holes) { if(isPointInPolygon(realPt, h)) { safe=false; break; } } }
                            if(safe) { rawPoints.push({x:realPt.x, y:realPt.y, type:'point'}); }
                        }
                        lastFilledPointRot = {x: segPoints[segPoints.length-1], y:y};
                     }
                }
                direction *= -1;
                y += DENSITY;
            }
            if(lastFilledPointRot) {
                 let startP = target.shape[0];
                 let startPRot = rotatePt(startP.x, startP.y, -fillAngle);
                 let idx1 = findClosestIndex(lastFilledPointRot, rotTarget);
                 let idx2 = findClosestIndex(startPRot, rotTarget);
                 let trace = getPerimeterPath(idx1, idx2, rotTarget);
                 trace.forEach(tp => { let rp = rotatePt(tp.x, tp.y, fillAngle); rawPoints.push({x:rp.x, y:rp.y, type:'point'}); });
            } else { rawPoints.push({type: 'break'}); }

            target.shape.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'}));
            rawPoints.push({x:target.shape[0].x, y:target.shape[0].y, type:'point'});
            holes.forEach(h => {
                rawPoints.push({type: 'break'});
                h.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'}));
                rawPoints.push({x:h[0].x, y:h[0].y, type:'point'});
            });
            rawPoints.push({type: 'break'});
            render();
            showToast("Master Fill Complete!", "success");
        }

        // --- IMAGE UPLOAD HANDLING ---
        function handleImageUpload(input) {
            const file = input.files[0];
            if(!file) return;
            showToast("Scanning...", "info");
            saveState();
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const tCan = document.createElement('canvas');
                    const MAX = 1000;
                    let tw = img.width, th = img.height;
                    if(tw>th && tw>MAX){ th*=MAX/tw; tw=MAX; } 
                    else if(th>MAX){ tw*=MAX/th; th=MAX; }
                    tCan.width = tw; tCan.height = th;
                    const tCtx = tCan.getContext('2d');
                    tCtx.fillStyle = "white"; tCtx.fillRect(0,0,tw,th);
                    tCtx.filter = "grayscale(100%) contrast(150%)";
                    tCtx.drawImage(img, 0, 0, tw, th);
                    ImageTracer.imageToSVG(tCan.toDataURL(), function(svgStr){ processTrace(svgStr, tw, th); }, { ltres:0.5, qtres:0.5, pathomit:2, colorsampling:2, numberofcolors:2 });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processTrace(svgStr, imgW, imgH) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgStr, "image/svg+xml");
            const paths = doc.getElementsByTagName("path");
            let strokes = [];
            const res = 2.0; 
            for(let i=0; i<paths.length; i++) {
                const p = paths[i];
                const len = p.getTotalLength();
                if(len < 5) continue; 
                let pts = [];
                let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
                for(let d=0; d<=len; d+=res) {
                    const pt = p.getPointAtLength(d);
                    pts.push({x: pt.x, y: pt.y});
                    if(pt.x<minX) minX=pt.x; if(pt.x>maxX) maxX=pt.x;
                    if(pt.y<minY) minY=pt.y; if(pt.y>maxY) maxY=pt.y;
                }
                const w = maxX - minX;
                const h = maxY - minY;
                if (w > imgW * 0.98 || h > imgH * 0.98) continue; 
                strokes.push(pts);
            }
            if(strokes.length === 0) return showToast("No shapes found", "error");
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            strokes.flat().forEach(p => {
                if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
            });
            const contentW = maxX - minX;
            const contentH = maxY - minY;
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const scaleFac = (tableR * 2 * 0.9) / Math.max(contentW, contentH);
            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;
            let normalizedStrokes = strokes.map(s => {
                return s.map(p => ({
                    x: (p.x - cx) * scaleFac,
                    y: -(p.y - cy) * scaleFac 
                })).filter(p => Math.hypot(p.x, p.y) < tableR);
            });
            rawPoints = [];
            normalizedStrokes.forEach(s => {
                rawPoints.push({type:'break'});
                s.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'}));
            });
            rawPoints.push({type:'break'});
            resetStatus();
            showToast("Trace Loaded (Click Prepare)", "info");
            render();
        }

        // --- OPTIMIZER ---
        function prepareGCode() {
            if(rawPoints.length === 0) return showToast("Draw something first!", "error");
            showToast("Optimizing Path...", "info");
            setTimeout(() => { 
                const tableR = parseFloat(document.getElementById('cfgRadius').value);
                const sym = parseInt(document.getElementById('symSlider').value);
                let shapes = [];
                let curShape = [];
                rawPoints.forEach(p => {
                    if(p.type === 'break' || p.type === 'cmd') {
                        if(curShape.length > 0) shapes.push(curShape);
                        curShape = [];
                    } else { curShape.push(p); }
                });
                if(curShape.length > 0) shapes.push(curShape);
                let pool = [];
                for(let s=0; s<sym; s++) {
                    const ang = s * (Math.PI*2/sym);
                    const c = Math.cos(ang), si = Math.sin(ang);
                    shapes.forEach(sh => {
                        let newSh = sh.map(p => ({ x: p.x*c - p.y*si, y: p.x*si + p.y*c, type: 'point' }));
                        pool.push(newSh);
                    });
                }
                let bestShapeIdx = -1, bestPointIdx = -1, maxDist = -1;
                for (let i=0; i<pool.length; i++) {
                    for (let j=0; j<pool[i].length; j++) {
                        let d = Math.hypot(pool[i][j].x, pool[i][j].y);
                        if (d > maxDist) { maxDist = d; bestShapeIdx = i; bestPointIdx = j; }
                    }
                }
                let startShape = pool[bestShapeIdx];
                pool.splice(bestShapeIdx, 1);
                let dClose = Math.hypot(startShape[0].x - startShape[startShape.length-1].x, startShape[0].y - startShape[startShape.length-1].y);
                if(dClose < 5.0) { 
                    let p1 = startShape.slice(bestPointIdx);
                    let p2 = startShape.slice(0, bestPointIdx);
                    startShape = p1.concat(p2);
                    startShape.push(startShape[0]);
                } else { 
                    let dStart = Math.hypot(startShape[0].x, startShape[0].y);
                    let dEnd = Math.hypot(startShape[startShape.length-1].x, startShape[startShape.length-1].y);
                    if(dEnd > dStart) startShape.reverse();
                }
                let sortedShapes = [startShape];
                let curPos = startShape[startShape.length-1];
                while(pool.length > 0) {
                    let bestIdx = -1, bestDist = Infinity, bestStartIdx = 0, bestIsReverse = false;
                    for(let i=0; i<pool.length; i++) {
                        let s = pool[i];
                        let isClosed = Math.hypot(s[0].x - s[s.length-1].x, s[0].y - s[s.length-1].y) < 5.0;
                        if(isClosed) {
                            for(let k=0; k<s.length; k++) {
                                let d = Math.hypot(curPos.x - s[k].x, curPos.y - s[k].y);
                                if(d < bestDist) { bestDist = d; bestIdx = i; bestStartIdx = k; bestIsReverse = false; }
                            }
                        } else {
                            let dStart = Math.hypot(curPos.x - s[0].x, curPos.y - s[0].y);
                            if(dStart < bestDist) { bestDist=dStart; bestIdx=i; bestStartIdx=0; bestIsReverse=false; }
                            let dEnd = Math.hypot(curPos.x - s[s.length-1].x, curPos.y - s[s.length-1].y);
                            if(dEnd < bestDist) { bestDist=dEnd; bestIdx=i; bestStartIdx=0; bestIsReverse=true; }
                        }
                    }
                    let winner = pool[bestIdx];
                    let isWinnerClosed = Math.hypot(winner[0].x - winner[winner.length-1].x, winner[0].y - winner[winner.length-1].y) < 5.0;
                    if(isWinnerClosed) {
                        let p1 = winner.slice(bestStartIdx);
                        let p2 = winner.slice(0, bestStartIdx);
                        winner = p1.concat(p2);
                        winner.push(winner[0]);
                    } else {
                        if(bestIsReverse) winner.reverse();
                    }
                    sortedShapes.push(winner);
                    curPos = winner[winner.length-1];
                    pool.splice(bestIdx, 1);
                }
                processedPoints = [];
                let stats_connections = 0;
                let stats_rerouted = 0;
                if(sortedShapes.length > 0) {
                    let fPt = sortedShapes[0][0];
                    let fAng = Math.atan2(fPt.y, fPt.x);
                    processedPoints.push({x: tableR*Math.cos(fAng), y: tableR*Math.sin(fAng), type:'point'});
                }
                for(let i=0; i<sortedShapes.length; i++) {
                    let s = sortedShapes[i];
                    if(i > 0) {
                        stats_connections++;
                        let prev = sortedShapes[i-1];
                        let currStart = s[0];
                        let bestExitIdx = -1;
                        let minDist = Infinity;
                        for(let k=0; k<prev.length; k++) {
                            let d = Math.hypot(prev[k].x - currStart.x, prev[k].y - currStart.y);
                            if(d < minDist) { minDist = d; bestExitIdx = k; }
                        }
                        let isPrevClosed = Math.hypot(prev[0].x - prev[prev.length-1].x, prev[0].y - prev[prev.length-1].y) < 5.0;
                        let retracePath = [];
                        if(isPrevClosed) {
                            let distFwd = bestExitIdx; 
                            let distBk = (prev.length-1) - bestExitIdx;
                            if(distFwd < distBk) { for(let m=0; m<=bestExitIdx; m++) retracePath.push(prev[m]); } 
                            else { for(let m=prev.length-1; m>=bestExitIdx; m--) retracePath.push(prev[m]); }
                        } else { for(let m=prev.length-1; m>=bestExitIdx; m--) retracePath.push(prev[m]); }
                        retracePath.forEach(p => processedPoints.push(p));
                        let startJump = prev[bestExitIdx];
                        let safePath = routeConnect(startJump, currStart, sortedShapes);
                        if(safePath.length > 1) { stats_rerouted++; }
                        safePath.forEach(p => processedPoints.push({x:p.x, y:p.y, type:'point'}));
                    }
                    s.forEach(p => processedPoints.push(p));
                }
                if(processedPoints.length > 0) {
                    let lastPt = processedPoints[processedPoints.length-1];
                    processedPoints.push({type: 'cmd', val: 'M0'});
                    let exitAng = Math.atan2(lastPt.y, lastPt.x);
                    processedPoints.push({ x: tableR * Math.cos(exitAng), y: tableR * Math.sin(exitAng), type: 'point' });
                }
                generatedGCode = generateGCodeStringFromProcessed();
                let summary = `Path Ready! ${sortedShapes.length} shapes. ${stats_rerouted}/${stats_connections} jumps rerouted.`;
                document.getElementById('statusTxt').innerText = summary;
                document.getElementById('statusTxt').style.color = "green";
                document.getElementById('progressSlider').value = 0;
                document.getElementById('designPhaseControls').style.display = 'none';
                document.getElementById('productionPhaseControls').style.display = 'block';
                document.getElementById('productionPhaseControls').classList.add('fade-in');
                render(); 
                showToast(summary, "success");
            }, 50);
        }

        function returnToEditing() {
            generatedGCode = null;
            processedPoints = [];
            document.getElementById('designPhaseControls').style.display = 'block';
            document.getElementById('productionPhaseControls').style.display = 'none';
            document.getElementById('designPhaseControls').classList.add('fade-in');
            resetStatus();
            updateUI();
        }

        function generateGCodeStringFromProcessed() {
            const L1 = parseFloat(document.getElementById('cfgL1').value);
            const L2 = parseFloat(document.getElementById('cfgL2').value);
            const gearRatio = 1.125;
            const tableRadius = parseFloat(document.getElementById('cfgRadius').value);
            const stepsPerDeg = parseFloat(document.getElementById('cfgStepsPerDeg').value);
            const stepsPerRad = stepsPerDeg * (180 / Math.PI);
            const centerDelay = parseFloat(document.getElementById('cfgCenterDelay').value);
            const perimDelay = parseFloat(document.getElementById('cfgPerimDelay').value);
            let cmds = [];
            let prevBase = 0;
            let prevElbow = 0;
            let firstPt = processedPoints[0];
            if(firstPt.type === 'cmd') return "";
            let startIK = calculateIK(-firstPt.x, firstPt.y, 0, 0, L1, L2, gearRatio, stepsPerRad);
            prevBase = startIK.base_steps;
            prevElbow = startIK.elbow_steps;
            for(let i=0; i<processedPoints.length-1; i++) {
                let p1 = processedPoints[i];
                let p2 = processedPoints[i+1];
                if (p1.type === 'cmd' && p1.val === 'M0') { cmds.push("M0"); }
                if (p2.type === 'cmd' && p2.val === 'M0') { continue; }
                let startX, startY;
                if(p1.type === 'cmd') {
                   let back = i-1;
                   while(back >= 0 && processedPoints[back].type === 'cmd') back--;
                   if(back < 0) { startX=0; startY=0; }
                   else { startX = processedPoints[back].x; startY = processedPoints[back].y; }
                } else { startX = p1.x; startY = p1.y; }
                let dist = Math.hypot(p2.x-startX, p2.y-startY);
                let steps = Math.max(1, Math.ceil(dist / 1.0)); 
                for(let j=1; j<=steps; j++) {
                    let t = j/steps;
                    let x = startX + (p2.x - startX)*t;
                    let y = startY + (p2.y - startY)*t;
                    let ik = calculateIK(-x, y, prevBase, prevElbow, L1, L2, gearRatio, stepsPerRad);
                    let dBase = Math.round(ik.base_steps - prevBase);
                    let dElbow = Math.round(ik.elbow_steps - prevElbow);
                    if(dBase !== 0 || dElbow !== 0) {
                        let r = Math.hypot(x, y);
                        if (r < 5.0 && (Math.abs(dBase) > 2000 || Math.abs(dElbow) > 2000)) { prevBase += dBase; prevElbow += dElbow; continue; }
                        let rFactor = r / tableRadius;
                        if(rFactor > 1) rFactor = 1;
                        let delay = Math.round(centerDelay + ((perimDelay - centerDelay) * rFactor));
                        cmds.push(`G1 ${dElbow} ${dBase} ${delay}`);
                        prevBase += dBase; prevElbow += dElbow;
                    }
                }
            }
            return cmds.join('\n');
        }

        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const size = container.getBoundingClientRect().width;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            ctx.scale(dpr, dpr);
            origin = { x: size/2, y: size/2 };
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            scale = (size/2) / (tableR * 1.05);
            render();
        }
        function saveState() {
            if(historyStack.length>10) historyStack.shift();
            historyStack.push(JSON.stringify(rawPoints));
        }
        function undo() {
            if(historyStack.length===0) return;
            rawPoints = JSON.parse(historyStack.pop());
            resetStatus();
            render();
        }
        function clearCanvas() {
            saveState();
            rawPoints = [];
            resetStatus();
            render();
        }
        function setTool(t) {
            // Save base points if leaving another tool
            if(currentTool === 'sandify' && t !== 'sandify') {
                 sandBasePoints = null; // Clear base cache
            }

            currentTool = t;
            document.getElementById('btnDraw').className = t==='draw'?'active':'secondary';
            document.getElementById('btnErase').className = t==='erase'?'active':'secondary';
            document.getElementById('btnFill').className = t==='fill'?'active':'secondary';
            document.getElementById('btnSelect').className = t==='select'?'active':'secondary';
            document.getElementById('btnSandify').className = t==='sandify'?'active':'secondary';
            
            updateToolSettings();

            // Sandify Logic: Auto-Capture state and generate
            if(t === 'sandify') {
                if(rawPoints.length > 0) {
                     sandBasePoints = JSON.parse(JSON.stringify(rawPoints));
                     applySandify();
                } else {
                    showToast("Draw something first!", "error");
                }
            }
        }
        
        function updateToolSettings() {
            const area = document.getElementById('toolSettingsArea');
            const grps = document.querySelectorAll('.tool-setting-group');
            grps.forEach(g => g.style.display = 'none');
            
            let activeGrp = null;
            if(currentTool === 'draw') activeGrp = document.getElementById('set-pen');
            if(currentTool === 'erase') activeGrp = document.getElementById('set-erase');
            if(currentTool === 'fill') activeGrp = document.getElementById('set-fill');
            if(currentTool === 'select') activeGrp = document.getElementById('set-select');
            if(currentTool === 'sandify') activeGrp = document.getElementById('set-sandify');
            
            if(activeGrp) {
                area.style.display = 'block';
                activeGrp.style.display = 'block';
            } else {
                area.style.display = 'none';
            }
            eraserRadius = parseInt(document.getElementById('eraserSizeSlider').value);
            document.getElementById('eraseSizeVal').innerText = eraserRadius + 'px';
            fillGap = parseFloat(document.getElementById('fillGapSlider').value);
            document.getElementById('fillGapVal').innerText = fillGap.toFixed(1);
        }

        function updateUI() {
            document.getElementById('symVal').textContent = document.getElementById('symSlider').value + 'x';
            render();
        }
        function showToast(msg, type) {
            const t = document.getElementById('status-toast');
            t.textContent = msg; t.className = type; t.style.opacity = 1;
            setTimeout(()=>t.style.opacity=0, 3000);
        }
        function openNav() { document.getElementById("mySidebar").style.width = "250px"; }
        function closeNav() { document.getElementById("mySidebar").style.width = "0"; }
        function toggleTheme() {
            const b = document.body;
            b.setAttribute('data-theme', b.getAttribute('data-theme')==='dark'?'light':'dark');
            render();
        }
        function resetStatus() {
            generatedGCode = null;
            processedPoints = [];
            document.getElementById('statusTxt').innerText = "Drawing Mode";
            document.getElementById('statusTxt').style.color = "var(--primary)";
            document.getElementById('progressSlider').value = 100;
            render();
        }
        function render() {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            ctx.clearRect(0, 0, w, h);
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const sym = parseInt(document.getElementById('symSlider').value);
            const dark = document.body.getAttribute('data-theme') === 'dark';
            const prog = parseInt(document.getElementById('progressSlider').value);
            document.getElementById('progVal').textContent = prog + '%';
            ctx.save();
            ctx.translate(origin.x, origin.y);
            ctx.beginPath(); ctx.arc(0, 0, tableR*scale, 0, Math.PI*2);
            ctx.strokeStyle = dark ? '#444' : '#ddd'; ctx.lineWidth = 2; ctx.stroke();
            const showingFinal = (processedPoints.length > 0);
            const dataToShow = showingFinal ? processedPoints : rawPoints;
            const limit = Math.floor(dataToShow.length * (prog/100));
            const color = showingFinal ? '#ff0000' : (dark ? 'cyan' : '#007bff');
            ctx.lineWidth = 1.5;
            const loopCount = showingFinal ? 1 : sym;
            for(let s=0; s<loopCount; s++) {
                const ang = s * (Math.PI*2/sym);
                ctx.save(); 
                if(!showingFinal) ctx.rotate(ang); 
                ctx.beginPath();
                ctx.strokeStyle = color;
                let isMove = true;
                for(let i=0; i<limit; i++) {
                    const p = dataToShow[i];
                    if(p.type === 'break' || p.type === 'cmd') { isMove = true; continue; }
                    const px = p.x * scale;
                    const py = -p.y * scale;
                    if(isMove) { ctx.moveTo(px, py); isMove = false; }
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                if(limit > 0 && limit < dataToShow.length) {
                    const tip = dataToShow[limit];
                    if(tip.type !== 'break' && tip.type !== 'cmd') {
                        ctx.beginPath(); ctx.arc(tip.x*scale, -tip.y*scale, 4, 0, Math.PI*2); ctx.fillStyle = color; ctx.fill();
                    }
                }
                ctx.restore();
            }
            if(currentTool === 'select' && rawPoints.length > 0 && !generatedGCode) {
                 let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
                 rawPoints.forEach(p => {
                    if(p.type === 'point') { if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x; if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y; }
                });
                if(minX !== Infinity) {
                    ctx.beginPath(); ctx.rect(minX*scale, -maxY*scale, (maxX-minX)*scale, (maxY-minY)*scale);
                    ctx.strokeStyle = dark ? "white" : "black"; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
                }
            }
            ctx.restore();
        }

        async function sendToTable() { 
            if(!generatedGCode) return showToast("Click Prepare first", "error"); 
            let code = generatedGCode; 
            if(document.getElementById('autoClearMode').checked) { 
                try { let r = await fetch('./designs/clear.txt'); if(r.ok) code = (await r.text()) + "\n" + code; } catch(e) {} 
            } 
            fetch(BASE_URL+'/send_gcode_block', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({gcode:code}) })
            .then(r => r.json()).then(d => showToast(d.success ? "Sent!" : "Error", d.success ? "success" : "error")); 
        }

        async function saveToServer() { 
            if(!generatedGCode) return showToast("Prepare Path first!", "error");
            let n = prompt("Enter filename (will be saved as .txt):"); 
            if(n) {
                if(!n.toLowerCase().endsWith('.txt')) n += ".txt";
                showToast("Saving...", "info");
                fetch(BASE_URL+'/save_design', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({filename:n, gcode:generatedGCode}) })
                .then(r => r.json()).then(d => { if(d.success) showToast("Saved to Pi!", "success"); else showToast("Save Failed: " + (d.error || "Unknown"), "error"); })
                .catch(e => showToast("Network Error", "error"));
            }
        }
        function getShortestRotation(raw, last) {
            let diff = (raw - last) / (2 * Math.PI);
            let offset = Math.round(diff);
            return raw - (offset * 2 * Math.PI);
        }
        function calculateIK(x, y, lastBaseSteps, lastElbowSteps, L1, L2, gearRatio, stepsPerRad) {
            let dist = Math.hypot(x, y);
            if (dist < 2.0) { 
                const targetBaseSteps = lastBaseSteps; 
                const currentBaseAngle = -lastBaseSteps / stepsPerRad;
                const targetElbowSteps = -(Math.PI + gearRatio * currentBaseAngle) * stepsPerRad;
                return { base_steps: targetBaseSteps, elbow_steps: targetElbowSteps };
            }
            const maxReach = L1 + L2;
            if (dist > maxReach) { x = (x / dist) * maxReach; y = (y / dist) * maxReach; dist = maxReach; }
            const lastT1 = -lastBaseSteps / stepsPerRad; 
            let cosBend = (dist*dist - L1*L1 - L2*L2) / (2 * L1 * L2);
            cosBend = Math.max(-1, Math.min(1, cosBend));
            const bend1 = Math.acos(cosBend);
            const bend2 = -Math.acos(cosBend);
            const k1_1 = L1 + L2 * Math.cos(bend1);
            const k2_1 = L2 * Math.sin(bend1);
            let t1_1 = Math.atan2(y, x) - Math.atan2(k2_1, k1_1);
            t1_1 = getShortestRotation(t1_1, lastT1);
            const k1_2 = L1 + L2 * Math.cos(bend2);
            const k2_2 = L2 * Math.sin(bend2);
            let t1_2 = Math.atan2(y, x) - Math.atan2(k2_2, k1_2);
            t1_2 = getShortestRotation(t1_2, lastT1);
            const b1_steps = -t1_1 * stepsPerRad;
            const e1_steps = -(bend1 + gearRatio * t1_1) * stepsPerRad;
            const b2_steps = -t1_2 * stepsPerRad;
            const e2_steps = -(bend2 + gearRatio * t1_2) * stepsPerRad;
            const cost1 = Math.abs(b1_steps - lastBaseSteps) + Math.abs(e1_steps - lastElbowSteps);
            const cost2 = Math.abs(b2_steps - lastBaseSteps) + Math.abs(e2_steps - lastElbowSteps);
            return (cost1 <= cost2) ? { base_steps: b1_steps, elbow_steps: e1_steps } : { base_steps: b2_steps, elbow_steps: e2_steps };
        }
        init();
    </script>
</body>
</html>
