<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Packers Sand Table (Pro Engine)</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

    <style>
        /* --- Dark/Gold Theme (Packers Inspired) --- */
        :root {
            --color-primary: #d2b48c; 
            --color-secondary: #b08d5c; 
            --color-bg: #121212;
            --color-panel: #1e1e1e;
            --color-text: #e0e0e0;
            --color-accent: #2ecc71;
            --radius: 12px;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            margin: 0; padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        .nav-bar {
            padding: 10px 15px; background: var(--color-panel);
            display: flex; justify-content: space-between; align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            z-index: 10;
        }

        /* --- Layout --- */
        .app-container {
            flex: 1; display: flex; flex-direction: column;
            padding: 10px; gap: 10px; overflow: hidden;
        }
        
        @media (min-width: 768px) {
            .app-container { flex-direction: row; }
            .canvas-panel { flex: 2; }
            .controls-panel { flex: 1; min-width: 320px; max-width: 400px; }
        }

        /* --- Canvas --- */
        .canvas-panel {
            background: var(--color-panel); border-radius: var(--radius);
            position: relative; display: flex; align-items: center; justify-content: center;
            overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .canvas-wrapper {
            width: 95%; aspect-ratio: 1/1; max-height: 90vh;
            border: 3px solid var(--color-secondary); border-radius: 50%;
            background: #222; position: relative; overflow: hidden;
        }
        canvas { width: 100%; height: 100%; display: block; border-radius: 50%; }

        /* --- Controls --- */
        .controls-panel {
            background: var(--color-panel); border-radius: var(--radius);
            padding: 15px; overflow-y: auto; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
        button {
            flex: 1; padding: 12px; border: none; border-radius: 8px;
            font-weight: 600; cursor: pointer; transition: 0.2s;
            background: #333; color: white;
        }
        button.primary { background: var(--color-primary); color: #000; }
        button.action { background: var(--color-accent); color: #000; }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        button:active { transform: translateY(0); }

        .slider-row { margin-bottom: 15px; background: #2a2a2a; padding: 10px; border-radius: 8px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; accent-color: var(--color-secondary); }

        /* --- Status --- */
        #status-toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none;
            z-index: 100; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .success { background: #2ecc71 !important; color: #000 !important; }
        .error { background: #e74c3c !important; color: white !important; }

        input[type="file"] { display: none; }
        
        details { background: #2a2a2a; padding: 10px; border-radius: 8px; margin-top: 10px; }
        summary { cursor: pointer; font-size: 13px; font-weight: bold; color: #aaa; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        .settings-grid input { width: 100%; box-sizing: border-box; background: #444; border: 1px solid #555; color: white; padding: 5px; border-radius: 4px; }
    </style>
</head>
<body>

    <div class="nav-bar">
        <h1 style="margin:0; font-size:1.1rem; color:var(--color-primary);">Packers Sand Pro</h1>
        <button style="background:none; border:none; font-size:1.2rem;" onclick="location.reload()">â†º</button>
    </div>

    <div class="app-container">
        <div class="canvas-panel">
            <div class="canvas-wrapper" id="canvasContainer">
                <canvas id="mainCanvas"></canvas>
            </div>
            <div style="position:absolute; bottom:10px; left:10px; font-size:10px; color:#666;">
                Points: <span id="ptCount">0</span>
            </div>
        </div>

        <div class="controls-panel">
            
            <div class="btn-group">
                <input type="file" id="imgUpload" accept="image/*" onchange="processImage(this)">
                <button class="primary" onclick="document.getElementById('imgUpload').click()">ðŸ“‚ Open Image</button>
                <button onclick="clearTable()">âœ– Clear</button>
            </div>

            <div class="slider-row">
                <div class="slider-header"><span>SMOOTHNESS</span> <span id="smoothVal">High</span></div>
                <input type="range" id="smoothSlider" min="0" max="5" value="3" oninput="updateFilters()">
                <div style="font-size:10px; color:#666; margin-top:4px;">Higher = Rounder Curves</div>
            </div>

            <div class="slider-row">
                <div class="slider-header"><span>SIMULATION</span> <span id="simVal">100%</span></div>
                <input type="range" id="simSlider" min="0" max="100" value="100" oninput="render()">
            </div>
            
            <div class="btn-group">
                <button class="action" onclick="sendToTable()">ðŸš€ SEND TO TABLE</button>
                <button onclick="downloadCode()">ðŸ’¾ Save G-Code</button>
            </div>

            <div style="text-align:center; margin-top:10px; font-size:12px; color:#888;">
                Est. Time: <span id="timeEst" style="color:var(--color-primary); font-weight:bold;">0m 0s</span>
            </div>

            <details>
                <summary>Machine Settings</summary>
                <div class="settings-grid">
                    <label>Radius (mm)</label> <input type="number" id="cfgRadius" value="202.6">
                    <label>Arm 1</label> <input type="number" id="cfgL1" value="101.3">
                    <label>Arm 2</label> <input type="number" id="cfgL2" value="101.3">
                    <label>Gear Ratio</label> <input type="number" id="cfgGear" value="1.125">
                </div>
            </details>

        </div>
    </div>

    <div id="status-toast"></div>

    <script>
        // --- CORE VARIABLES ---
        let rawPaths = [];      // Original paths from tracer
        let processedPoints = []; // Final sorted & smoothed points
        let gcode = "";
        
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let tableRadius = 202.6;

        // --- INIT ---
        function init() {
            window.addEventListener('resize', resize);
            resize();
            // Load default settings
            tableRadius = parseFloat(document.getElementById('cfgRadius').value);
        }

        function resize() {
            const container = document.getElementById('canvasContainer');
            const size = container.getBoundingClientRect().width;
            canvas.width = size * window.devicePixelRatio;
            canvas.height = size * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            render();
        }

        // --- 1. IMAGE PROCESSING (The "Input" Stage) ---
        function processImage(input) {
            const file = input.files[0];
            if(!file) return;

            showToast("Analyzing Image...", "info");

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // 1. Pre-process Image (High Contrast for Line Drawings)
                    const tempCan = document.createElement('canvas');
                    const MAX = 1000; 
                    let w = img.width, h = img.height;
                    // Smart resize
                    if(w>h && w>MAX){ h*=MAX/w; w=MAX; }
                    else if(h>MAX){ w*=MAX/h; h=MAX; }
                    
                    tempCan.width = w; tempCan.height = h;
                    const tCtx = tempCan.getContext('2d');
                    tCtx.fillStyle = "white"; tCtx.fillRect(0,0,w,h);
                    
                    // Contrast Filter
                    tCtx.filter = "grayscale(100%) contrast(150%) brightness(100%)";
                    tCtx.drawImage(img, 0, 0, w, h);
                    
                    // 2. Run Tracer
                    const opts = {
                        ltres: 0.1, qtres: 0.1, pathomit: 2, 
                        colorsampling: 2, numberofcolors: 2,
                        blurradius: 0, blurdelta: 10
                    };
                    
                    ImageTracer.imageToSVG(tempCan.toDataURL(), function(svgStr){
                        parseSVG(svgStr);
                    }, opts);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- 2. PARSING & SCALING (The "Normalization" Stage) ---
        function parseSVG(svgStr) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgStr, "image/svg+xml");
            const paths = doc.getElementsByTagName("path");
            
            let extractedPaths = [];
            const samplingRes = 2.0; // mm

            // Extract points from SVG paths
            for(let i=0; i<paths.length; i++) {
                const p = paths[i];
                const len = p.getTotalLength();
                if(len < 5) continue; // Skip noise

                let pts = [];
                for(let d=0; d<=len; d+=samplingRes) {
                    const pt = p.getPointAtLength(d);
                    pts.push({x: pt.x, y: pt.y});
                }
                extractedPaths.push(pts);
            }

            if(extractedPaths.length === 0) return showToast("No shapes found!", "error");

            // Auto-Scale to fit Table (Bounding Box)
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            extractedPaths.forEach(path => path.forEach(p => {
                if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
            }));

            const w = maxX - minX;
            const h = maxY - minY;
            const scale = (tableRadius * 2 * 0.95) / Math.max(w, h);
            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;

            // Normalize
            rawPaths = extractedPaths.map(path => {
                return path.map(p => ({
                    x: (p.x - cx) * scale,
                    y: -(p.y - cy) * scale // Flip Y
                })).filter(p => Math.hypot(p.x, p.y) < tableRadius);
            });

            updateFilters(); // Triggers Optimization & Rendering
            showToast("Trace Successful!", "success");
        }

        // --- 3. OPTIMIZATION & SMOOTHING (The "Pro" Stage) ---
        function updateFilters() {
            if(rawPaths.length === 0) return;

            const smoothLevel = parseInt(document.getElementById('smoothSlider').value);
            document.getElementById('smoothVal').textContent = smoothLevel;

            // A. PATH SORTING (Traveling Salesman - Greedy)
            // Reorder shapes to minimize travel time
            let pool = [...rawPaths];
            let sorted = [];
            let currentPos = {x:0, y:0}; // Start at center

            while(pool.length > 0) {
                let bestIdx = -1;
                let bestDist = Infinity;
                let reverseBest = false;

                for(let i=0; i<pool.length; i++) {
                    const p = pool[i];
                    const start = p[0];
                    const end = p[p.length-1];

                    // Dist to Start
                    const dStart = Math.hypot(start.x-currentPos.x, start.y-currentPos.y);
                    if(dStart < bestDist) {
                        bestDist = dStart;
                        bestIdx = i;
                        reverseBest = false;
                    }

                    // Dist to End (if we draw it backwards)
                    const dEnd = Math.hypot(end.x-currentPos.x, end.y-currentPos.y);
                    if(dEnd < bestDist) {
                        bestDist = dEnd;
                        bestIdx = i;
                        reverseBest = true;
                    }
                }

                let chosen = pool[bestIdx];
                if(reverseBest) chosen.reverse();
                
                sorted.push(chosen);
                currentPos = chosen[chosen.length-1];
                pool.splice(bestIdx, 1);
            }

            // B. SMOOTHING (Chaikin's Algorithm)
            // Runs iteratively based on slider
            let smoothed = [];
            
            sorted.forEach(path => {
                let sp = [...path];
                for(let i=0; i<smoothLevel; i++) {
                    sp = chaikinSmooth(sp);
                }
                smoothed.push({type: 'break'});
                sp.forEach(p => smoothed.push({type:'point', x:p.x, y:p.y}));
            });
            smoothed.push({type:'break'});

            processedPoints = smoothed;
            generateGCode();
            render();
        }

        function chaikinSmooth(points) {
            if(points.length < 3) return points;
            let newPts = [points[0]];
            for(let i=0; i<points.length-1; i++) {
                const p0 = points[i];
                const p1 = points[i+1];
                
                // Cut corners at 25% and 75%
                const Q = { x: 0.75*p0.x + 0.25*p1.x, y: 0.75*p0.y + 0.25*p1.y };
                const R = { x: 0.25*p0.x + 0.75*p1.x, y: 0.25*p0.y + 0.75*p1.y };
                
                newPts.push(Q);
                newPts.push(R);
            }
            newPts.push(points[points.length-1]);
            return newPts;
        }

        // --- 4. ENGINE (V17 Kinematics) ---
        function generateGCode() {
            if(processedPoints.length < 2) return;

            const L1 = parseFloat(document.getElementById('cfgL1').value);
            const L2 = parseFloat(document.getElementById('cfgL2').value);
            const gear = parseFloat(document.getElementById('cfgGear').value);
            const minDelay = 50; 
            
            // Steps calc
            const STEPS_PER_RAD = 8.888888 * (180/Math.PI);

            let cmds = [];
            let time = 0;
            let prevB=0, prevE=0;

            // Initial Move
            const startPt = processedPoints.find(p=>p.type==='point');
            if(startPt) {
                const ik = calcIK(startPt.x, startPt.y, 0, 0, L1, L2, gear, STEPS_PER_RAD);
                prevB = ik.b; prevE = ik.e;
            }

            // Iterate
            for(let i=0; i<processedPoints.length; i++) {
                const p = processedPoints[i];
                if(p.type === 'break') continue;

                // Simple scaling speed (slower near center)
                let r = Math.hypot(p.x, p.y);
                let delay = 500 + (2500 * (r/tableRadius)); // 500us center, 3000us edge

                let ik = calcIK(p.x, p.y, prevB, prevE, L1, L2, gear, STEPS_PER_RAD);
                let db = Math.round(ik.b - prevB);
                let de = Math.round(ik.e - prevE);

                if(db!==0 || de!==0) {
                    cmds.push(`G1 ${de} ${db} ${Math.round(delay)}`);
                    let steps = Math.max(Math.abs(db), Math.abs(de));
                    time += steps * delay;
                    prevB += db; prevE += de;
                }
            }

            gcode = cmds.join('\n');
            
            // Time Calc
            let sec = Math.round(time/1000000);
            let m = Math.floor(sec/60);
            document.getElementById('timeEst').textContent = `${m}m ${sec%60}s`;
            document.getElementById('ptCount').textContent = processedPoints.length;
        }

        // --- KINEMATICS UTILS ---
        function getShortestRot(r, l) {
            let d = (r - l) / (2*Math.PI);
            let o = Math.round(d);
            return r - (o * 2 * Math.PI);
        }

        function calcIK(x, y, lb, le, l1, l2, gr, spr) {
            let d = Math.hypot(x, y);
            let max = l1+l2;
            if(d > max) { x = x*max/d; y = y*max/d; d=max; }
            if(d < 1.0) { // Center Singularity Fix
                let curBase = -lb / spr;
                return { b: lb, e: -(Math.PI + gr * curBase) * spr };
            }

            let lt1 = -lb / spr;
            let cb = (d*d - l1*l1 - l2*l2)/(2*l1*l2);
            cb = Math.max(-1, Math.min(1, cb));
            let b1 = Math.acos(cb), b2 = -Math.acos(cb);
            
            let k1_1 = l1 + l2*Math.cos(b1), k2_1 = l2*Math.sin(b1);
            let t1_1 = getShortestRot(Math.atan2(y,x) - Math.atan2(k2_1, k1_1), lt1);
            
            let k1_2 = l1 + l2*Math.cos(b2), k2_2 = l2*Math.sin(b2);
            let t1_2 = getShortestRot(Math.atan2(y,x) - Math.atan2(k2_2, k1_2), lt1);

            let bs1 = -t1_1 * spr, es1 = -(b1 + gr*t1_1) * spr;
            let bs2 = -t1_2 * spr, es2 = -(b2 + gr*t1_2) * spr;

            let c1 = Math.abs(bs1-lb) + Math.abs(es1-le);
            let c2 = Math.abs(bs2-lb) + Math.abs(es2-le);
            return (c1<=c2) ? {b:bs1, e:es1} : {b:bs2, e:es2};
        }

        // --- RENDER ---
        function render() {
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            const size = Math.min(width, height);
            const scale = (size/2) / (tableRadius*1.05);
            const cx = width/2;
            const cy = height/2;

            ctx.clearRect(0,0,width,height);

            // Bed
            ctx.beginPath(); ctx.arc(cx, cy, tableRadius*scale, 0, Math.PI*2);
            ctx.strokeStyle = "#333"; ctx.lineWidth=2; ctx.stroke();

            // Paths
            if(processedPoints.length === 0) return;

            const limitPct = parseInt(document.getElementById('simSlider').value);
            const limitIdx = Math.floor((processedPoints.length * limitPct)/100);

            ctx.beginPath();
            ctx.strokeStyle = "#d2b48c"; ctx.lineWidth = 1.5;

            let isMove = true;
            for(let i=0; i<limitIdx; i++) {
                const p = processedPoints[i];
                if(p.type==='break') { isMove=true; continue; }
                
                const px = cx + p.x*scale;
                const py = cy - p.y*scale;

                if(isMove) { ctx.moveTo(px, py); isMove=false; }
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Head
            if(limitIdx > 0 && limitIdx < processedPoints.length) {
                const last = processedPoints[limitIdx];
                if(last.type === 'point') {
                    ctx.beginPath();
                    ctx.arc(cx+last.x*scale, cy-last.y*scale, 4, 0, Math.PI*2);
                    ctx.fillStyle = "#2ecc71"; ctx.fill();
                }
            }
        }

        // --- UTILS ---
        function showToast(msg, type) {
            const t = document.getElementById('status-toast');
            t.textContent = msg; t.className = type; t.style.opacity = 1;
            setTimeout(()=>t.style.opacity=0, 3000);
        }
        function sendToTable() {
            if(!gcode) return showToast("No pattern!", "error");
            showToast("Sending...", "info");
            fetch(window.location.origin + '/send_gcode_block', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({gcode: gcode, speed_override: null})
            }).then(r=>r.json()).then(d=>{
                if(d.success) showToast("Sent!", "success");
                else showToast("Error", "error");
            }).catch(()=>showToast("Network Error", "error"));
        }
        function downloadCode() {
            if(!gcode) return;
            const b = new Blob([gcode], {type:'text/plain'});
            const a = document.createElement('a');
            a.download = 'trace_pro.txt'; a.href = URL.createObjectURL(b); a.click();
        }
        function clearTable() {
            processedPoints = []; gcode = ""; rawPaths = [];
            render(); showToast("Cleared", "info");
        }

        init();
    </script>
</body>
</html>
