<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Packers Sand Pro (Synced v32 - The Grandmaster)</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

    <style>
        :root {
            --primary: #d2b48c; 
            --secondary: #b08d5c; 
            --bg: #f4f4f4; 
            --panel: #ffffff; 
            --text: #333; 
            --accent: #2ecc71;
            --danger: #e74c3c;
            --btn-text: #fff;
        }
        body[data-theme='dark'] {
            --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --btn-text: #000;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--bg); color: var(--text);
            margin: 0; padding: 0; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
        }

        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--panel);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100;
        }
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background-color: var(--primary); overflow-x: hidden;
            transition: 0.3s; padding-top: 60px; z-index: 2000;
            box-shadow: 4px 0 10px rgba(0,0,0,0.3);
        }
        .sidebar a {
            padding: 15px 24px; text-decoration: none; font-size: 18px;
            color: #fff; display: block; font-weight: 500;
        }

        .app-container {
            display: flex; flex-direction: column; height: 100%; width: 100%;
            padding: 10px; box-sizing: border-box; gap: 10px; overflow-y: auto;
        }
        @media (min-width: 768px) {
            .app-container { flex-direction: row; overflow: hidden; }
            .drawing-panel { flex: 2; border-radius: 16px; background: var(--panel); position: relative; }
            .controls-panel { flex: 1; max-width: 400px; border-radius: 16px; background: var(--panel); padding: 20px; overflow-y: auto; }
        }
        @media (max-width: 767px) {
            .drawing-panel { width: 100%; aspect-ratio: 1/1; border-radius: 16px; background: var(--panel); flex-shrink: 0; }
            .controls-panel { flex: 1; border-radius: 16px; background: var(--panel); padding: 15px; }
        }

        .canvas-wrapper {
            position: relative; width: 95%; height: 95%; margin: auto;
            aspect-ratio: 1/1; border-radius: 50%;
            border: 4px solid var(--primary); background: #fff;
            touch-action: none; cursor: crosshair; overflow: hidden;
            top: 50%; transform: translateY(-50%);
        }
        body[data-theme='dark'] .canvas-wrapper { background: #222; border-color: var(--secondary); }
        canvas { display: block; width: 100%; height: 100%; border-radius: 50%; }

        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: var(--secondary); text-align: center; }
        .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
        button {
            background: var(--primary); color: var(--btn-text); border: none;
            padding: 12px; border-radius: 8px; font-weight: 600; cursor: pointer;
            flex: 1; transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        button.secondary { background: transparent; border: 1px solid var(--text); color: var(--text); }
        button.active { background: var(--secondary); border: 2px solid var(--text); }
        button.action { background: var(--accent); color: #000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .slider-row { margin-bottom: 15px; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; font-weight: bold; }
        input[type="range"] { width: 100%; accent-color: var(--secondary); }
        
        #progressSlider {
            -webkit-appearance: none; width: 100%; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none;
        }
        #progressSlider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--secondary); cursor: pointer;
        }

        details { background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; }
        summary { cursor: pointer; font-weight: bold; font-size: 13px; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        input[type="number"] { width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; font-family: monospace;}

        #status-toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 3000;
        }
        .success { background: var(--accent) !important; color: #000 !important; }
        .error { background: var(--danger) !important; color: #fff !important; }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 0 5px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-tog { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-tog:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-tog { background-color: var(--secondary); }
        input:checked + .slider-tog:before { transform: translateX(18px); }

    </style>
</head>
<body data-theme="light">

    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Designs</a> 
        <a href="/controls">Drawing</a>
        <a href="/led_controls">LED Controls</a>
        <a href="/ai_builder">AI Builder</a>
        <a href="/terminal">Terminal</a>
    </div>

    <div class="nav-bar">
        <button style="flex:0; background:none; font-size:24px; color:var(--text); padding:0;" onclick="openNav()">‚ò∞</button>
        <h1 style="margin:0; font-size:1.2rem;">Sand Controller</h1>
        <button style="flex:0; background:none; font-size:20px;" onclick="toggleTheme()">‚òÄÔ∏è</button>
    </div>

    <div class="app-container">
        
        <div class="drawing-panel">
            <div class="canvas-wrapper" id="canvasContainer">
                <canvas id="drawCanvas"></canvas>
            </div>
            <div id="coordDisplay" style="position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none;">X:0 Y:0</div>
        </div>

        <div class="controls-panel">
            <h2>Tools</h2>
            
            <div class="toggle-row">
                <span style="font-weight:600; font-size:13px;">üñãÔ∏è Smart Pen Mode</span>
                <label class="switch">
                    <input type="checkbox" id="smartPenMode" checked>
                    <span class="slider-tog"></span>
                </label>
            </div>

            <div class="btn-group">
                <button id="btnDraw" onclick="setTool('draw')" class="active">‚úèÔ∏è Draw</button>
                <button id="btnErase" onclick="setTool('erase')" class="secondary">üßº Erase</button>
            </div>

            <div class="btn-group">
                <input type="file" id="imgUpload" accept="image/*" style="display:none" onchange="handleImageUpload(this)">
                <button class="secondary" onclick="document.getElementById('imgUpload').click()">‚ú® Trace Image</button>
            </div>

            <div class="btn-group">
                <button onclick="undo()" class="secondary">‚Ü∂ Undo</button>
                <button onclick="clearCanvas()" class="secondary" style="color:var(--danger); border-color:var(--danger);">‚úñ Clear</button>
            </div>

            <hr style="border:0; border-top:1px solid #ddd; margin: 15px 0;">
            
             <div class="slider-row">
                <div class="slider-header"><span>SYMMETRY</span> <span id="symVal">1x</span></div>
                <input type="range" id="symSlider" min="1" max="12" value="1" step="1" oninput="updateUI()">
            </div>

            <div class="slider-row">
                <div class="slider-header"><span>SIMULATION (Start ‚Æï Finish)</span> <span id="progVal">100%</span></div>
                <input type="range" id="progressSlider" min="0" max="100" value="100" oninput="render()">
            </div>

            <button class="action" onclick="prepareGCode()" style="margin-bottom:15px; font-size:1.1em;">‚öôÔ∏è Prepare Path</button>

            <div style="text-align:center; font-size:12px; margin-bottom:10px; color:#666;">
                Status: <span id="statusTxt" style="font-weight:bold; color:var(--primary);">Drawing Mode</span>
            </div>

            <div class="toggle-row" style="background:rgba(0,0,0,0.03); padding:8px; border-radius:8px; margin-bottom:10px;">
                <span style="font-weight:600; font-size:13px;">‚ú® Auto-Clear Before Run</span>
                <label class="switch">
                    <input type="checkbox" id="autoClearMode" checked>
                    <span class="slider-tog"></span>
                </label>
            </div>

            <div class="btn-group">
                <button onclick="sendToTable()" class="active">üöÄ Run</button>
                <button onclick="saveToServer()" class="secondary">üíæ Save to Pi</button>
            </div>
            
            <div class="btn-group">
                <button onclick="downloadThetaRho()" class="secondary" style="border-color:#2ecc71; color:#2ecc71;">üì• Copy .THR</button>
            </div>

            <details>
                <summary>‚öôÔ∏è Machine Settings</summary>
                <div class="settings-grid">
                    <div><label>Radius</label><input type="number" id="cfgRadius" value="202.6" onchange="resizeCanvas()"></div>
                    <div><label>Center (us)</label><input type="number" id="cfgCenterDelay" value="500"></div>
                    <div><label>Rim (us)</label><input type="number" id="cfgPerimDelay" value="3000"></div>
                    <div><label>Steps/Deg</label><input type="number" id="cfgStepsPerDeg" value="8.888888"></div>
                    <div><label>Arm 1</label><input type="number" id="cfgL1" value="101.3"></div>
                    <div><label>Arm 2</label><input type="number" id="cfgL2" value="101.3"></div>
                    <div><label>Gear Ratio</label><input type="number" id="cfgGearRatio" value="1.125"></div>
                    <div><label>Resolution</label><input type="number" id="cfgResolution" value="1.0"></div>
                </div>
            </details>
        </div>
    </div>

    <div id="status-toast"></div>

    <script>
        // === GLOBAL STATE ===
        let rawPoints = []; 
        let processedPoints = []; 
        let historyStack = [];
        let isDrawing = false;
        let currentTool = 'draw';
        let origin = {x:0, y:0};
        let scale = 1;
        let generatedGCode = null;
        let generatedThr = null;

        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_URL = window.location.origin;

        // === INITIALIZATION ===
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('pointerdown', startDraw);
            canvas.addEventListener('pointermove', moveDraw);
            canvas.addEventListener('pointerup', endDraw);
            canvas.addEventListener('pointerleave', endDraw);
            canvas.style.touchAction = "none";
            updateUI();
        }

        // === V32: THE GRANDMASTER SOLVER (Simulated Annealing + Weighted A*) ===
        async function prepareGCode() {
            if(rawPoints.length === 0) return showToast("Draw something first!", "error");
            
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const sym = parseInt(document.getElementById('symSlider').value);
            
            // --- STEP 2: IDENTIFY SHAPES ---
            showToast("Step 2: Identifying Shapes...", "info");
            await new Promise(r => setTimeout(r, 20));

            let shapes = groupPointsToShapes(rawPoints);
            
            // Apply Symmetry
            let pool = [];
            for(let s=0; s<sym; s++) {
                const ang = s * (Math.PI*2/sym);
                const c = Math.cos(ang), si = Math.sin(ang);
                shapes.forEach(sh => {
                    pool.push(sh.map(p => ({
                        x: p.x*c - p.y*si,
                        y: p.x*si + p.y*c
                    })));
                });
            }
            if(pool.length === 0) return;

            // --- STEP 1: IDENTIFY ANCHORS (Start/End) ---
            showToast("Step 1: Calculating Anchors...", "info");
            
            // Pre-calc metadata for all shapes
            let shapeMeta = pool.map((s, idx) => {
                const dStartEnd = Math.hypot(s[0].x - s[s.length-1].x, s[0].y - s[s.length-1].y);
                const isClosed = dStartEnd < 15.0; 
                if(isClosed) s[s.length-1] = {x: s[0].x, y: s[0].y}; // Snap Close
                
                // Find point closest to rim
                let minRimD = Infinity;
                for(let p of s) {
                    let d = Math.abs(tableR - Math.hypot(p.x, p.y));
                    if(d < minRimD) minRimD = d;
                }
                
                // Centroid for rough sorting
                let cx=0, cy=0;
                s.forEach(p=>{cx+=p.x; cy+=p.y});
                cx/=s.length; cy/=s.length;

                return { id: idx, points: s, isClosed: isClosed, distToRim: minRimD, centroid:{x:cx,y:cy} };
            });

            // Sort by proximity to rim
            shapeMeta.sort((a,b) => a.distToRim - b.distToRim);
            let startMeta = shapeMeta[0];
            let endMeta = (shapeMeta.length > 1) ? shapeMeta[1] : shapeMeta[0];

            // --- STEP 4 (Part 1): BEST ORDER (Simulated Annealing) ---
            showToast("Step 4: Calculating Optimal Order (Simulated Annealing)...", "info");
            await new Promise(r => setTimeout(r, 20));

            // Optimize the "Middle" shapes
            let middleShapes = shapeMeta.filter(m => m.id !== startMeta.id && m.id !== endMeta.id);
            
            // Run Physics Simulation to find best order
            let optimizedOrder = runSimulatedAnnealing(middleShapes);
            
            // Build Sequence: Start -> Optimized Middle -> End
            let finalSequence = [startMeta, ...optimizedOrder];
            if(endMeta.id !== startMeta.id) finalSequence.push(endMeta);

            // --- STEP 3: RECALCULATE START/END POINTS ---
            // Orient shapes so entry/exit aligns with flow
            let optimizedShapes = optimizeSeams(finalSequence, tableR);

            // --- STEP 4 (Part 2): REARRANGE TRAVEL LINES (A* Outliner) ---
            showToast("Step 4: Routing with Point System (1mm=100pts)...", "info");
            await new Promise(r => setTimeout(r, 50));

            // Build Collision Grid
            // 2mm resolution for accuracy
            const gridSize = 2.0; 
            const grid = new Map();
            const toKey = (x,y) => `${Math.floor(x/gridSize)},${Math.floor(y/gridSize)}`;
            
            // Mark existing lines as "Cheap"
            for(let shapePts of optimizedShapes) {
                for(let p of shapePts) {
                    // Mark point and neighbors to thicken the "road"
                    let k = toKey(p.x, p.y);
                    grid.set(k, 1);
                }
            }

            processedPoints = [];
            
            // 1. Entry (Rim -> Start)
            let firstPt = optimizedShapes[0][0];
            let ang = Math.atan2(firstPt.y, firstPt.x);
            processedPoints.push({x: tableR*Math.cos(ang), y: tableR*Math.sin(ang), type:'point'});

            // 2. Connect Sequence
            for(let i=0; i<optimizedShapes.length; i++) {
                // Add Shape
                optimizedShapes[i].forEach(p => processedPoints.push({x:p.x, y:p.y, type:'point'}));
                
                // Route to Next
                if(i < optimizedShapes.length - 1) {
                    let currEnd = optimizedShapes[i][optimizedShapes[i].length-1];
                    let nextStart = optimizedShapes[i+1][0];
                    let dist = Math.hypot(nextStart.x-currEnd.x, nextStart.y-currEnd.y);
                    
                    if(dist > 3.0) {
                        // A* Router with 100pt Penalty logic
                        let route = findWeightedPath(currEnd, nextStart, grid, gridSize);
                        route.forEach(p => processedPoints.push({x:p.x, y:p.y, type:'point'}));
                    }
                }
            }

            // 3. Exit (End -> Rim)
            let lastPt = processedPoints[processedPoints.length-1];
            let exAng = Math.atan2(lastPt.y, lastPt.x);
            processedPoints.push({x: tableR*Math.cos(exAng), y: tableR*Math.sin(exAng), type:'exit'});

            // 4. Simplify
            processedPoints = simplifyPath(processedPoints, 0.5);

            generateKinematicsGCode(processedPoints);
            
            document.getElementById('statusTxt').innerText = "AI Path: Grandmaster";
            document.getElementById('statusTxt').style.color = "#2ecc71";
            document.getElementById('progressSlider').value = 0;
            render(); 
            showToast("Grandmaster Optimization Complete!", "success");
        }

        // --- ALGORITHMS ---

        function groupPointsToShapes(points) {
            let shapes = [];
            let cur = [];
            points.forEach(p => {
                if(p.type === 'break' || p.type === 'exit') {
                    if(cur.length > 0) shapes.push(cur);
                    cur = [];
                } else {
                    cur.push({x:p.x, y:p.y});
                }
            });
            if(cur.length > 0) shapes.push(cur);
            return shapes;
        }

        // Simulated Annealing (The Order Solver)
        function runSimulatedAnnealing(shapes) {
            if(shapes.length < 2) return shapes;
            let current = [...shapes];
            let best = [...shapes];
            let bestCost = calculateTotalDist(best);
            let temp = 1000, cooling = 0.99;

            for(let i=0; i<3000; i++) {
                let a = Math.floor(Math.random()*current.length);
                let b = Math.floor(Math.random()*current.length);
                
                swap(current, a, b);
                let newCost = calculateTotalDist(current);
                
                if(newCost < bestCost || Math.random() < Math.exp((bestCost - newCost)/temp)) {
                    if(newCost < bestCost) { bestCost = newCost; best = [...current]; }
                } else {
                    swap(current, a, b); // revert
                }
                temp *= cooling;
            }
            return best;
        }
        function calculateTotalDist(arr) {
            let d=0;
            for(let i=0; i<arr.length-1; i++) d += distSq(arr[i].centroid, arr[i+1].centroid);
            return d;
        }
        function swap(arr, a, b) { let t=arr[a]; arr[a]=arr[b]; arr[b]=t; }

        // Seam Optimization
        function optimizeSeams(sequence, tableR) {
            let optimized = [];
            let headPos = {x: tableR, y: 0};

            for(let meta of sequence) {
                let pts = [...meta.points];
                if(meta.isClosed) {
                    // Rotate to start closest to headPos
                    let bestIdx = 0, minD = Infinity;
                    for(let k=0; k<pts.length; k+=2) {
                        let d = distSq(headPos, pts[k]);
                        if(d < minD) { minD = d; bestIdx = k; }
                    }
                    pts = rotateArray(pts, bestIdx);
                } else {
                    // Flip if needed
                    let dStart = distSq(headPos, pts[0]);
                    let dEnd = distSq(headPos, pts[pts.length-1]);
                    if(dEnd < dStart) pts.reverse();
                }
                optimized.push(pts);
                headPos = pts[pts.length-1];
            }
            return optimized;
        }

        // Weighted A* (The Outliner)
        function findWeightedPath(start, end, grid, gridSize) {
            const toKey = (x,y) => `${Math.floor(x/gridSize)},${Math.floor(y/gridSize)}`;
            const h = (n) => Math.hypot(n.x-end.x, n.y-end.y) * 10; // Heuristic weight

            let open = [{x:start.x, y:start.y, g:0, f:0, parent:null}];
            let closed = new Set();
            let count = 0, maxNodes = 3000; // Allow deep thought

            while(open.length > 0 && count++ < maxNodes) {
                open.sort((a,b) => a.f - b.f);
                let curr = open.shift();

                // Check Goal
                if(Math.hypot(curr.x-end.x, curr.y-end.y) < gridSize * 2) {
                    let path = [];
                    while(curr.parent) { path.push({x:curr.x, y:curr.y}); curr = curr.parent; }
                    return path.reverse();
                }

                let k = toKey(curr.x, curr.y);
                if(closed.has(k)) continue;
                closed.add(k);

                // 8 Neighbors
                let dirs = [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0},{x:1,y:1},{x:1,y:-1},{x:-1,y:1},{x:-1,y:-1}];
                
                for(let d of dirs) {
                    let nx = curr.x + d.x * gridSize;
                    let ny = curr.y + d.y * gridSize;
                    let nk = toKey(nx, ny);
                    
                    // THE POINT SYSTEM:
                    // On Grid (Line) = 1 Point
                    // Off Grid (Sand) = 100 Points
                    let moveCost = grid.has(nk) ? 1 : 100;
                    
                    let newG = curr.g + moveCost;
                    open.push({x:nx, y:ny, g:newG, f:newG + h({x:nx, y:ny}), parent:curr});
                }
            }
            return []; // Fail -> Straight line
        }

        // --- UTILS ---
        function distSq(p1, p2) { return (p1.x-p2.x)**2 + (p1.y-p2.y)**2; }
        function rotateArray(arr, idx) {
            if(idx === 0) return [...arr];
            let p1 = arr.slice(idx), p2 = arr.slice(0, idx);
            let n = p1.concat(p2); n.push({x:n[0].x, y:n[0].y}); return n;
        }
        function simplifyPath(points, tol) {
            if(points.length < 3) return points;
            let newPts = [points[0]], last = points[0];
            for(let i=1; i<points.length-1; i++) {
                if(Math.hypot(points[i].x-last.x, points[i].y-last.y) > tol) {
                    newPts.push(points[i]); last = points[i];
                }
            }
            newPts.push(points[points.length-1]); return newPts;
        }

        // --- G-CODE GEN ---
        function generateKinematicsGCode(pathPoints) {
            const L1 = parseFloat(document.getElementById('cfgL1').value);
            const L2 = parseFloat(document.getElementById('cfgL2').value);
            const gearRatio = parseFloat(document.getElementById('cfgGearRatio').value);
            const stepsPerDeg = parseFloat(document.getElementById('cfgStepsPerDeg').value);
            const tableRadius = parseFloat(document.getElementById('cfgRadius').value);
            const centerDelay = parseFloat(document.getElementById('cfgCenterDelay').value);
            const perimDelay = parseFloat(document.getElementById('cfgPerimDelay').value);
            const res = parseFloat(document.getElementById('cfgResolution').value) || 1.0;
            const stepsPerRad = stepsPerDeg * (180 / Math.PI);

            let commands = [];
            let prevBase = 0, prevElbow = 0;
            let fullPath = [{x:0, y:0}].concat(pathPoints); 

            for (let i = 0; i < fullPath.length - 1; i++) {
                let p1 = fullPath[i], p2 = fullPath[i+1];
                if (p2.type === 'exit') commands.push("M0"); 

                let dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                let steps = Math.ceil(dist / res);
                steps = Math.max(1, steps);

                for (let j = 1; j <= steps; j++) {
                    let t = j / steps;
                    let x = p1.x + (p2.x - p1.x) * t;
                    let y = p1.y + (p2.y - p1.y) * t;

                    let ik = calculateIK(x, y, prevBase, prevElbow, L1, L2, gearRatio, stepsPerRad);
                    let dBase = Math.round(ik.base_steps - prevBase);
                    let dElbow = Math.round(ik.elbow_steps - prevElbow);

                    if (dBase !== 0 || dElbow !== 0) {
                        let rFactor = Math.min(1.0, Math.hypot(x, y) / tableRadius);
                        let delay = Math.round(centerDelay + ((perimDelay - centerDelay) * rFactor));
                        commands.push(`G1 ${dElbow} ${dBase} ${delay}`);
                        prevBase += dBase; prevElbow += dElbow;
                    }
                }
            }
            generatedGCode = commands.join('\n');
            
            let thrLines = ["# format: thetarho"];
            let prevTheta = 0, cumTheta = 0, isFirst = true;
            for(let p of pathPoints) {
                if(p.type !== 'exit') {
                    let rho = Math.min(1.0, Math.hypot(p.x, p.y) / tableRadius);
                    let rawTheta = Math.atan2(p.y, p.x);
                    if(isFirst) { cumTheta = rawTheta; prevTheta = rawTheta; isFirst = false; }
                    else {
                        let diff = rawTheta - prevTheta;
                        while(diff <= -Math.PI) diff += 2*Math.PI;
                        while(diff > Math.PI) diff -= 2*Math.PI;
                        cumTheta += diff; prevTheta = rawTheta;
                    }
                    thrLines.push(`${cumTheta.toFixed(5)} ${rho.toFixed(5)}`);
                }
            }
            generatedThr = thrLines.join('\n');
        }

        function calculateIK(x, y, lastBase, lastElbow, L1, L2, gr, spr) {
            let dist = Math.hypot(x, y);
            const maxReach = L1 + L2;
            if (dist > maxReach) { x = (x/dist)*maxReach; y = (y/dist)*maxReach; dist = maxReach; }
            if (dist < 1.0) { 
                return { base_steps: lastBase, elbow_steps: -(Math.PI + gr * (-lastBase/spr)) * spr };
            }
            let cosBend = (dist*dist - L1*L1 - L2*L2) / (2*L1*L2);
            cosBend = Math.max(-1, Math.min(1, cosBend));
            const bend1 = Math.acos(cosBend), bend2 = -Math.acos(cosBend);
            const lastT1 = -lastBase / spr;

            const k1_1 = L1 + L2 * Math.cos(bend1), k2_1 = L2 * Math.sin(bend1);
            let t1_1 = Math.atan2(y, x) - Math.atan2(k2_1, k1_1);
            t1_1 = getShortest(t1_1, lastT1);

            const k1_2 = L1 + L2 * Math.cos(bend2), k2_2 = L2 * Math.sin(bend2);
            let t1_2 = Math.atan2(y, x) - Math.atan2(k2_2, k1_2);
            t1_2 = getShortest(t1_2, lastT1);

            const b1 = -t1_1 * spr, e1 = -(bend1 + gr * t1_1) * spr;
            const b2 = -t1_2 * spr, e2 = -(bend2 + gr * t1_2) * spr;
            const cost1 = Math.abs(b1 - lastBase) + Math.abs(e1 - lastElbow);
            const cost2 = Math.abs(b2 - lastBase) + Math.abs(e2 - lastElbow);
            return (cost1 <= cost2) ? {base_steps:b1, elbow_steps:e1} : {base_steps:b2, elbow_steps:e2};
        }
        function getShortest(raw, last) {
            let diff = (raw - last) / (2 * Math.PI);
            return raw - (Math.round(diff) * 2 * Math.PI);
        }

        // --- DRAWING ---
        function startDraw(e) { e.preventDefault(); if(document.getElementById('smartPenMode').checked) currentTool = e.pointerType==='pen'?'draw':'erase'; saveState(); isDrawing=true; canvas.setPointerCapture(e.pointerId); processPointer(e); resetStatus(); }
        function moveDraw(e) { e.preventDefault(); if(!isDrawing) { render(); drawCursor(getPos(e)); return; } processPointer(e); }
        function endDraw(e) { if(!isDrawing) return; isDrawing=false; if(currentTool==='draw') rawPoints.push({type:'break'}); canvas.releasePointerCapture(e.pointerId); render(); }
        function getPos(e) { return { x: (e.offsetX - origin.x)/scale, y: -(e.offsetY - origin.y)/scale }; }
        function processPointer(e) { const p=getPos(e); if(currentTool==='draw') rawPoints.push({x:p.x, y:p.y, type:'point'}); else rawPoints=rawPoints.filter(pt=>Math.hypot(pt.x-p.x, pt.y-p.y)>10); render(); if(currentTool==='erase') drawCursor(p); }
        
        async function sendToTable() { if(!generatedGCode) return showToast("Click Prepare first", "error"); let code=generatedGCode; if(document.getElementById('autoClearMode').checked) { try{let r=await fetch('./designs/clear.txt'); if(r.ok) code=(await r.text())+"\n"+code;}catch(e){} } fetch(BASE_URL+'/send_gcode_block', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({gcode:code})}).then(r=>r.json()).then(d=>showToast(d.success?"Sent!":"Error","success")); }
        async function saveToServer() { let n=prompt("Name:"); if(n) fetch(BASE_URL+'/save_design', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({filename:n, gcode:generatedGCode})}).then(r=>r.json()).then(d=>showToast("Saved","success")); }
        function downloadThetaRho() { if(!generatedThr) return; if(navigator.clipboard && window.isSecureContext) navigator.clipboard.writeText(generatedThr); else fallbackCopyTextToClipboard(generatedThr); showToast("Copied","success"); }
        function fallbackCopyTextToClipboard(text) { var t=document.createElement("textarea"); t.value=text; document.body.appendChild(t); t.select(); document.execCommand('copy'); document.body.removeChild(t); }
        
        // --- BOILERPLATE ---
        function resizeCanvas() { const c=document.getElementById('canvasContainer'); canvas.width=c.clientWidth; canvas.height=c.clientHeight; origin={x:canvas.width/2, y:canvas.height/2}; scale=(canvas.width/2)/(parseFloat(document.getElementById('cfgRadius').value)*1.1); render(); }
        function saveState() { if(historyStack.length>10) historyStack.shift(); historyStack.push(JSON.stringify(rawPoints)); }
        function undo() { if(historyStack.length) { rawPoints=JSON.parse(historyStack.pop()); render(); } }
        function clearCanvas() { saveState(); rawPoints=[]; render(); }
        function setTool(t) { currentTool=t; document.getElementById('btnDraw').className=t==='draw'?'active':'secondary'; document.getElementById('btnErase').className=t==='erase'?'active':'secondary'; }
        function updateUI() { document.getElementById('symVal').textContent = document.getElementById('symSlider').value + 'x'; render(); }
        function showToast(msg, type) { const t=document.getElementById('status-toast'); t.textContent=msg; t.className=type; t.style.opacity=1; setTimeout(()=>t.style.opacity=0, 3000); }
        function openNav() { document.getElementById("mySidebar").style.width = "250px"; }
        function closeNav() { document.getElementById("mySidebar").style.width = "0"; }
        function toggleTheme() { document.body.setAttribute('data-theme', document.body.getAttribute('data-theme')==='dark'?'light':'dark'); render(); }

        init();
    </script>
</body>
</html>
