<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Packers Sand Pro (Rim Optimized)</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

    <style>
        :root {
            --primary: #d2b48c; 
            --secondary: #b08d5c; 
            --bg: #f4f4f4; 
            --panel: #ffffff; 
            --text: #333;
            --accent: #2ecc71;
            --danger: #e74c3c;
            --btn-text: #fff;
        }
        body[data-theme='dark'] {
            --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --btn-text: #000;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--bg); color: var(--text);
            margin: 0; padding: 0; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
        }

        /* --- Header --- */
        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--panel);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100;
        }
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background-color: var(--primary); overflow-x: hidden;
            transition: 0.3s; padding-top: 60px; z-index: 2000;
            box-shadow: 4px 0 10px rgba(0,0,0,0.3);
        }
        .sidebar a {
            padding: 15px 24px; text-decoration: none; font-size: 18px;
            color: #fff; display: block; font-weight: 500;
        }

        /* --- Layout --- */
        .app-container {
            display: flex; flex-direction: column; height: 100%; width: 100%;
            padding: 10px; box-sizing: border-box; gap: 10px; overflow-y: auto;
        }
        @media (min-width: 768px) {
            .app-container { flex-direction: row; overflow: hidden; }
            .drawing-panel { flex: 2; border-radius: 16px; background: var(--panel); position: relative; }
            .controls-panel { flex: 1; max-width: 400px; border-radius: 16px; background: var(--panel); padding: 20px; overflow-y: auto; }
        }
        @media (max-width: 767px) {
            .drawing-panel { width: 100%; aspect-ratio: 1/1; border-radius: 16px; background: var(--panel); flex-shrink: 0; }
            .controls-panel { flex: 1; border-radius: 16px; background: var(--panel); padding: 15px; }
        }

        /* --- Canvas --- */
        .canvas-wrapper {
            position: relative; width: 95%; height: 95%; margin: auto;
            aspect-ratio: 1/1; border-radius: 50%;
            border: 4px solid var(--primary); background: #fff;
            touch-action: none; cursor: crosshair; overflow: hidden;
            top: 50%; transform: translateY(-50%);
        }
        body[data-theme='dark'] .canvas-wrapper { background: #222; border-color: var(--secondary); }
        canvas { display: block; width: 100%; height: 100%; border-radius: 50%; }

        /* --- Controls --- */
        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: var(--secondary); text-align: center; }
        .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
        button {
            background: var(--primary); color: var(--btn-text); border: none;
            padding: 12px; border-radius: 8px; font-weight: 600; cursor: pointer;
            flex: 1; transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        button.secondary { background: transparent; border: 1px solid var(--text); color: var(--text); }
        button.active { background: var(--secondary); border: 2px solid var(--text); }
        button.action { background: var(--accent); color: #000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .slider-row { margin-bottom: 15px; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; font-weight: bold; }
        input[type="range"] { width: 100%; accent-color: var(--secondary); }
        
        #progressSlider {
            -webkit-appearance: none; width: 100%; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none;
        }
        #progressSlider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--secondary); cursor: pointer;
        }

        details { background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; }
        summary { cursor: pointer; font-weight: bold; font-size: 13px; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        input[type="number"] { width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; font-family: monospace;}

        #status-toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 3000;
        }
        .success { background: var(--accent) !important; color: #000 !important; }
        .error { background: var(--danger) !important; color: #fff !important; }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 0 5px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-tog { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-tog:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-tog { background-color: var(--secondary); }
        input:checked + .slider-tog:before { transform: translateX(18px); }

    </style>
</head>
<body data-theme="light">

    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Designs</a> 
        <a href="/controls">Drawing</a>
        <a href="/led_controls">LED Controls</a>
        <a href="/ai_builder">AI Builder</a>
        <a href="/terminal">Terminal</a>
    </div>

    <div class="nav-bar">
        <button style="flex:0; background:none; font-size:24px; color:var(--text); padding:0;" onclick="openNav()">‚ò∞</button>
        <h1 style="margin:0; font-size:1.2rem;">Sand Controller</h1>
        <button style="flex:0; background:none; font-size:20px;" onclick="toggleTheme()">‚òÄÔ∏è</button>
    </div>

    <div class="app-container">
        
        <div class="drawing-panel">
            <div class="canvas-wrapper" id="canvasContainer">
                <canvas id="drawCanvas"></canvas>
            </div>
            <div id="coordDisplay" style="position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none;">X:0 Y:0</div>
        </div>

        <div class="controls-panel">
            <h2>Tools</h2>
            
            <div class="toggle-row">
                <span style="font-weight:600; font-size:13px;">üñãÔ∏è Smart Pen Mode</span>
                <label class="switch">
                    <input type="checkbox" id="smartPenMode" checked>
                    <span class="slider-tog"></span>
                </label>
            </div>

            <div class="btn-group">
                <button id="btnDraw" onclick="setTool('draw')" class="active">‚úèÔ∏è Draw</button>
                <button id="btnErase" onclick="setTool('erase')" class="secondary">üßº Erase</button>
            </div>

            <div class="btn-group">
                <input type="file" id="imgUpload" accept="image/*" style="display:none" onchange="handleImageUpload(this)">
                <button class="secondary" onclick="document.getElementById('imgUpload').click()">‚ú® Trace Image</button>
            </div>

            <div class="btn-group">
                <button onclick="undo()" class="secondary">‚Ü∂ Undo</button>
                <button onclick="clearCanvas()" class="secondary" style="color:var(--danger); border-color:var(--danger);">‚úñ Clear</button>
            </div>

            <hr style="border:0; border-top:1px solid #ddd; margin: 15px 0;">
            
             <div class="slider-row">
                <div class="slider-header"><span>SYMMETRY</span> <span id="symVal">1x</span></div>
                <input type="range" id="symSlider" min="1" max="12" value="1" step="1" oninput="updateUI()">
            </div>

            <div class="slider-row">
                <div class="slider-header"><span>SIMULATION (Start ‚Æï Finish)</span> <span id="progVal">100%</span></div>
                <input type="range" id="progressSlider" min="0" max="100" value="100" oninput="render()">
            </div>

            <button class="action" onclick="prepareGCode()" style="margin-bottom:15px; font-size:1.1em;">‚öôÔ∏è Prepare Path</button>

            <div style="text-align:center; font-size:12px; margin-bottom:10px; color:#666;">
                Lines: <span id="ptCount" style="font-weight:bold;">0</span> | 
                Status: <span id="statusTxt" style="font-weight:bold; color:var(--primary);">Drawing Mode</span>
            </div>

            <div class="btn-group">
                <button onclick="sendToTable()" class="active">üöÄ Run</button>
                <button onclick="downloadGcode()" class="secondary">üíæ Save</button>
            </div>

            <details>
                <summary>‚öôÔ∏è Machine Settings</summary>
                <div class="settings-grid">
                    <div><label>Radius</label><input type="number" id="cfgRadius" value="202.6" onchange="resizeCanvas()"></div>
                    <div><label>Center Speed</label><input type="number" id="cfgCenterDelay" value="500"></div>
                    <div><label>Rim Speed</label><input type="number" id="cfgPerimDelay" value="3000"></div>
                    <div><label>Steps/Deg</label><input type="number" id="cfgStepsPerDeg" value="8.888888"></div>
                    <div><label>Arm 1</label><input type="number" id="cfgL1" value="101.3"></div>
                    <div><label>Arm 2</label><input type="number" id="cfgL2" value="101.3"></div>
                </div>
            </details>
        </div>
    </div>

    <div id="status-toast"></div>

    <script>
        // --- GLOBAL STATE ---
        let rawPoints = []; // User Input (Blue Line)
        let processedPoints = []; // Final G-Code Points (Red Line - includes travel)
        let historyStack = [];
        let isDrawing = false;
        let currentTool = 'draw';
        let origin = {x:0, y:0};
        let scale = 1;
        let generatedGCode = null;

        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_URL = window.location.origin;

        // --- INIT ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('pointerdown', startDraw);
            canvas.addEventListener('pointermove', moveDraw);
            canvas.addEventListener('pointerup', endDraw);
            canvas.addEventListener('pointerleave', endDraw);
            canvas.style.touchAction = "none";
            
            updateUI();
        }

        // --- DRAWING LOGIC ---
        function startDraw(e) {
            e.preventDefault();
            const smart = document.getElementById('smartPenMode').checked;
            if(smart) {
                if(e.pointerType === 'pen') setTool('draw');
                else if(e.pointerType === 'touch') setTool('erase');
            }
            saveState();
            isDrawing = true;
            canvas.setPointerCapture(e.pointerId);
            processPointer(e);
            resetStatus();
        }

        function moveDraw(e) {
            e.preventDefault();
            const pos = getPos(e);
            document.getElementById('coordDisplay').textContent = `X:${pos.x.toFixed(0)} Y:${pos.y.toFixed(0)}`;
            if(!isDrawing) { render(); drawCursor(pos); return; }
            processPointer(e);
        }

        function endDraw(e) {
            if(!isDrawing) return;
            isDrawing = false;
            if(currentTool === 'draw') rawPoints.push({type:'break'});
            canvas.releasePointerCapture(e.pointerId);
            render();
        }

        function getPos(e) {
            return {
                x: (e.offsetX - origin.x) / scale,
                y: -(e.offsetY - origin.y) / scale
            };
        }

        function processPointer(e) {
            const p = getPos(e);
            if(currentTool === 'draw') {
                rawPoints.push({x: p.x, y: p.y, type: 'point'});
            } else {
                const r = 10;
                rawPoints = rawPoints.filter(pt => {
                    if(pt.type === 'break') return true;
                    return Math.hypot(pt.x - p.x, pt.y - p.y) > r;
                });
            }
            render();
            if(currentTool==='erase') drawCursor(p);
        }

        function drawCursor(p) {
            if(currentTool !== 'erase') return;
            const r = 10 * scale;
            const px = origin.x + p.x * scale;
            const py = origin.y - p.y * scale;
            ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2);
            ctx.strokeStyle = "#999"; ctx.fillStyle = "rgba(200,200,200,0.3)";
            ctx.stroke(); ctx.fill();
        }

        function resetStatus() {
            generatedGCode = null;
            processedPoints = [];
            document.getElementById('statusTxt').innerText = "Drawing Mode";
            document.getElementById('statusTxt').style.color = "orange";
            document.getElementById('progressSlider').value = 100;
        }

        // --- RENDERER ---
        function render() {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            ctx.clearRect(0, 0, w, h);
            
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const sym = parseInt(document.getElementById('symSlider').value);
            const dark = document.body.getAttribute('data-theme') === 'dark';
            const prog = parseInt(document.getElementById('progressSlider').value);
            document.getElementById('progVal').textContent = prog + '%';

            ctx.save();
            ctx.translate(origin.x, origin.y);

            // Table Circle
            ctx.beginPath(); ctx.arc(0, 0, tableR*scale, 0, Math.PI*2);
            ctx.strokeStyle = dark ? '#444' : '#ddd'; ctx.lineWidth = 2; ctx.stroke();

            // RENDER LOGIC:
            const showingFinal = (processedPoints.length > 0);
            const dataToShow = showingFinal ? processedPoints : rawPoints;
            const limit = Math.floor(dataToShow.length * (prog/100));
            
            // Color: Blue for Edit, Red for Final Simulation
            const color = showingFinal ? '#ff0000' : (dark ? 'cyan' : '#007bff');

            ctx.lineWidth = 1.5;
            
            // Symmetry Loop
            const loopCount = showingFinal ? 1 : sym;

            for(let s=0; s<loopCount; s++) {
                const ang = s * (Math.PI*2/sym);
                ctx.save(); 
                if(!showingFinal) ctx.rotate(ang); 
                
                ctx.beginPath();
                ctx.strokeStyle = color;
                
                let isMove = true;
                for(let i=0; i<limit; i++) {
                    const p = dataToShow[i];
                    if(p.type === 'break') { isMove = true; continue; }
                    
                    const px = p.x * scale;
                    const py = -p.y * scale;
                    
                    if(isMove) { ctx.moveTo(px, py); isMove = false; }
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                
                // Draw Head
                if(limit > 0 && limit < dataToShow.length) {
                    const tip = dataToShow[limit];
                    if(tip.type !== 'break') {
                        ctx.beginPath(); 
                        ctx.arc(tip.x*scale, -tip.y*scale, 4, 0, Math.PI*2);
                        ctx.fillStyle = color; ctx.fill();
                    }
                }

                ctx.restore();
            }
            ctx.restore();
        }

        // --- AI TRACER ---
        function handleImageUpload(input) {
            const file = input.files[0];
            if(!file) return;
            showToast("Scanning...", "info");
            saveState();

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const tCan = document.createElement('canvas');
                    const MAX = 1000;
                    let tw = img.width, th = img.height;
                    if(tw>th && tw>MAX){ th*=MAX/tw; tw=MAX; } 
                    else if(th>MAX){ tw*=MAX/th; th=MAX; }
                    
                    tCan.width = tw; tCan.height = th;
                    const tCtx = tCan.getContext('2d');
                    tCtx.fillStyle = "white"; tCtx.fillRect(0,0,tw,th);
                    tCtx.filter = "grayscale(100%) contrast(150%)";
                    tCtx.drawImage(img, 0, 0, tw, th);
                    
                    ImageTracer.imageToSVG(tCan.toDataURL(), function(svgStr){
                        processTrace(svgStr, tw, th);
                    }, { ltres:0.5, qtres:0.5, pathomit:2, colorsampling:2, numberofcolors:2 });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processTrace(svgStr, imgW, imgH) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgStr, "image/svg+xml");
            const paths = doc.getElementsByTagName("path");
            let strokes = [];
            const res = 2.0; 

            for(let i=0; i<paths.length; i++) {
                const p = paths[i];
                const len = p.getTotalLength();
                if(len < 5) continue; 
                
                let pts = [];
                let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;

                for(let d=0; d<=len; d+=res) {
                    const pt = p.getPointAtLength(d);
                    pts.push({x: pt.x, y: pt.y});
                    if(pt.x<minX) minX=pt.x; if(pt.x>maxX) maxX=pt.x;
                    if(pt.y<minY) minY=pt.y; if(pt.y>maxY) maxY=pt.y;
                }
                
                const w = maxX - minX;
                const h = maxY - minY;
                if (w > imgW * 0.98 || h > imgH * 0.98) continue; 
                strokes.push(pts);
            }

            if(strokes.length === 0) return showToast("No shapes found", "error");

            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            strokes.flat().forEach(p => {
                if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
            });
            
            const contentW = maxX - minX;
            const contentH = maxY - minY;
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const scaleFac = (tableR * 2 * 0.9) / Math.max(contentW, contentH);
            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;

            let normalizedStrokes = strokes.map(s => {
                return s.map(p => ({
                    x: (p.x - cx) * scaleFac,
                    y: -(p.y - cy) * scaleFac 
                })).filter(p => Math.hypot(p.x, p.y) < tableR);
            });

            rawPoints = [];
            normalizedStrokes.forEach(s => {
                rawPoints.push({type:'break'});
                s.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'}));
            });
            rawPoints.push({type:'break'});

            resetStatus();
            showToast("Trace Loaded (Click Prepare)", "info");
            render();
        }

        // --- OPTIMIZER LOGIC (THE BRAIN) ---
        function prepareGCode() {
            if(rawPoints.length === 0) return showToast("Draw something first!", "error");
            showToast("Calculating Best Route...", "info");

            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const sym = parseInt(document.getElementById('symSlider').value);
            
            // 1. Separate Shapes
            let shapes = [];
            let curShape = [];
            rawPoints.forEach(p => {
                if(p.type === 'break') {
                    if(curShape.length > 0) shapes.push(curShape);
                    curShape = [];
                } else {
                    curShape.push(p);
                }
            });
            if(curShape.length > 0) shapes.push(curShape);

            // 2. Expand Symmetry
            let pool = [];
            for(let s=0; s<sym; s++) {
                const ang = s * (Math.PI*2/sym);
                const c = Math.cos(ang), si = Math.sin(ang);
                shapes.forEach(sh => {
                    let newSh = sh.map(p => ({
                        x: p.x*c - p.y*si,
                        y: p.x*si + p.y*c,
                        type: 'point'
                    }));
                    pool.push(newSh);
                });
            }

            // --- STEP 3: FIND ABSOLUTE BEST START POINT (Closest to Rim) ---
            // Scan EVERY pixel of EVERY shape to find the one closest to perimeter.
            let bestShapeIdx = -1;
            let bestPointIdx = -1;
            let maxDist = -1;

            for (let i=0; i<pool.length; i++) {
                for (let j=0; j<pool[i].length; j++) {
                    let d = Math.hypot(pool[i][j].x, pool[i][j].y);
                    if (d > maxDist) {
                        maxDist = d;
                        bestShapeIdx = i;
                        bestPointIdx = j;
                    }
                }
            }

            // Extract Start Shape
            let startShape = pool[bestShapeIdx];
            pool.splice(bestShapeIdx, 1);

            // ROTATE/REVERSE Start Shape to align with that point
            // Check if closed loop (tolerance 5mm)
            let dClose = Math.hypot(startShape[0].x - startShape[startShape.length-1].x, startShape[0].y - startShape[startShape.length-1].y);
            if(dClose < 5.0) {
                // Closed Loop: Rotate points so bestPointIdx is the first point
                const part1 = startShape.slice(bestPointIdx);
                const part2 = startShape.slice(0, bestPointIdx);
                startShape = part1.concat(part2);
                startShape.push(startShape[0]); // Ensure visual closure
            } else {
                // Open Line: Reverse if best point is at the end
                // If best point is in middle, we can't do much without cutting line. 
                // Just check ends.
                let dStart = Math.hypot(startShape[0].x, startShape[0].y);
                let dEnd = Math.hypot(startShape[startShape.length-1].x, startShape[startShape.length-1].y);
                if(dEnd > dStart) startShape.reverse();
            }

            let sortedShapes = [startShape];
            let curPos = startShape[startShape.length-1];

            // --- STEP 4: GREEDY TSP SORT ---
            while(pool.length > 0) {
                let bestIdx = -1;
                let bestDist = Infinity;
                let bestStartIdx = 0;
                let bestIsReverse = false;

                for(let i=0; i<pool.length; i++) {
                    let s = pool[i];
                    let isClosed = Math.hypot(s[0].x - s[s.length-1].x, s[0].y - s[s.length-1].y) < 5.0;

                    if(isClosed) {
                        // Check EVERY point for entry
                        for(let k=0; k<s.length; k++) {
                            let d = Math.hypot(curPos.x - s[k].x, curPos.y - s[k].y);
                            if(d < bestDist) {
                                bestDist = d;
                                bestIdx = i;
                                bestStartIdx = k;
                                bestIsReverse = false;
                            }
                        }
                    } else {
                        // Check Start vs End
                        let dStart = Math.hypot(curPos.x - s[0].x, curPos.y - s[0].y);
                        if(dStart < bestDist) { bestDist=dStart; bestIdx=i; bestStartIdx=0; bestIsReverse=false; }
                        let dEnd = Math.hypot(curPos.x - s[s.length-1].x, curPos.y - s[s.length-1].y);
                        if(dEnd < bestDist) { bestDist=dEnd; bestIdx=i; bestStartIdx=0; bestIsReverse=true; }
                    }
                }

                // Process Winner
                let winner = pool[bestIdx];
                let isWinnerClosed = Math.hypot(winner[0].x - winner[winner.length-1].x, winner[0].y - winner[winner.length-1].y) < 5.0;

                if(isWinnerClosed) {
                    let p1 = winner.slice(bestStartIdx);
                    let p2 = winner.slice(0, bestStartIdx);
                    winner = p1.concat(p2);
                    winner.push(winner[0]);
                } else {
                    if(bestIsReverse) winner.reverse();
                }

                sortedShapes.push(winner);
                curPos = winner[winner.length-1];
                pool.splice(bestIdx, 1);
            }

            // --- STEP 5: ADD ENTRY/EXIT LINES ---
            if(sortedShapes.length > 0) {
                // Entry Line (From rim to first point)
                let first = sortedShapes[0];
                let fPt = first[0];
                let fAng = Math.atan2(fPt.y, fPt.x);
                first.unshift({x: tableR*Math.cos(fAng), y: tableR*Math.sin(fAng), type:'point'});

                // Exit Line (From last point to rim)
                let last = sortedShapes[sortedShapes.length-1];
                let lPt = last[last.length-1];
                let lAng = Math.atan2(lPt.y, lPt.x);
                last.push({x: tableR*Math.cos(lAng), y: tableR*Math.sin(lAng), type:'point'});
            }

            // --- STEP 6: FLATTEN & INTERPOLATE FOR VISUALS ---
            processedPoints = [];
            const res = 1.0; 
            
            for(let i=0; i<sortedShapes.length; i++) {
                let s = sortedShapes[i];
                
                // Add travel line from previous shape
                if(i > 0) {
                    let prev = sortedShapes[i-1];
                    let p1 = prev[prev.length-1];
                    let p2 = s[0];
                    let d = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                    let steps = Math.ceil(d/res);
                    for(let k=1; k<=steps; k++) {
                        let t = k/steps;
                        processedPoints.push({
                            x: p1.x + (p2.x-p1.x)*t,
                            y: p1.y + (p2.y-p1.y)*t,
                            type: 'point'
                        });
                    }
                }
                s.forEach(p => processedPoints.push(p));
            }

            // Generate G-Code
            generatedGCode = generateGCodeStringFromProcessed();
            
            document.getElementById('statusTxt').innerText = "Path Optimized (Red)";
            document.getElementById('statusTxt').style.color = "green";
            document.getElementById('progressSlider').value = 0;
            render(); 
            showToast("Path Optimized!", "success");
        }

        // --- G-CODE GENERATION ---
        function generateGCodeStringFromProcessed() {
            const L1 = parseFloat(document.getElementById('cfgL1').value);
            const L2 = parseFloat(document.getElementById('cfgL2').value);
            const gearRatio = 1.125;
            const tableRadius = parseFloat(document.getElementById('cfgRadius').value);
            const stepsPerDeg = parseFloat(document.getElementById('cfgStepsPerDeg').value);
            const stepsPerRad = stepsPerDeg * (180 / Math.PI);
            
            const centerDelay = parseFloat(document.getElementById('cfgCenterDelay').value);
            const perimDelay = parseFloat(document.getElementById('cfgPerimDelay').value);

            let cmds = [];
            let prevBase = 0;
            let prevElbow = 0;

            let firstPt = processedPoints[0];
            let startIK = calculateIK(firstPt.x, firstPt.y, 0, 0, L1, L2, gearRatio, stepsPerRad);
            prevBase = startIK.base_steps;
            prevElbow = startIK.elbow_steps;

            // Interpolate small steps for smooth motor movement
            for(let i=0; i<processedPoints.length-1; i++) {
                let p1 = processedPoints[i];
                let p2 = processedPoints[i+1];
                let dist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                let steps = Math.max(1, Math.ceil(dist / 1.0)); 
                
                for(let j=1; j<=steps; j++) {
                    let t = j/steps;
                    let x = p1.x + (p2.x - p1.x)*t;
                    let y = p1.y + (p2.y - p1.y)*t;

                    let ik = calculateIK(x, y, prevBase, prevElbow, L1, L2, gearRatio, stepsPerRad);
                    let dBase = Math.round(ik.base_steps - prevBase);
                    let dElbow = Math.round(ik.elbow_steps - prevElbow);

                    if(dBase !== 0 || dElbow !== 0) {
                        let r = Math.hypot(x, y);
                        let rFactor = r / tableRadius;
                        if(rFactor > 1) rFactor = 1;
                        let delay = Math.round(centerDelay + ((perimDelay - centerDelay) * rFactor));
                        
                        cmds.push(`G1 ${dElbow} ${dBase} ${delay}`);
                        prevBase += dBase; prevElbow += dElbow;
                    }
                }
            }
            return cmds.join('\n');
        }

        // --- IK MATH (EXACT COPY) ---
        function getShortestRotation(raw, last) {
            let diff = (raw - last) / (2 * Math.PI);
            let offset = Math.round(diff);
            return raw - (offset * 2 * Math.PI);
        }

        function calculateIK(x, y, lastBaseSteps, lastElbowSteps, L1, L2, gearRatio, stepsPerRad) {
            let dist = Math.hypot(x, y);
            const maxReach = L1 + L2;
            if (dist > maxReach) { x = (x / dist) * maxReach; y = (y / dist) * maxReach; dist = maxReach; }

            if (dist < 1.0) { 
                const targetBaseSteps = lastBaseSteps; 
                const currentBaseAngle = -lastBaseSteps / stepsPerRad;
                const targetElbowSteps = -(Math.PI + gearRatio * currentBaseAngle) * stepsPerRad;
                return { base_steps: targetBaseSteps, elbow_steps: targetElbowSteps };
            }

            const lastT1 = -lastBaseSteps / stepsPerRad; 
            let cosBend = (dist*dist - L1*L1 - L2*L2) / (2 * L1 * L2);
            cosBend = Math.max(-1, Math.min(1, cosBend));
            const bend1 = Math.acos(cosBend);
            const bend2 = -Math.acos(cosBend);

            const k1_1 = L1 + L2 * Math.cos(bend1);
            const k2_1 = L2 * Math.sin(bend1);
            let t1_1 = Math.atan2(y, x) - Math.atan2(k2_1, k1_1);
            t1_1 = getShortestRotation(t1_1, lastT1);

            const k1_2 = L1 + L2 * Math.cos(bend2);
            const k2_2 = L2 * Math.sin(bend2);
            let t1_2 = Math.atan2(y, x) - Math.atan2(k2_2, k1_2);
            t1_2 = getShortestRotation(t1_2, lastT1);

            const b1_steps = -t1_1 * stepsPerRad;
            const e1_steps = -(bend1 + gearRatio * t1_1) * stepsPerRad;
            const b2_steps = -t1_2 * stepsPerRad;
            const e2_steps = -(bend2 + gearRatio * t1_2) * stepsPerRad;

            const cost1 = Math.abs(b1_steps - lastBaseSteps) + Math.abs(e1_steps - lastElbowSteps);
            const cost2 = Math.abs(b2_steps - lastBaseSteps) + Math.abs(e2_steps - lastElbowSteps);

            return (cost1 <= cost2) ? { base_steps: b1_steps, elbow_steps: e1_steps } 
                                    : { base_steps: b2_steps, elbow_steps: e2_steps };
        }

        // --- ACTIONS ---
        function sendToTable() {
            if(!generatedGCode) return showToast("Click 'Prepare Path' first!", "error");
            showToast("Sending...", "info");
            fetch(BASE_URL + '/send_gcode_block', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({gcode: generatedGCode, speed_override: null})
            }).then(r=>r.json()).then(d=>{
                if(d.success) showToast("Sent!", "success");
                else showToast("Error: " + d.error, "error");
            }).catch(()=>showToast("Network Error", "error"));
        }
        
        function downloadGcode() {
            if(!generatedGCode) return showToast("Click 'Prepare Path' first!", "error");
            const blob = new Blob([generatedGCode], {type:'text/plain'});
            const a = document.createElement('a');
            a.download = 'pattern.txt'; a.href = URL.createObjectURL(blob); a.click();
        }

        // --- UTILS ---
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const size = container.getBoundingClientRect().width;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            ctx.scale(dpr, dpr);
            origin = { x: size/2, y: size/2 };
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            scale = (size/2) / (tableR * 1.05);
            render();
        }
        function saveState() {
            if(historyStack.length>10) historyStack.shift();
            historyStack.push(JSON.stringify(rawPoints));
        }
        function undo() {
            if(historyStack.length===0) return;
            rawPoints = JSON.parse(historyStack.pop());
            resetStatus();
            render();
        }
        function clearCanvas() {
            saveState();
            rawPoints = [];
            resetStatus();
            render();
        }
        function setTool(t) {
            currentTool = t;
            document.getElementById('btnDraw').className = t==='draw'?'active':'secondary';
            document.getElementById('btnErase').className = t==='erase'?'active':'secondary';
        }
        function updateUI() {
            document.getElementById('symVal').textContent = document.getElementById('symSlider').value + 'x';
            render();
        }
        function showToast(msg, type) {
            const t = document.getElementById('status-toast');
            t.textContent = msg; t.className = type; t.style.opacity = 1;
            setTimeout(()=>t.style.opacity=0, 3000);
        }
        function openNav() { document.getElementById("mySidebar").style.width = "250px"; }
        function closeNav() { document.getElementById("mySidebar").style.width = "0"; }
        function toggleTheme() {
            const b = document.body;
            b.setAttribute('data-theme', b.getAttribute('data-theme')==='dark'?'light':'dark');
            render();
        }

        init();
    </script>
</body>
</html>
