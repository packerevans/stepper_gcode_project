<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sand Controller Pro</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <style>
        :root {
            --primary: #d2b48c; 
            --secondary: #b08d5c; 
            --bg: #f4f4f4; 
            --panel: #ffffff; 
            --text: #333;
            --accent: #2ecc71;
            --danger: #e74c3c;
            --btn-text: #fff;
        }
        body[data-theme='dark'] {
            --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --btn-text: #000;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--bg); color: var(--text);
            margin: 0; padding: 0; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
        }

        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--panel);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100;
        }
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background-color: var(--primary); overflow-x: hidden;
            transition: 0.3s; padding-top: 60px; z-index: 2000;
            box-shadow: 4px 0 10px rgba(0,0,0,0.3);
        }
        .sidebar a {
            padding: 15px 24px; text-decoration: none; font-size: 18px;
            color: #fff; display: block; font-weight: 500;
        }

        .app-container {
            display: flex; flex-direction: column; height: 100%; width: 100%;
            padding: 10px; box-sizing: border-box; gap: 10px; overflow-y: auto;
        }
        @media (min-width: 768px) {
            .app-container { flex-direction: row; overflow: hidden; }
            .drawing-panel { flex: 2; border-radius: 16px; background: var(--panel); position: relative; display: flex; align-items: center; justify-content: center; }
            .controls-panel { flex: 1; max-width: 400px; border-radius: 16px; background: var(--panel); padding: 20px; overflow-y: auto; }
        }
        @media (max-width: 767px) {
            .drawing-panel { width: 100%; aspect-ratio: 1/1; border-radius: 16px; background: var(--panel); flex-shrink: 0; position: relative;}
            .controls-panel { flex: 1; border-radius: 16px; background: var(--panel); padding: 15px; }
        }

        /* SQUARE LOCK CANVAS */
        .canvas-wrapper {
            position: relative;
            width: 95vmin; /* Limits width to viewport min dimension */
            height: 95vmin; /* Limits height to viewport min dimension */
            max-width: 95%; /* Prevents overflow on width */
            max-height: 95%; /* Prevents overflow on height */
            aspect-ratio: 1 / 1; /* Forces square */
            margin: auto;
            border-radius: 50%;
            border: 4px solid var(--primary); 
            background: #fff;
            touch-action: none; cursor: crosshair; overflow: hidden;
        }
        body[data-theme='dark'] .canvas-wrapper { background: #222; border-color: var(--secondary); }
        canvas { display: block; width: 100%; height: 100%; border-radius: 50%; }

        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: var(--secondary); text-align: center; }
        .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
        button {
            background: var(--primary); color: var(--btn-text); border: none;
            padding: 12px; border-radius: 8px; font-weight: 600; cursor: pointer;
            flex: 1; transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        button.secondary { background: transparent; border: 1px solid var(--text); color: var(--text); }
        button.active { background: var(--secondary); border: 2px solid var(--text); }
        button.action { background: var(--accent); color: #000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .slider-row { margin-bottom: 15px; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; font-weight: bold; }
        input[type="range"] { width: 100%; accent-color: var(--secondary); }
        
        #progressSlider {
            -webkit-appearance: none; width: 100%; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none;
        }
        #progressSlider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--secondary); cursor: pointer;
        }

        details { background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; }
        summary { cursor: pointer; font-weight: bold; font-size: 13px; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        input[type="number"] { width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; font-family: monospace;}

        #status-toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 3000;
        }
        .success { background: var(--accent) !important; color: #000 !important; }
        .error { background: var(--danger) !important; color: #fff !important; }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 0 5px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-tog { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-tog:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-tog { background-color: var(--secondary); }
        input:checked + .slider-tog:before { transform: translateX(18px); }

        #toolSettingsArea {
            background: rgba(0,0,0,0.03);
            border: 1px dashed var(--secondary);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 12px;
            display: none;
        }
        .tool-setting-group { display: none; }
        .tool-setting-group.active { display: block; }
        .tool-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--secondary); margin-bottom: 5px; display:block;}

        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .stamp-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-top: 8px; }
        .stamp-btn { font-size: 18px; padding: 5px; background: rgba(0,0,0,0.05); border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); }
        .stamp-btn:hover { background: var(--secondary); color: white; }

        /* Hidden canvas for trace/vortex logic */
        #hiddenTraceBuffer, #vortexScanCanvas { display: none; }
        
        select.full-width { width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #ccc; }

    </style>
</head>
<body data-theme="light">

    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Designs</a> 
        <a href="/ai_builder">AI Builder</a>
        <a href="/led_controls">LED Controls</a>
        <a href="/terminal">Terminal</a>
    </div>

    <div class="nav-bar">
        <button style="flex:0; background:none; font-size:24px; color:var(--text); padding:0;" onclick="openNav()">‚ò∞</button>
        <h1 style="margin:0; font-size:1.2rem;">Sand Controller Pro</h1>
        <button style="flex:0; background:none; font-size:20px;" onclick="toggleTheme()">‚òÄÔ∏è</button>
    </div>

    <div class="app-container">
        <div class="drawing-panel">
            <div class="canvas-wrapper" id="canvasContainer">
                <canvas id="drawCanvas"></canvas>
            </div>
            <div id="coordDisplay" style="position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none;">X:0 Y:0</div>
        </div>

        <div class="controls-panel">
            <div id="designPhaseControls">
                <h2>Tools</h2>
                
                <div class="toggle-row">
                    <span style="font-weight:600; font-size:13px;">üñãÔ∏è Stylus Mode</span>
                    <label class="switch">
                        <input type="checkbox" id="stylusMode">
                        <span class="slider-tog"></span>
                    </label>
                </div>

                <div id="toolSettingsArea">
                    <div id="set-pen" class="tool-setting-group">
                        <div class="toggle-row" style="margin:0;">
                            <span style="font-size:13px;">üîó Shape Connector</span>
                            <label class="switch">
                                <input type="checkbox" id="shapeConnectMode" checked>
                                <span class="slider-tog"></span>
                            </label>
                        </div>
                        <div style="margin-top:10px;">
                            <span class="tool-label">Add Stamps</span>
                            <div class="stamp-grid">
                                <button class="stamp-btn" onclick="addShape('circle')">‚≠ï</button>
                                <button class="stamp-btn" onclick="addShape('square')">‚¨ú</button>
                                <button class="stamp-btn" onclick="addShape('triangle')">üî∫</button>
                                <button class="stamp-btn" onclick="addShape('hexagon')">‚¨°</button>
                                <button class="stamp-btn" onclick="addShape('pentagon')">‚¨†</button>
                                <button class="stamp-btn" onclick="addShape('star')">‚≠ê</button>
                                <button class="stamp-btn" onclick="addShape('spiral')">üåÄ</button>
                                <button class="stamp-btn" onclick="addShape('random')">üé≤</button>
                            </div>
                        </div>
                    </div>

                    <div id="set-erase" class="tool-setting-group">
                        <span class="tool-label">Eraser Size: <span id="eraseSizeVal">10px</span></span>
                        <input type="range" min="2" max="50" value="10" oninput="updateToolSettings()" id="eraserSizeSlider">
                    </div>

                    <div id="set-fill" class="tool-setting-group">
                        <span class="tool-label">Line Spacing: <span id="fillGapVal">5.0</span></span>
                        <input type="range" min="1.0" max="15.0" step="0.5" value="5.0" oninput="updateToolSettings()" id="fillGapSlider">
                    </div>

                    <div id="set-select" class="tool-setting-group">
                        <span class="tool-label">Transform Selection</span>
                        
                        <div id="traceMoveMsg" style="display:none; color:var(--accent); font-size:11px; margin-bottom:8px;">
                            ‚ú® Trace Active: Drag/Rotate/Resize image
                        </div>

                        <span class="tool-label">Rotate Live</span>
                        <input type="range" min="-180" max="180" value="0" step="1" id="liveRotSlider" 
                               oninput="liveRotate(this.value)" onchange="endLiveTransform(this)">
                        <div style="text-align:right; font-size:10px; color:#666;" id="liveRotVal">0¬∞</div>
                        
                        <span class="tool-label" style="margin-top:10px;">Resize Live</span>
                        <input type="range" min="10" max="200" value="100" step="1" id="liveScaleSlider" 
                               oninput="liveScale(this.value)" onchange="endLiveTransform(this)">
                        <div style="text-align:right; font-size:10px; color:#666;" id="liveScaleVal">100%</div>
                    </div>

                    <div id="set-sandify" class="tool-setting-group">
                        <span class="tool-label" style="color:var(--accent); font-weight:bold;">Vortex Generator</span>
                        
                        <label class="tool-label">Shape Source</label>
                        <select id="vortexShape" class="full-width" onchange="updateVortexParams()">
                            <option value="custom">Current Drawing</option>
                            <option value="triangle">Triangle</option>
                            <option value="square">Square</option>
                            <option value="pentagon">Pentagon</option>
                            <option value="hexagon">Hexagon</option>
                            <option value="star">Star</option>
                            <option value="text">Letter / Symbol</option>
                        </select>

                        <div id="vortexTextContainer" style="display:none; margin-top:5px;">
                             <input type="text" id="vortexChar" maxlength="1" value="S" style="text-align:center; font-weight:bold; width:100%;" oninput="updateVortexParams()">
                        </div>

                        <span class="tool-label" style="margin-top:10px;">Loop Count: <span id="val-swirl">20</span></span>
                        <input type="range" id="vortexSwirl" min="5" max="50" step="1" value="20" oninput="updateVortexParams()">

                        <span class="tool-label">Shape Zoom: <span id="val-scale">1.0</span></span>
                        <input type="range" id="vortexScale" min="0.1" max="2.0" step="0.05" value="1.0" oninput="updateVortexParams()">

                        <span class="tool-label">Twist Angle: <span id="val-twist">5</span></span>
                        <input type="range" id="vortexTwist" min="-45" max="45" step="0.5" value="5" oninput="updateVortexParams()">
                        
                        <span class="tool-label">Shift Center (Left/Right): <span id="val-shift">0</span></span>
                        <input type="range" id="vortexShift" min="-150" max="150" step="1" value="0" oninput="updateVortexParams()">
                    </div>
                    
                    <div id="set-trace" class="tool-setting-group">
                         <span class="tool-label" style="color:var(--accent); font-weight:bold;">High Precision Trace</span>
                         <span class="tool-label" style="color:#666; font-size:10px;">Tip: Use "Move" tool to reposition image</span>
                         
                         <span class="tool-label">Contrast Threshold: <span id="traceThreshVal">150</span></span>
                         <input type="range" min="10" max="240" value="150" id="traceThreshInput" oninput="runHighPrecisionTrace()">
                         
                         <span class="tool-label">Spiral Spacing: <span id="traceDensityVal">1.5</span></span>
                         <input type="range" min="1" max="3" value="1.5" step="0.1" id="traceDensityInput" oninput="runHighPrecisionTrace()">

                         <button class="secondary" style="margin-top:10px; font-size:11px;" onclick="document.getElementById('imgUpload').click()">üìÇ Change Image</button>
                    </div>
                </div>

                <div class="btn-group">
                    <button id="btnDraw" onclick="setTool('draw')" class="active">‚úèÔ∏è Draw</button>
                    <button id="btnErase" onclick="setTool('erase')" class="secondary">üßº Erase</button>
                </div>

                <div class="btn-group">
                    <button id="btnSelect" onclick="setTool('select')" class="secondary">‚úã Move</button>
                    <button id="btnSandify" onclick="setTool('sandify')" class="secondary">üåÄ Vortex</button>
                </div>

                <div class="btn-group">
                    <button id="btnFill" onclick="setTool('fill')" class="secondary">üåä Dune Fill</button>
                    <input type="file" id="imgUpload" accept="image/*" style="display:none" onchange="handleImageUpload(this)">
                    <button id="btnTrace" class="secondary" onclick="document.getElementById('imgUpload').click()">‚ú® Trace</button>
                </div>

                <div class="btn-group">
                    <button onclick="undo()" class="secondary">‚Ü∂ Undo</button>
                    <button onclick="clearCanvas()" class="secondary" style="color:var(--danger); border-color:var(--danger);">‚úñ Clear</button>
                </div>

                <hr style="border:0; border-top:1px solid #ddd; margin: 15px 0;">
                
                <div class="slider-row">
                    <div class="slider-header"><span>SYMMETRY</span> <span id="symVal">1x</span></div>
                    <input type="range" id="symSlider" min="1" max="12" value="1" step="1" oninput="updateUI()">
                </div>

                <button class="action" onclick="prepareGCode()" style="margin-bottom:15px; font-size:1.1em;">‚öôÔ∏è Prepare Path</button>
            </div>
            
            <div id="productionPhaseControls" style="display:none; margin-bottom:15px;">
                <button class="secondary" onclick="returnToEditing()" style="width:100%; border:2px dashed #999; color:#444; background: rgba(0,0,0,0.05);">
                    ‚úèÔ∏è Back to Edit
                </button>
            </div>

            <div class="slider-row">
                <div class="slider-header"><span>SIMULATION</span> <span id="progVal">100%</span></div>
                <input type="range" id="progressSlider" min="0" max="100" value="100" oninput="render()">
            </div>

            <div style="text-align:center; font-size:12px; margin-bottom:10px; color:#666;">
                Status: <span id="statusTxt" style="font-weight:bold; color:var(--primary);">Drawing Mode</span>
            </div>

            <div class="toggle-row" style="background:rgba(0,0,0,0.03); padding:8px; border-radius:8px; margin-bottom:10px;">
                <span style="font-weight:600; font-size:13px;">‚ú® Auto-Clear Before Run</span>
                <label class="switch">
                    <input type="checkbox" id="autoClearMode" checked>
                    <span class="slider-tog"></span>
                </label>
            </div>

            <div class="btn-group">
                <button onclick="sendToTable()" class="active">üöÄ Run</button>
                <button onclick="saveToServer()" class="secondary">üíæ Save to Pi</button>
            </div>

            <details>
                <summary>‚öôÔ∏è Machine Settings</summary>
                <div class="settings-grid">
                    <div><label>Radius</label><input type="number" id="cfgRadius" value="202.6" onchange="resizeCanvas()"></div>
                    <div><label>Center Speed</label><input type="number" id="cfgCenterDelay" value="500"></div>
                    <div><label>Rim Speed</label><input type="number" id="cfgPerimDelay" value="3000"></div>
                    <div><label>Steps/Deg</label><input type="number" id="cfgStepsPerDeg" value="8.888888"></div>
                    <div><label>Arm 1</label><input type="number" id="cfgL1" value="101.3"></div>
                    <div><label>Arm 2</label><input type="number" id="cfgL2" value="101.3"></div>
                </div>
                <button class="secondary" onclick="copyGCode()" style="margin-top:10px; width:100%;">üìã Copy GCode</button>
            </details>
        </div>
    </div>

    <div id="status-toast"></div>
    <canvas id="hiddenTraceBuffer" width="800" height="800"></canvas>
    <canvas id="vortexScanCanvas" width="600" height="600"></canvas>

    <script>
        // --- GLOBAL STATE ---
        let rawPoints = []; 
        let processedPoints = []; 
        let historyStack = [];
        let isDrawing = false;
        let currentTool = 'draw';
        let origin = {x:0, y:0};
        let scale = 1;
        let generatedGCode = null;

        // Tool Settings State
        let eraserRadius = 10;
        let fillGap = 5.0;

        // Trace State
        let traceImgData = null;
        let traceState = { active: false, img: null, x: 0, y: 0, scale: 1.0, baseScale: 1.0, rotation: 0 }; 

        // Live Transform State
        let lastRotVal = 0;
        let lastScaleVal = 100;

        // Vortex State
        const vortexState = {
            radiusMap: new Float32Array(720) 
        };
        let vortexSourcePath = [];

        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_URL = window.location.origin;

        // --- MATH HELPERS ---
        function distSq(p1, p2) { return (p1.x-p2.x)**2 + (p1.y-p2.y)**2; }
        function dist(p1, p2) { return Math.sqrt(distSq(p1, p2)); }
        function isPointInPolygon(p, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i].x, yi = polygon[i].y;
                let xj = polygon[j].x, yj = polygon[j].y;
                let intersect = ((yi > p.y) !== (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        function getBounds(shape) {
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            shape.forEach(p => { if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; });
            return { minX, maxX, minY, maxY, area: (maxX-minX)*(maxY-minY), w: maxX-minX, h: maxY-minY, cx: (minX+maxX)/2, cy: (minY+maxY)/2 };
        }
        function getIntersection(A, B, C, D) {
            const det = (B.x - A.x) * (D.y - C.y) - (D.x - C.x) * (B.y - A.y);
            if (det === 0) return null; 
            const lambda = ((D.y - C.y) * (D.x - A.x) + (C.x - D.x) * (D.y - A.y)) / det;
            const gamma = ((A.y - B.y) * (D.x - A.x) + (B.x - A.x) * (D.y - A.y)) / det;
            if (lambda > 0.001 && lambda < 0.999 && gamma > 0.001 && gamma < 0.999) {
                return { x: A.x + lambda * (B.x - A.x), y: A.y + lambda * (B.y - A.y) };
            }
            return null;
        }
        function distToPoly(pt, poly) {
            let minD = Infinity; for(let i=0; i<poly.length; i++) { let d = Math.hypot(poly[i].x - pt.x, poly[i].y - pt.y); if(d < minD) minD = d; } return minD;
        }
        function findClosestIndex(pt, poly) {
            let minD = Infinity, idx = -1; for(let i=0; i<poly.length; i++) { let d = distSq(pt, poly[i]); if(d < minD) { minD = d; idx = i; } } return idx;
        }
        function findClosestPoly(pt, target, holes) {
            let minD = 5.0; if(distToPoly(pt, target) < minD) return target; for(let h of holes) { if(distToPoly(pt, h) < minD) return h; } return null;
        }
        function getPerimeterPath(idx1, idx2, poly) {
            if(idx1 === -1 || idx2 === -1) return [];
            if(idx1 === idx2) return [poly[idx1]];
            let isClosed = dist(poly[0], poly[poly.length-1]) < 2.0;
            if (!isClosed) {
                let path = []; let step = (idx1 < idx2) ? 1 : -1;
                for(let i=idx1; i !== idx2; i+=step) path.push(poly[i]); path.push(poly[idx2]); return path;
            }
            let len = poly.length; let cwDist = 0, ccwDist = 0; let curr = idx1;
            while(curr !== idx2) { let next = (curr + 1) % len; cwDist += dist(poly[curr], poly[next]); curr = next; }
            curr = idx1; while(curr !== idx2) { let next = (curr - 1 + len) % len; ccwDist += dist(poly[curr], poly[next]); curr = next; }
            let path = [];
            if(cwDist < ccwDist) { curr = idx1; while(curr !== idx2) { let next = (curr + 1) % len; path.push(poly[next]); curr = next; } } 
            else { curr = idx1; while(curr !== idx2) { let next = (curr - 1 + len) % len; path.push(poly[next]); curr = next; } }
            path.push(poly[idx2]); return path;
        }
        function routeConnect(start, end, shapes, depth=0) {
            if (depth > 5) return [end]; 
            let collision = null; let minD = Infinity;
            for (let sIdx = 0; sIdx < shapes.length; sIdx++) {
                let poly = shapes[sIdx]; let isClosed = dist(poly[0], poly[poly.length-1]) < 2.0; let limit = isClosed ? poly.length : poly.length - 1;
                for (let i = 0; i < limit; i++) {
                    let p1 = poly[i]; let p2 = poly[(i+1)%poly.length];
                    if (dist(start, p1) < 0.1 || dist(start, p2) < 0.1) continue;
                    let hit = getIntersection(start, end, p1, p2);
                    if (hit) { let d = dist(start, hit); if (d < minD) { minD = d; collision = { pt: hit, poly: poly, idx: i }; } }
                }
            }
            if (!collision) return [end];
            let obstacle = collision.poly; let exitIdx = -1, minExitD = Infinity;
            for(let i=0; i<obstacle.length; i++) { let d = dist(obstacle[i], end); if(d < minExitD) { minExitD = d; exitIdx = i; } }
            let entryIdx = -1, minEntryD = Infinity;
            for(let i=0; i<obstacle.length; i++) { let d = dist(obstacle[i], collision.pt); if(d < minEntryD) { minEntryD = d; entryIdx = i; } }
            let surfPath = getPerimeterPath(entryIdx, exitIdx, obstacle);
            let exitPoint = obstacle[exitIdx];
            let remainingPath = routeConnect(exitPoint, end, shapes, depth+1);
            return surfPath.concat(remainingPath);
        }

        const Noise = {
            p: [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
                190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,
                125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,
                105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,
                135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,
                82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,
                153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,
                251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,
                157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,
                78,66,215,61,156,180],
            perm: new Array(512),
            grad3: [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],
            init: function() { for(let i=0; i<256; i++) this.perm[i] = this.perm[i+256] = this.p[i]; },
            dot: function(g, x, y) { return g[0]*x + g[1]*y; },
            mix: function(a, b, t) { return (1-t)*a + t*b; },
            fade: function(t) { return t*t*t*(t*(t*6-15)+10); },
            eval: function(x, y) { if(!this.perm[0]) this.init(); var X = Math.floor(x), Y = Math.floor(y); x -= X; y -= Y; X = X & 255; Y = Y & 255; var n00 = this.dot(this.grad3[this.perm[X+this.perm[Y]] % 12], x, y); var n01 = this.dot(this.grad3[this.perm[X+this.perm[Y+1]] % 12], x, y-1); var n10 = this.dot(this.grad3[this.perm[X+1+this.perm[Y]] % 12], x-1, y); var n11 = this.dot(this.grad3[this.perm[X+1+this.perm[Y+1]] % 12], x-1, y-1); var u = this.fade(x), v = this.fade(y); return this.mix(this.mix(n00, n10, u), this.mix(n01, n11, u), v); }
        };

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('pointerdown', startDraw);
            canvas.addEventListener('pointermove', moveDraw);
            canvas.addEventListener('pointerup', endDraw);
            canvas.addEventListener('pointerleave', endDraw);
            canvas.style.touchAction = "none";
            updateUI();
            updateToolSettings();
        }

        let dragStart = null;

        // --- DRAWING LOGIC ---
        function startDraw(e) {
            e.preventDefault();
            if(generatedGCode) return;
            if(currentTool === 'fill') { handleFillClick(e); return; }

            const smart = document.getElementById('stylusMode').checked;
            if(smart && currentTool !== 'select' && currentTool !== 'sandify') {
                if(e.pointerType === 'pen') setTool('draw');
                else if(e.pointerType === 'touch') setTool('erase');
            }

            if(currentTool === 'select') {
                isDrawing = true;
                dragStart = getPos(e);
                canvas.setPointerCapture(e.pointerId);
                return;
            }
            if(currentTool === 'sandify' || currentTool === 'trace_set') return;

            saveState();
            isDrawing = true;
            canvas.setPointerCapture(e.pointerId);
            processPointer(e);
            resetStatus();
        }

        // UNIFIED MOVE DRAW FUNCTION
        function moveDraw(e) {
            e.preventDefault();
            const pos = getPos(e);
            document.getElementById('coordDisplay').textContent = `X:${pos.x.toFixed(0)} Y:${pos.y.toFixed(0)}`;
            
            // --- TRACE MOVE LOGIC ---
            if(currentTool === 'select' && traceState.active && isDrawing && dragStart) {
                const dx = pos.x - dragStart.x;
                const dy = pos.y - dragStart.y;
                
                const tableR = parseFloat(document.getElementById('cfgRadius').value);
                // The visual scale factor logic matches drawTracePreview:
                // visualScale = (tableR * 2 / 800) * scale.
                // We need to invert this to apply delta to Trace Units (0-800)
                const mmToTraceFactor = 800 / (tableR * 2);
                
                traceState.x += dx * mmToTraceFactor;
                // Invert Y delta: Screen Y Up (+), Trace Buffer Y Down (+)
                traceState.y -= dy * mmToTraceFactor; 
                
                dragStart = pos;
                drawTracePreview();
                return;
            }
            // -------------------------

            if(!isDrawing) { render(); drawCursor(pos); return; }

            if(currentTool === 'select' && dragStart) {
                const dx = pos.x - dragStart.x;
                const dy = pos.y - dragStart.y;
                rawPoints.forEach(p => { if(p.type === 'point') { p.x += dx; p.y += dy; } });
                dragStart = pos; 
                render();
                return;
            }
            processPointer(e);
        }

        function endDraw(e) {
            if(!isDrawing) return;
            isDrawing = false;
            canvas.releasePointerCapture(e.pointerId);
            
            if(currentTool === 'select') {
                dragStart = null;
                // If we were moving a trace, commit it now
                if(traceState.active) {
                    commitTraceMove();
                } else {
                    saveState();
                }
                return;
            }
            
            if(currentTool === 'draw') {
                if(document.getElementById('shapeConnectMode').checked) {
                    autoConnectAndSmooth();
                }
                rawPoints.push({type:'break'});
            }
            render();
        }

        function autoConnectAndSmooth() {
            let lastBreak = -1;
            for(let i=rawPoints.length-1; i>=0; i--) { if(rawPoints[i].type === 'break' || rawPoints[i].type === 'cmd') { lastBreak = i; break; } }
            let stroke = [];
            let startIndex = lastBreak + 1;
            for(let i=startIndex; i<rawPoints.length; i++) stroke.push(rawPoints[i]);
            if(stroke.length < 3) return;
            let startP = stroke[0]; let endP = stroke[stroke.length-1];
            let d = Math.hypot(startP.x - endP.x, startP.y - endP.y);
            if(d < 30.0) { stroke.push({x: startP.x, y: startP.y, type:'point'}); }
            for(let pass=0; pass<2; pass++) {
                let smooth = []; smooth.push(stroke[0]);
                for(let i=0; i<stroke.length-1; i++) {
                    let p0 = stroke[i]; let p1 = stroke[i+1];
                    smooth.push({ x: 0.75 * p0.x + 0.25 * p1.x, y: 0.75 * p0.y + 0.25 * p1.y, type: 'point' });
                    smooth.push({ x: 0.25 * p0.x + 0.75 * p1.x, y: 0.25 * p0.y + 0.75 * p1.y, type: 'point' });
                }
                smooth.push(stroke[stroke.length-1]); stroke = smooth;
            }
            rawPoints.splice(startIndex, rawPoints.length - startIndex, ...stroke);
        }

        // --- SHAPE STAMPS ---
        function addShape(type) {
            saveState();
            const r = 50; 
            let pts = [];
            if(type==='circle') { for(let i=0; i<=36; i++) { const a = (i/36)*Math.PI*2; pts.push({x: Math.cos(a)*r, y: Math.sin(a)*r}); } } 
            else if(type==='square') { pts = [{x:-r,y:-r}, {x:r,y:-r}, {x:r,y:r}, {x:-r,y:r}, {x:-r,y:-r}]; } 
            else if(type==='triangle') { pts = [{x:0,y:r}, {x:r*0.86,y:-r/2}, {x:-r*0.86,y:-r/2}, {x:0,y:r}]; } 
            else if(type==='hexagon') { for(let i=0; i<=6; i++) { const a = (i/6)*Math.PI*2; pts.push({x: Math.cos(a)*r, y: Math.sin(a)*r}); } } 
            else if(type==='pentagon') { for(let i=0; i<=5; i++) { const a = (i/5)*Math.PI*2 - Math.PI/2; pts.push({x: Math.cos(a)*r, y: Math.sin(a)*r}); } } 
            else if(type==='star') { for(let i=0; i<=10; i++) { const a = (i/10)*Math.PI*2 + Math.PI/2; const rad = (i%2===0) ? r : r*0.4; pts.push({x: Math.cos(a)*rad, y: Math.sin(a)*rad}); } } 
            else if(type==='spiral') { for(let i=0; i<100; i++) { const a = i * 0.3; const rad = (i/100)*r; pts.push({x: Math.cos(a)*rad, y: Math.sin(a)*rad}); } } 
            else if (type === 'random') {
                const numPoints = Math.floor(Math.random() * 15) + 1;
                if(numPoints === 1) { const rx = r * (0.5 + Math.random()); const ry = r * (0.5 + Math.random()); for(let i=0; i<=36; i++) { const a = (i/36)*Math.PI*2; pts.push({x: Math.cos(a)*rx, y: Math.sin(a)*ry}); } } 
                else if(numPoints === 2) { const angle = Math.random() * Math.PI * 2; const len = r * (0.8 + Math.random() * 0.4); pts.push({x: Math.cos(angle)*len, y: Math.sin(angle)*len}); pts.push({x: Math.cos(angle + Math.PI)*len, y: Math.sin(angle + Math.PI)*len}); } 
                else { let angles = []; for(let i=0; i<numPoints; i++) angles.push(Math.random() * Math.PI * 2); angles.sort((a,b) => a-b); for(let i=0; i<angles.length; i++) { const rad = r * (0.5 + Math.random() * 0.8); pts.push({x: Math.cos(angles[i])*rad, y: Math.sin(angles[i])*rad}); } pts.push(pts[0]); }
                showToast("Added Random Shape (" + numPoints + " edges)", "success");
            }
            if(type !== 'random') showToast("Added " + type, "success");
            if(rawPoints.length > 0 && rawPoints[rawPoints.length-1].type !== 'break') rawPoints.push({type:'break'});
            pts.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'}));
            rawPoints.push({type:'break'});
            render();
        }

        function getPos(e) { return { x: (e.offsetX - origin.x) / scale, y: -(e.offsetY - origin.y) / scale }; }

        function processPointer(e) {
            const p = getPos(e);
            if(currentTool === 'draw') { rawPoints.push({x: p.x, y: p.y, type: 'point'}); } 
            else if (currentTool === 'erase') { const r = eraserRadius; rawPoints = rawPoints.filter(pt => { if(pt.type === 'break') return true; return Math.hypot(pt.x - p.x, pt.y - p.y) > r; }); }
            render(); if(currentTool==='erase') drawCursor(p);
        }

        function drawCursor(p) {
            if(generatedGCode) return;
            const r = (currentTool === 'erase' ? eraserRadius : 10) * scale;
            const px = origin.x + p.x * scale;
            const py = origin.y - p.y * scale;
            if(currentTool === 'erase') { ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.strokeStyle = "#999"; ctx.fillStyle = "rgba(200,200,200,0.3)"; ctx.stroke(); ctx.fill(); } 
            else if (currentTool === 'fill') { ctx.font = "20px Arial"; ctx.fillStyle = "black"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("üåä", px, py); } 
            else if (currentTool === 'select') { ctx.font = "20px Arial"; ctx.fillStyle = "black"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("‚úã", px, py); } 
            else if (currentTool === 'sandify') { ctx.font = "20px Arial"; ctx.fillStyle = "black"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("üåÄ", px, py); }
        }

        // --- LIVE TRANSFORM HELPERS ---
        function liveRotate(val) {
            if(traceState.active) {
                traceState.rotation = parseFloat(val);
                drawTracePreview();
                return;
            }

            if(rawPoints.length === 0) return;
            const diff = val - lastRotVal; if(diff === 0) return;
            const rad = (diff * Math.PI) / 180; const cos = Math.cos(rad); const sin = Math.sin(rad);
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity; let hasPoints = false;
            rawPoints.forEach(p => { if(p.type === 'point') { if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; hasPoints = true; } });
            if(!hasPoints) return; const cx = (minX + maxX)/2; const cy = (minY + maxY)/2;
            rawPoints.forEach(p => { if(p.type === 'point') { let tx = p.x - cx; let ty = p.y - cy; p.x = cx + (tx * cos - ty * sin); p.y = cy + (tx * sin + ty * cos); } });
            lastRotVal = val; document.getElementById('liveRotVal').innerText = val + "¬∞"; render();
        }

        function liveScale(val) {
             if(traceState.active) {
                 const factor = val / 100.0;
                 traceState.scale = traceState.baseScale * factor;
                 drawTracePreview();
                 return;
             }

             if(rawPoints.length === 0) return;
             const factor = val / lastScaleVal; if(factor === 1) return;
             let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity; let hasPoints = false;
             rawPoints.forEach(p => { if(p.type === 'point') { if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; hasPoints = true; } });
             if(!hasPoints) return; const cx = (minX + maxX)/2; const cy = (minY + maxY)/2;
             rawPoints.forEach(p => { if(p.type === 'point') { p.x = cx + (p.x - cx) * factor; p.y = cy + (p.y - cy) * factor; } });
             lastScaleVal = val; document.getElementById('liveScaleVal').innerText = val + "%"; render();
        }

        function endLiveTransform(slider) {
            if(traceState.active) {
                commitTraceMove();
                if(slider.id === 'liveScaleSlider') slider.value = 100; 
                if(slider.id === 'liveRotSlider') {
                    slider.value = 0; 
                    traceState.rotation = 0; 
                }
                return;
            }

            saveState(); 
            if(slider.id === 'liveRotSlider') { slider.value = 0; lastRotVal = 0; document.getElementById('liveRotVal').innerText = "0¬∞"; }
            if(slider.id === 'liveScaleSlider') { slider.value = 100; lastScaleVal = 100; document.getElementById('liveScaleVal').innerText = "100%"; }
        }

        // ========================================================
        // === VORTEX GENERATOR LOGIC (REPLACES SANDIFY) ===
        // ========================================================

        function updateVortexParams() {
            if(currentTool === 'sandify') {
                document.getElementById('val-swirl').innerText = document.getElementById('vortexSwirl').value;
                document.getElementById('val-scale').innerText = document.getElementById('vortexScale').value;
                document.getElementById('val-twist').innerText = document.getElementById('vortexTwist').value;
                document.getElementById('val-shift').innerText = document.getElementById('vortexShift').value;
                
                const type = document.getElementById('vortexShape').value;
                document.getElementById('vortexTextContainer').style.display = type === 'text' ? 'block' : 'none';
                
                scanVortexShape();
                generateVortex();
            }
        }

        function scanVortexShape() {
            const scanCanvas = document.getElementById('vortexScanCanvas');
            const scanCtx = scanCanvas.getContext('2d');
            const w = scanCanvas.width;
            const h = scanCanvas.height;
            const cx = w/2;
            const cy = h/2;
            const r = w/2 - 20;

            const type = document.getElementById('vortexShape').value;
            const txt = document.getElementById('vortexChar').value;
            const shiftX = parseFloat(document.getElementById('vortexShift').value);

            // Clear and Prep
            scanCtx.fillStyle = '#000';
            scanCtx.fillRect(0, 0, w, h);
            
            scanCtx.fillStyle = '#fff';
            scanCtx.strokeStyle = '#fff';
            scanCtx.lineWidth = 15;
            scanCtx.textAlign = 'center';
            scanCtx.textBaseline = 'middle';
            
            scanCtx.save();
            // Apply Shift to the source shape, but scanner stays at center
            // This creates the "offset center" effect
            scanCtx.translate(-shiftX, 0);

            scanCtx.beginPath();
            
            // Helper for drawing shapes
            const drawPoly = (sides) => {
                const offset = -Math.PI / 2;
                scanCtx.moveTo(cx + r * Math.cos(offset), cy + r * Math.sin(offset));
                for (let i = 1; i <= sides; i++) {
                    scanCtx.lineTo(cx + r * Math.cos(offset + i * 2 * Math.PI / sides), cy + r * Math.sin(offset + i * 2 * Math.PI / sides));
                }
            };
            const drawStar = (pts) => {
                let rot = Math.PI / 2 * 3;
                let step = Math.PI / pts;
                scanCtx.moveTo(cx, cy - r);
                for (let i = 0; i < pts; i++) {
                    scanCtx.lineTo(cx + Math.cos(rot) * r, cy + Math.sin(rot) * r);
                    rot += step;
                    scanCtx.lineTo(cx + Math.cos(rot) * (r*0.4), cy + Math.sin(rot) * (r*0.4));
                    rot += step;
                }
                scanCtx.lineTo(cx, cy - r);
            };

            if (type === 'custom') {
                // Draw whatever was in rawPoints before we switched to Vortex
                const tableR = parseFloat(document.getElementById('cfgRadius').value);
                const scaleToFit = r / tableR; // Scale table units to scan canvas units
                
                scanCtx.beginPath();
                vortexSourcePath.forEach((p, i) => {
                    if(p.type === 'break' || p.type === 'cmd') return;
                    
                    // Transform table coord (0,0 center) to scan canvas (cx, cy center)
                    const sx = cx + (p.x * scaleToFit);
                    const sy = cy - (p.y * scaleToFit); // Flip Y to match canvas
                    
                    if(i===0 || vortexSourcePath[i-1].type === 'break') scanCtx.moveTo(sx, sy);
                    else scanCtx.lineTo(sx, sy);
                });
                scanCtx.stroke();
            }
            else if (type === 'text') {
                scanCtx.font = 'bold 450px Arial';
                scanCtx.fillText(txt, cx, cy + 30);
            } 
            else if (type === 'triangle') drawPoly(3);
            else if (type === 'square') drawPoly(4);
            else if (type === 'pentagon') drawPoly(5);
            else if (type === 'hexagon') drawPoly(6);
            else if (type === 'star') drawStar(5);
            
            if (type !== 'custom') scanCtx.fill(); // Custom uses stroke, others use fill for solid shape

            scanCtx.restore();

            // Raycast Scan
            const pixels = scanCtx.getImageData(0, 0, w, h).data;
            const steps = 720;
            
            for (let i = 0; i < steps; i++) {
                let maxDist = 0;
                const angle = (i / steps) * Math.PI * 2;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);

                for (let dist = 0; dist < r; dist += 2) {
                    const x = Math.floor(cx + cos * dist);
                    const y = Math.floor(cy + sin * dist);
                    const idx = (y * w + x) * 4;
                    if (pixels[idx] > 100) maxDist = dist; 
                }
                vortexState.radiusMap[i] = maxDist / r; 
            }
        }

        function generateVortex() {
            // Configuration
            const swirlCount = parseInt(document.getElementById('vortexSwirl').value);
            const scaleFac = parseFloat(document.getElementById('vortexScale').value);
            const twistDeg = parseFloat(document.getElementById('vortexTwist').value);
            const tableRadius = parseFloat(document.getElementById('cfgRadius').value);
            
            // Generate Path
            const iterations = 10000; // Resolution
            const centerGap = 4;
            const newPoints = [];

            // Add starting break
            newPoints.push({type:'break'});

            // Loop Logic: t goes from -1 (Outer Start) -> 0 (Center) -> 1 (Outer End)
            for (let i = 0; i <= iterations; i++) {
                const t = (i / iterations) * 2 - 1;
                const progress = Math.abs(t); 
                
                // 1. Base Spiral Angle
                const spiralAngle = t * swirlCount * Math.PI * 2;
                
                // 2. Dynamic Shape Rotation (Twist)
                const twistRad = (twistDeg * (Math.PI/180)) * swirlCount * Math.abs(t);
                
                // 3. Shape Lookup
                let lookupAngle = spiralAngle + twistRad;
                let normAngle = lookupAngle % (Math.PI * 2);
                if (normAngle < 0) normAngle += Math.PI * 2;
                
                const mapIdx = Math.floor((normAngle / (Math.PI * 2)) * 720) % 720;
                let shapeFactor = vortexState.radiusMap[mapIdx];
                if(shapeFactor < 0.05) shapeFactor = 0.05; 

                // 4. Radius Calculation
                const maxR = tableRadius * scaleFac;
                const spiralR = centerGap + (progress * (maxR - centerGap));
                const r = spiralR * shapeFactor;

                // 5. Coord Calculation (Standard Math: Y is Up)
                let x, y;
                
                if (t < 0) {
                    // INCOMING
                    x = r * Math.cos(spiralAngle);
                    y = r * Math.sin(spiralAngle);
                } else {
                    // OUTGOING (Shifted 90 deg to create continuous flow)
                    const flipOffset = Math.PI / 2;
                    x = r * Math.cos(spiralAngle + flipOffset);
                    y = r * Math.sin(spiralAngle + flipOffset);
                }

                newPoints.push({x: x, y: y, type:'point'});
            }
            
            // Add ending break
            newPoints.push({type:'break'});

            // Overwrite current drawing
            rawPoints = newPoints;
            render();
        }

        // --- MASTER DUNE FILL ---
        function handleFillClick(e) {
            const clickPos = getPos(e);
            const DENSITY = fillGap; 
            const NOISE_SCALE = 0.05;
            const WAVE_AMP = 3.0; 
            const MAX_JUMP = 30.0; 

            let shapes = [];
            let currentShape = [];
            
            rawPoints.forEach(p => {
                if(p.type === 'break' || p.type === 'cmd') { if(currentShape.length > 2) shapes.push(currentShape); currentShape = []; } 
                else { if(currentShape.length > 0) { let last = currentShape[currentShape.length-1]; let dist = Math.hypot(p.x - last.x, p.y - last.y); if(dist > MAX_JUMP) { if(currentShape.length > 2) shapes.push(currentShape); currentShape = []; } } currentShape.push(p); }
            });
            if(currentShape.length > 2) shapes.push(currentShape);

            let candidates = [];
            for(let i=0; i<shapes.length; i++) { if(isPointInPolygon(clickPos, shapes[i])) { let bounds = getBounds(shapes[i]); candidates.push({ id: i, area: bounds.area, shape: shapes[i], bounds: bounds }); } }

            if(candidates.length === 0) { showToast("Click inside a closed shape", "error"); return; }
            candidates.sort((a,b) => a.area - b.area);
            const target = candidates[0]; 
            
            let holes = [];
            shapes.forEach((s, idx) => { if(idx === target.id) return; if(isPointInPolygon(s[0], target.shape)) { let sBounds = getBounds(s); if(sBounds.area < target.area) { holes.push(s); } } });

            showToast("Generating Smart Trace...", "info");
            saveState();

            const fillAngle = Math.random() * Math.PI; 
            const rotatePt = (x, y, rad) => ({ x: x * Math.cos(rad) - y * Math.sin(rad), y: x * Math.sin(rad) + y * Math.cos(rad) });

            const rotTarget = target.shape.map(p => rotatePt(p.x, p.y, -fillAngle));
            const rotHoles = holes.map(h => h.map(p => rotatePt(p.x, p.y, -fillAngle)));
            const rotBounds = getBounds(rotTarget);
            
            let y = rotBounds.minY + DENSITY;
            let direction = 1;
            
            rawPoints.push({type: 'break'});

            let lastFilledPointRot = null;

            while(y < rotBounds.maxY) {
                let cutPoints = [];
                const addIntersections = (poly, polyId) => {
                    for(let i=0; i<poly.length; i++) {
                        let p1 = poly[i]; let p2 = poly[(i+1)%poly.length];
                        if((p1.y <= y && p2.y > y) || (p1.y > y && p2.y <= y)) {
                            let x = p1.x + (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);
                            cutPoints.push({x:x, polyIndex: polyId}); 
                        }
                    }
                };
                addIntersections(rotTarget, -1); rotHoles.forEach((h, idx) => addIntersections(h, idx));
                cutPoints.sort((a,b) => a.x - b.x);

                for(let k=0; k<cutPoints.length; k++) {
                     if(k+1 >= cutPoints.length) break;
                     let startCut = cutPoints[k]; let endCut = cutPoints[k+1];
                     let midX = (startCut.x + endCut.x) / 2; let pMid = {x: midX, y: y};
                     let isInsideTarget = isPointInPolygon(pMid, rotTarget); let isInsideHole = false;
                     for(let rh of rotHoles) { if(isPointInPolygon(pMid, rh)) { isInsideHole = true; break; } }

                     if(isInsideTarget && !isInsideHole) {
                        let segPoints = []; const step = 2.0; let xStart = startCut.x; let xEnd = endCut.x;
                        if(direction === 1) { for(let x=xStart; x<=xEnd; x+=step) segPoints.push(x); if(segPoints[segPoints.length-1] !== xEnd) segPoints.push(xEnd); } 
                        else { for(let x=xEnd; x>=xStart; x-=step) segPoints.push(x); if(segPoints[segPoints.length-1] !== xStart) segPoints.push(xStart); }
                        let segmentStartPointRot = {x: segPoints[0], y:y};
                        if(lastFilledPointRot) {
                            let startPoly = findClosestPoly(lastFilledPointRot, rotTarget, rotHoles);
                            let endPoly = findClosestPoly(segmentStartPointRot, rotTarget, rotHoles);
                            if(startPoly && endPoly && startPoly === endPoly) {
                                let idx1 = findClosestIndex(lastFilledPointRot, startPoly);
                                let idx2 = findClosestIndex(segmentStartPointRot, startPoly);
                                let trace = getPerimeterPath(idx1, idx2, startPoly);
                                trace.forEach(tp => { let rp = rotatePt(tp.x, tp.y, fillAngle); rawPoints.push({x:rp.x, y:rp.y, type:'point'}); });
                            } else { if(rawPoints.length>0 && rawPoints[rawPoints.length-1].type!=='break') { rawPoints.push({type:'break'}); } }
                        } else { rawPoints.push({type:'break'}); }
                        for(let px of segPoints) {
                            let noiseVal = Noise.eval(px * NOISE_SCALE, y * NOISE_SCALE); let py = y + (noiseVal * WAVE_AMP);
                            let realPt = rotatePt(px, py, fillAngle); let safe = isPointInPolygon(realPt, target.shape);
                            if(safe) { for(let h of holes) { if(isPointInPolygon(realPt, h)) { safe=false; break; } } }
                            if(safe) { rawPoints.push({x:realPt.x, y:realPt.y, type:'point'}); }
                        }
                        lastFilledPointRot = {x: segPoints[segPoints.length-1], y:y};
                     }
                }
                direction *= -1; y += DENSITY;
            }
            if(lastFilledPointRot) {
                 let startP = target.shape[0]; let startPRot = rotatePt(startP.x, startP.y, -fillAngle);
                 let idx1 = findClosestIndex(lastFilledPointRot, rotTarget); let idx2 = findClosestIndex(startPRot, rotTarget);
                 let trace = getPerimeterPath(idx1, idx2, rotTarget);
                 trace.forEach(tp => { let rp = rotatePt(tp.x, tp.y, fillAngle); rawPoints.push({x:rp.x, y:rp.y, type:'point'}); });
            } else { rawPoints.push({type: 'break'}); }

            target.shape.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'})); rawPoints.push({x:target.shape[0].x, y:target.shape[0].y, type:'point'});
            holes.forEach(h => { rawPoints.push({type: 'break'}); h.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'})); rawPoints.push({x:h[0].x, y:h[0].y, type:'point'}); });
            rawPoints.push({type: 'break'}); render(); showToast("Master Fill Complete!", "success");
        }

        // =======================================================
        // === HIGH PRECISION TRACE LOGIC & LIVE EDIT ===
        // =======================================================

        function handleImageUpload(input) {
            const file = input.files[0]; if(!file) return;
            showToast("Loading image...", "info"); saveState(); 
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Activate Trace Mode
                    traceState.active = true;
                    traceState.img = img;
                    traceState.x = 0;
                    traceState.y = 0;
                    traceState.scale = 1.0;
                    traceState.rotation = 0; // Reset Rotation
                    
                    // Calc base scale to fit 800x800 logic
                    const size = 800;
                    const scale = Math.min(size/img.width, size/img.height) * 0.9;
                    traceState.baseScale = scale;
                    traceState.scale = scale; // Initialize

                    commitTraceMove(); // Initial run
                    setTool('trace_set');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            input.value = ''; // Reset input to allow re-upload of same file
        }

        function drawTracePreview() {
            // Clears canvas and resets filters to prevent "Black Circle"
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            ctx.clearRect(0, 0, w, h);
            ctx.filter = 'none'; // IMPORTANT RESET
            
            // Draw Table Outline
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            ctx.save();
            ctx.translate(origin.x, origin.y);
            ctx.beginPath(); ctx.arc(0, 0, tableR*scale, 0, Math.PI*2);
            ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.stroke();

            const internalSize = 800;
            const visualScale = (tableR * 2 / 800) * scale;
            
            ctx.save();
            ctx.scale(visualScale, visualScale);
            
            // Apply translation in Trace Units
            ctx.translate(traceState.x, traceState.y); 
            // Apply Rotation
            ctx.rotate(traceState.rotation * Math.PI / 180);
            
            // Draw Image Centered
            const img = traceState.img;
            const drawW = img.width * traceState.scale;
            const drawH = img.height * traceState.scale;
            
            // Set Filter just for the image
            ctx.filter = 'grayscale(100%) contrast(1000%) invert(1)';
            ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
            
            ctx.restore();
            ctx.restore();
            
            // Reset filter for next frame
            ctx.filter = 'none';
        }

        function commitTraceMove() {
            const size = 800;
            const buff = document.getElementById('hiddenTraceBuffer');
            const bCtx = buff.getContext('2d');
            
            bCtx.globalCompositeOperation = 'source-over';
            bCtx.fillStyle = "white"; 
            bCtx.fillRect(0, 0, size, size);
            
            bCtx.save();
            bCtx.translate(size/2, size/2); // Move to center of 800x800
            bCtx.translate(traceState.x, traceState.y); // Apply offset
            bCtx.rotate(traceState.rotation * Math.PI / 180); // Apply Rotation
            
            const drawW = traceState.img.width * traceState.scale;
            const drawH = traceState.img.height * traceState.scale;
            
            bCtx.drawImage(traceState.img, -drawW/2, -drawH/2, drawW, drawH);
            bCtx.restore();
            
            traceImgData = bCtx.getImageData(0,0,size,size);
            runHighPrecisionTrace();
        }

        function runHighPrecisionTrace() {
            if(!traceImgData) return;
            const thresh = parseInt(document.getElementById('traceThreshInput').value); 
            document.getElementById('traceThreshVal').innerText = thresh;
            const density = parseFloat(document.getElementById('traceDensityInput').value); 
            document.getElementById('traceDensityVal').innerText = density.toFixed(1);
            
            const SIZE = 800; 
            const CENTER = SIZE / 2;
            let pixelGrid = new Uint8Array(SIZE*SIZE);
            for(let i=0; i<SIZE*SIZE; i++) { pixelGrid[i] = traceImgData.data[i*4] < thresh ? 1 : 0; }
            
            let contours = []; const traced = new Uint8Array(SIZE*SIZE).fill(0);
            const traceBoundary = (sx, sy) => {
                const path = []; let cx = sx, cy = sy; let bx = sx-1, by = sy; let max = SIZE*4;
                do {
                    path.push({x:cx, y:cy}); traced[cy*SIZE+cx] = 1;
                    const n = [{x:-1,y:0},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:-1,y:1}];
                    let startIdx = 0; for(let i=0; i<8; i++) if(bx===cx+n[i].x && by===cy+n[i].y) startIdx=(i+1)%8;
                    let found = false;
                    for(let i=0; i<8; i++) {
                        const idx = (startIdx + i)%8; const nx = cx + n[idx].x; const ny = cy + n[idx].y;
                        if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && pixelGrid[ny*SIZE+nx]===1) { bx=cx; by=cy; cx=nx; cy=ny; found=true; break; } else { bx=nx; by=ny; }
                    }
                    if(!found) break; max--;
                } while((cx!==sx || cy!==sy) && max>0);
                return path;
            };
            for(let y=1; y<SIZE-1; y++) {
                for(let x=1; x<SIZE-1; x++) {
                    const idx = y*SIZE + x;
                    if(pixelGrid[idx] === 1 && pixelGrid[idx-1] === 0 && traced[idx] === 0) {
                        const pth = traceBoundary(x, y);
                        if(pth.length > 20) {
                             let maxDist = 0; let triggerPt = pth[0]; let bestIdx = 0;
                             pth.forEach((p, i) => { const dist = Math.hypot(p.x - CENTER, p.y - CENTER); if(dist > maxDist) { maxDist = dist; triggerPt = p; bestIdx = i; } });
                             const reordered = [...pth.slice(bestIdx), ...pth.slice(0, bestIdx)]; reordered.push(reordered[0]); contours.push({ points: reordered, trigger: triggerPt, merged: false });
                        }
                    }
                }
            }
            let spiral = []; const maxR = SIZE/2 - 5;
            // FIX: REMOVED INITIAL RIM PUSH TO FORCE START AT CENTER
            spiral.push({x: CENTER, y: CENTER});
            
            let angle = 0; let r = 0; const angleStep = 0.02; const spacingPx = density * 4.0; 
            while(r < maxR) {
                r = (spacingPx / (2*Math.PI)) * angle;
                let x = CENTER + Math.cos(angle)*r; let y = CENTER + Math.sin(angle)*r;
                let wiggle = 0; const ix = Math.floor(x), iy = Math.floor(y);
                if(ix>=0 && ix<SIZE && iy>=0 && iy<SIZE) { if(pixelGrid[iy*SIZE+ix] === 1) wiggle = Math.sin(angle * 30) * (spacingPx * 0.3); }
                x += Math.cos(angle) * wiggle; y += Math.sin(angle) * wiggle;
                spiral.push({ x: x, y: y }); angle += angleStep;
            }
            let finalPath = []; const distTolerance = spacingPx * 1.5;
            for(let i=0; i<spiral.length; i++) {
                const sp = spiral[i]; finalPath.push(sp);
                contours.forEach(c => {
                    if(!c.merged) {
                        const dist = Math.hypot(sp.x - c.trigger.x, sp.y - c.trigger.y);
                        if (dist < distTolerance) { c.points.forEach(p => finalPath.push(p)); finalPath.push(sp); c.merged = true; }
                    }
                });
            }
            const tableR = parseFloat(document.getElementById('cfgRadius').value); const scaleFac = (tableR * 2) / SIZE;
            rawPoints = []; if(finalPath.length > 0) rawPoints.push({type:'break'});
            finalPath.forEach(p => { let tx = (p.x - 400) * scaleFac; let ty = (400 - p.y) * scaleFac; rawPoints.push({ x: tx, y: ty, type: 'point' }); });
            if(finalPath.length > 0) rawPoints.push({type:'break'});
            
            render();
        }

        function resizeCanvas() {
            const container = document.getElementById('canvasContainer'); const size = container.getBoundingClientRect().width; const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr; canvas.height = size * dpr; ctx.scale(dpr, dpr); origin = { x: size/2, y: size/2 };
            const tableR = parseFloat(document.getElementById('cfgRadius').value); scale = (size/2) / (tableR * 1.05); render();
        }
        function saveState() { if(historyStack.length>10) historyStack.shift(); historyStack.push(JSON.stringify(rawPoints)); }
        function undo() { if(historyStack.length===0) return; rawPoints = JSON.parse(historyStack.pop()); resetStatus(); render(); }
        function clearCanvas() { saveState(); rawPoints = []; traceState.active=false; resetStatus(); render(); }
        function setTool(t) {
            currentTool = t;
            document.getElementById('btnDraw').className = t==='draw'?'active':'secondary';
            document.getElementById('btnErase').className = t==='erase'?'active':'secondary';
            document.getElementById('btnFill').className = t==='fill'?'active':'secondary';
            document.getElementById('btnSelect').className = t==='select'?'active':'secondary';
            document.getElementById('btnSandify').className = t==='sandify'?'active':'secondary';
            document.getElementById('btnTrace').className = t==='trace_set'?'active':'secondary';
            updateToolSettings();
            
            // Show special UI message if selecting Move while Trace is active
            if(t === 'select' && traceState.active) {
                document.getElementById('traceMoveMsg').style.display = 'block';
            } else {
                document.getElementById('traceMoveMsg').style.display = 'none';
            }

            if(t === 'sandify') {
                if (rawPoints.length === 0) { addShape('random'); }
                vortexSourcePath = JSON.parse(JSON.stringify(rawPoints));
                document.getElementById('vortexShape').value = 'custom';
                updateVortexParams(); 
            }
        }
        
        function updateToolSettings() {
            const area = document.getElementById('toolSettingsArea'); const grps = document.querySelectorAll('.tool-setting-group'); grps.forEach(g => g.style.display = 'none');
            let activeGrp = null;
            if(currentTool === 'draw') activeGrp = document.getElementById('set-pen');
            if(currentTool === 'erase') activeGrp = document.getElementById('set-erase');
            if(currentTool === 'fill') activeGrp = document.getElementById('set-fill');
            if(currentTool === 'select') activeGrp = document.getElementById('set-select');
            if(currentTool === 'sandify') activeGrp = document.getElementById('set-sandify');
            if(currentTool === 'trace_set') activeGrp = document.getElementById('set-trace');
            if(activeGrp) { area.style.display = 'block'; activeGrp.style.display = 'block'; } else { area.style.display = 'none'; }
            eraserRadius = parseInt(document.getElementById('eraserSizeSlider').value); document.getElementById('eraseSizeVal').innerText = eraserRadius + 'px';
            fillGap = parseFloat(document.getElementById('fillGapSlider').value); document.getElementById('fillGapVal').innerText = fillGap.toFixed(1);
        }

        function updateUI() { document.getElementById('symVal').textContent = document.getElementById('symSlider').value + 'x'; render(); }
        function showToast(msg, type) { const t = document.getElementById('status-toast'); t.textContent = msg; t.className = type; t.style.opacity = 1; setTimeout(()=>t.style.opacity=0, 3000); }
        function openNav() { document.getElementById("mySidebar").style.width = "250px"; }
        function closeNav() { document.getElementById("mySidebar").style.width = "0"; }
        function toggleTheme() { const b = document.body; b.setAttribute('data-theme', b.getAttribute('data-theme')==='dark'?'light':'dark'); render(); }
        function resetStatus() { generatedGCode = null; processedPoints = []; document.getElementById('statusTxt').innerText = "Drawing Mode"; document.getElementById('statusTxt').style.color = "var(--primary)"; document.getElementById('progressSlider').value = 100; render(); }
        function render() {
            const w = canvas.width / window.devicePixelRatio; const h = canvas.height / window.devicePixelRatio; ctx.clearRect(0, 0, w, h);
            ctx.filter = 'none'; // RESET FILTER TO PREVENT BLACK CIRCLE GLITCH
            const tableR = parseFloat(document.getElementById('cfgRadius').value); const sym = parseInt(document.getElementById('symSlider').value); const dark = document.body.getAttribute('data-theme') === 'dark'; const prog = parseInt(document.getElementById('progressSlider').value); document.getElementById('progVal').textContent = prog + '%';
            ctx.save(); ctx.translate(origin.x, origin.y); ctx.beginPath(); ctx.arc(0, 0, tableR*scale, 0, Math.PI*2); ctx.strokeStyle = dark ? '#444' : '#ddd'; ctx.lineWidth = 2; ctx.stroke();
            const showingFinal = (processedPoints.length > 0); const dataToShow = showingFinal ? processedPoints : rawPoints; const limit = Math.floor(dataToShow.length * (prog/100)); const color = showingFinal ? '#ff0000' : (dark ? 'cyan' : '#007bff'); ctx.lineWidth = 1.5; const loopCount = showingFinal ? 1 : sym;
            for(let s=0; s<loopCount; s++) {
                const ang = s * (Math.PI*2/sym); ctx.save(); if(!showingFinal) ctx.rotate(ang); ctx.beginPath(); ctx.strokeStyle = color; let isMove = true;
                for(let i=0; i<limit; i++) { const p = dataToShow[i]; if(p.type === 'break' || p.type === 'cmd') { isMove = true; continue; } const px = p.x * scale; const py = -p.y * scale; if(isMove) { ctx.moveTo(px, py); isMove = false; } else ctx.lineTo(px, py); }
                ctx.stroke(); if(limit > 0 && limit < dataToShow.length) { const tip = dataToShow[limit]; if(tip.type !== 'break' && tip.type !== 'cmd') { ctx.beginPath(); ctx.arc(tip.x*scale, -tip.y*scale, 4, 0, Math.PI*2); ctx.fillStyle = color; ctx.fill(); } } ctx.restore();
            }
            if(currentTool === 'select' && rawPoints.length > 0 && !generatedGCode && !traceState.active) { let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity; rawPoints.forEach(p => { if(p.type === 'point') { if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x; if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y; } }); if(minX !== Infinity) { ctx.beginPath(); ctx.rect(minX*scale, -maxY*scale, (maxX-minX)*scale, (maxY-minY)*scale); ctx.strokeStyle = dark ? "white" : "black"; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]); } }
            ctx.restore();
        }

        async function sendToTable() { if(!generatedGCode) return showToast("Click Prepare first", "error"); let code = generatedGCode; if(document.getElementById('autoClearMode').checked) { try { let r = await fetch('./designs/clear.txt'); if(r.ok) code = (await r.text()) + "\n" + code; } catch(e) {} } fetch(BASE_URL+'/send_gcode_block', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({gcode:code}) }).then(r => r.json()).then(d => showToast(d.success ? "Sent!" : "Error", d.success ? "success" : "error")); }
        async function saveToServer() { if(!generatedGCode) return showToast("Prepare Path first!", "error"); let n = prompt("Enter filename (will be saved as .txt):"); if(n) { if(!n.toLowerCase().endsWith('.txt')) n += ".txt"; showToast("Saving...", "info"); fetch(BASE_URL+'/save_design', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({filename:n, gcode:generatedGCode}) }).then(r => r.json()).then(d => { if(d.success) showToast("Saved to Pi!", "success"); else showToast("Save Failed: " + (d.error || "Unknown"), "error"); }).catch(e => showToast("Network Error", "error")); } }
        function getShortestRotation(raw, last) { let diff = (raw - last) / (2 * Math.PI); let offset = Math.round(diff); return raw - (offset * 2 * Math.PI); }
        function calculateIK(x, y, lastBaseSteps, lastElbowSteps, L1, L2, gearRatio, stepsPerRad) {
            let dist = Math.hypot(x, y); if (dist < 2.0) { const targetBaseSteps = lastBaseSteps; const currentBaseAngle = -lastBaseSteps / stepsPerRad; const targetElbowSteps = -(Math.PI + gearRatio * currentBaseAngle) * stepsPerRad; return { base_steps: targetBaseSteps, elbow_steps: targetElbowSteps }; }
            const maxReach = L1 + L2; if (dist > maxReach) { x = (x / dist) * maxReach; y = (y / dist) * maxReach; dist = maxReach; }
            const lastT1 = -lastBaseSteps / stepsPerRad; let cosBend = (dist*dist - L1*L1 - L2*L2) / (2 * L1 * L2); cosBend = Math.max(-1, Math.min(1, cosBend)); const bend1 = Math.acos(cosBend); const bend2 = -Math.acos(cosBend);
            const k1_1 = L1 + L2 * Math.cos(bend1); const k2_1 = L2 * Math.sin(bend1); let t1_1 = Math.atan2(y, x) - Math.atan2(k2_1, k1_1); t1_1 = getShortestRotation(t1_1, lastT1);
            const k1_2 = L1 + L2 * Math.cos(bend2); const k2_2 = L2 * Math.sin(bend2); let t1_2 = Math.atan2(y, x) - Math.atan2(k2_2, k1_2); t1_2 = getShortestRotation(t1_2, lastT1);
            const b1_steps = -t1_1 * stepsPerRad; const e1_steps = -(bend1 + gearRatio * t1_1) * stepsPerRad; const b2_steps = -t1_2 * stepsPerRad; const e2_steps = -(bend2 + gearRatio * t1_2) * stepsPerRad;
            const cost1 = Math.abs(b1_steps - lastBaseSteps) + Math.abs(e1_steps - lastElbowSteps); const cost2 = Math.abs(b2_steps - lastBaseSteps) + Math.abs(e2_steps - lastElbowSteps); return (cost1 <= cost2) ? { base_steps: b1_steps, elbow_steps: e1_steps } : { base_steps: b2_steps, elbow_steps: e2_steps };
        }
        
        // --- ADDED GENERATION LOGIC ---
        function prepareGCode() {
            if(rawPoints.length === 0) return showToast("Draw something first!", "error");
            showToast("Optimizing Path...", "info");
            setTimeout(() => { 
                const tableR = parseFloat(document.getElementById('cfgRadius').value);
                const sym = parseInt(document.getElementById('symSlider').value);
                let shapes = [];
                let curShape = [];
                rawPoints.forEach(p => {
                    if(p.type === 'break' || p.type === 'cmd') {
                        if(curShape.length > 0) shapes.push(curShape);
                        curShape = [];
                    } else { curShape.push(p); }
                });
                if(curShape.length > 0) shapes.push(curShape);
                let pool = [];
                for(let s=0; s<sym; s++) {
                    const ang = s * (Math.PI*2/sym);
                    const c = Math.cos(ang), si = Math.sin(ang);
                    shapes.forEach(sh => {
                        let newSh = sh.map(p => ({ x: p.x*c - p.y*si, y: p.x*si + p.y*c, type: 'point' }));
                        pool.push(newSh);
                    });
                }
                let bestShapeIdx = -1, bestPointIdx = -1, maxDist = -1;
                for (let i=0; i<pool.length; i++) {
                    for (let j=0; j<pool[i].length; j++) {
                        let d = Math.hypot(pool[i][j].x, pool[i][j].y);
                        if (d > maxDist) { maxDist = d; bestShapeIdx = i; bestPointIdx = j; }
                    }
                }
                let startShape = pool[bestShapeIdx];
                pool.splice(bestShapeIdx, 1);
                let dClose = Math.hypot(startShape[0].x - startShape[startShape.length-1].x, startShape[0].y - startShape[startShape.length-1].y);
                if(dClose < 5.0) { 
                    let p1 = startShape.slice(bestPointIdx);
                    let p2 = startShape.slice(0, bestPointIdx);
                    startShape = p1.concat(p2);
                    startShape.push(startShape[0]);
                } else { 
                    // FIX: START FROM CENTER FOR OPEN SHAPES
                    let dStart = Math.hypot(startShape[0].x, startShape[0].y);
                    let dEnd = Math.hypot(startShape[startShape.length-1].x, startShape[startShape.length-1].y);
                    
                    // If start (dStart) is further from center than end (dEnd), REVERSE it so it starts at center.
                    if(dStart > dEnd) startShape.reverse();
                }
                let sortedShapes = [startShape];
                let curPos = startShape[startShape.length-1];
                while(pool.length > 0) {
                    let bestIdx = -1, bestDist = Infinity, bestStartIdx = 0, bestIsReverse = false;
                    for(let i=0; i<pool.length; i++) {
                        let s = pool[i];
                        let isClosed = Math.hypot(s[0].x - s[s.length-1].x, s[0].y - s[s.length-1].y) < 5.0;
                        if(isClosed) {
                            for(let k=0; k<s.length; k++) {
                                let d = Math.hypot(curPos.x - s[k].x, curPos.y - s[k].y);
                                if(d < bestDist) { bestDist = d; bestIdx = i; bestStartIdx = k; bestIsReverse = false; }
                            }
                        } else {
                            let dStart = Math.hypot(curPos.x - s[0].x, curPos.y - s[0].y);
                            if(dStart < bestDist) { bestDist=dStart; bestIdx=i; bestStartIdx=0; bestIsReverse=false; }
                            let dEnd = Math.hypot(curPos.x - s[s.length-1].x, curPos.y - s[s.length-1].y);
                            if(dEnd < bestDist) { bestDist=dEnd; bestIdx=i; bestStartIdx=0; bestIsReverse=true; }
                        }
                    }
                    let winner = pool[bestIdx];
                    let isWinnerClosed = Math.hypot(winner[0].x - winner[winner.length-1].x, winner[0].y - winner[winner.length-1].y) < 5.0;
                    if(isWinnerClosed) {
                        let p1 = winner.slice(bestStartIdx);
                        let p2 = winner.slice(0, bestStartIdx);
                        winner = p1.concat(p2);
                        winner.push(winner[0]);
                    } else {
                        if(bestIsReverse) winner.reverse();
                    }
                    sortedShapes.push(winner);
                    curPos = winner[winner.length-1];
                    pool.splice(bestIdx, 1);
                }
                processedPoints = [];
                let stats_connections = 0;
                let stats_rerouted = 0;
                if(sortedShapes.length > 0) {
                    let fPt = sortedShapes[0][0];
                    let fAng = Math.atan2(fPt.y, fPt.x);
                    processedPoints.push({x: tableR*Math.cos(fAng), y: tableR*Math.sin(fAng), type:'point'});
                }
                for(let i=0; i<sortedShapes.length; i++) {
                    let s = sortedShapes[i];
                    if(i > 0) {
                        stats_connections++;
                        let prev = sortedShapes[i-1];
                        let currStart = s[0];
                        let bestExitIdx = -1;
                        let minDist = Infinity;
                        for(let k=0; k<prev.length; k++) {
                            let d = Math.hypot(prev[k].x - currStart.x, prev[k].y - currStart.y);
                            if(d < minDist) { minDist = d; bestExitIdx = k; }
                        }
                        let isPrevClosed = Math.hypot(prev[0].x - prev[prev.length-1].x, prev[0].y - prev[prev.length-1].y) < 5.0;
                        let retracePath = [];
                        if(isPrevClosed) {
                            let distFwd = bestExitIdx; 
                            let distBk = (prev.length-1) - bestExitIdx;
                            if(distFwd < distBk) { for(let m=0; m<=bestExitIdx; m++) retracePath.push(prev[m]); } 
                            else { for(let m=prev.length-1; m>=bestExitIdx; m--) retracePath.push(prev[m]); }
                        } else { for(let m=prev.length-1; m>=bestExitIdx; m--) retracePath.push(prev[m]); }
                        retracePath.forEach(p => processedPoints.push(p));
                        let startJump = prev[bestExitIdx];
                        let safePath = routeConnect(startJump, currStart, sortedShapes);
                        if(safePath.length > 1) { stats_rerouted++; }
                        safePath.forEach(p => processedPoints.push({x:p.x, y:p.y, type:'point'}));
                    }
                    s.forEach(p => processedPoints.push(p));
                }
                if(processedPoints.length > 0) {
                    let lastPt = processedPoints[processedPoints.length-1];
                    processedPoints.push({type: 'cmd', val: 'M0'});
                    let exitAng = Math.atan2(lastPt.y, lastPt.x);
                    processedPoints.push({ x: tableR * Math.cos(exitAng), y: tableR * Math.sin(exitAng), type: 'point' });
                }
                generatedGCode = generateGCodeStringFromProcessed();
                let summary = `Path Ready! ${sortedShapes.length} shapes. ${stats_rerouted}/${stats_connections} jumps rerouted.`;
                document.getElementById('statusTxt').innerText = summary;
                document.getElementById('statusTxt').style.color = "green";
                document.getElementById('progressSlider').value = 0;
                document.getElementById('designPhaseControls').style.display = 'none';
                document.getElementById('productionPhaseControls').style.display = 'block';
                document.getElementById('productionPhaseControls').classList.add('fade-in');
                render(); 
                showToast(summary, "success");
            }, 50);
        }

        function returnToEditing() {
            generatedGCode = null;
            processedPoints = [];
            document.getElementById('designPhaseControls').style.display = 'block';
            document.getElementById('productionPhaseControls').style.display = 'none';
            document.getElementById('designPhaseControls').classList.add('fade-in');
            resetStatus();
            updateUI();
        }

        function generateGCodeStringFromProcessed() {
            const L1 = parseFloat(document.getElementById('cfgL1').value);
            const L2 = parseFloat(document.getElementById('cfgL2').value);
            const gearRatio = 1.125;
            const tableRadius = parseFloat(document.getElementById('cfgRadius').value);
            const stepsPerDeg = parseFloat(document.getElementById('cfgStepsPerDeg').value);
            const stepsPerRad = stepsPerDeg * (180 / Math.PI);
            const centerDelay = parseFloat(document.getElementById('cfgCenterDelay').value);
            const perimDelay = parseFloat(document.getElementById('cfgPerimDelay').value);
            let cmds = [];
            let prevBase = 0;
            let prevElbow = 0;
            let firstPt = processedPoints[0];
            if(firstPt.type === 'cmd') return "";
            let startIK = calculateIK(-firstPt.x, firstPt.y, 0, 0, L1, L2, gearRatio, stepsPerRad);
            prevBase = startIK.base_steps;
            prevElbow = startIK.elbow_steps;
            for(let i=0; i<processedPoints.length-1; i++) {
                let p1 = processedPoints[i];
                let p2 = processedPoints[i+1];
                if (p1.type === 'cmd' && p1.val === 'M0') { cmds.push("M0"); }
                if (p2.type === 'cmd' && p2.val === 'M0') { continue; }
                let startX, startY;
                if(p1.type === 'cmd') {
                   let back = i-1;
                   while(back >= 0 && processedPoints[back].type === 'cmd') back--;
                   if(back < 0) { startX=0; startY=0; }
                   else { startX = processedPoints[back].x; startY = processedPoints[back].y; }
                } else { startX = p1.x; startY = p1.y; }
                let dist = Math.hypot(p2.x-startX, p2.y-startY);
                let steps = Math.max(1, Math.ceil(dist / 1.0)); 
                for(let j=1; j<=steps; j++) {
                    let t = j/steps;
                    let x = startX + (p2.x - startX)*t;
                    let y = startY + (p2.y - startY)*t;
                    let ik = calculateIK(-x, y, prevBase, prevElbow, L1, L2, gearRatio, stepsPerRad);
                    let dBase = Math.round(ik.base_steps - prevBase);
                    let dElbow = Math.round(ik.elbow_steps - prevElbow);
                    if(dBase !== 0 || dElbow !== 0) {
                        let r = Math.hypot(x, y);
                        if (r < 5.0 && (Math.abs(dBase) > 2000 || Math.abs(dElbow) > 2000)) { prevBase += dBase; prevElbow += dElbow; continue; }
                        let rFactor = r / tableRadius;
                        if(rFactor > 1) rFactor = 1;
                        let delay = Math.round(centerDelay + ((perimDelay - centerDelay) * rFactor));
                        cmds.push(`G1 ${dElbow} ${dBase} ${delay}`);
                        prevBase += dBase; prevElbow += dElbow;
                    }
                }
            }
            return cmds.join('\n');
        }

        // --- NEW COPY FUNCTION ---
        function copyGCode() {
            if(!generatedGCode) return showToast("Prepare path first!", "error");
            navigator.clipboard.writeText(generatedGCode).then(() => {
                showToast("GCode copied to clipboard!", "success");
            }).catch(err => {
                showToast("Failed to copy", "error");
            });
        }

        init();
    </script>
</body>
</html>
