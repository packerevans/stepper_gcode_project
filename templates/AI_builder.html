<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Packers Sand Pro (Synced v28 - Strict Logic)</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

    <style>
        :root {
            --primary: #d2b48c; 
            --secondary: #b08d5c; 
            --bg: #f4f4f4; 
            --panel: #ffffff; 
            --text: #333; 
            --accent: #2ecc71;
            --danger: #e74c3c;
            --btn-text: #fff;
        }
        body[data-theme='dark'] {
            --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --btn-text: #000;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--bg); color: var(--text);
            margin: 0; padding: 0; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
        }

        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--panel);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100;
        }
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background-color: var(--primary); overflow-x: hidden;
            transition: 0.3s; padding-top: 60px; z-index: 2000;
            box-shadow: 4px 0 10px rgba(0,0,0,0.3);
        }
        .sidebar a {
            padding: 15px 24px; text-decoration: none; font-size: 18px;
            color: #fff; display: block; font-weight: 500;
        }

        .app-container {
            display: flex; flex-direction: column; height: 100%; width: 100%;
            padding: 10px; box-sizing: border-box; gap: 10px; overflow-y: auto;
        }
        @media (min-width: 768px) {
            .app-container { flex-direction: row; overflow: hidden; }
            .drawing-panel { flex: 2; border-radius: 16px; background: var(--panel); position: relative; }
            .controls-panel { flex: 1; max-width: 400px; border-radius: 16px; background: var(--panel); padding: 20px; overflow-y: auto; }
        }
        @media (max-width: 767px) {
            .drawing-panel { width: 100%; aspect-ratio: 1/1; border-radius: 16px; background: var(--panel); flex-shrink: 0; }
            .controls-panel { flex: 1; border-radius: 16px; background: var(--panel); padding: 15px; }
        }

        .canvas-wrapper {
            position: relative; width: 95%; height: 95%; margin: auto;
            aspect-ratio: 1/1; border-radius: 50%;
            border: 4px solid var(--primary); background: #fff;
            touch-action: none; cursor: crosshair; overflow: hidden;
            top: 50%; transform: translateY(-50%);
        }
        body[data-theme='dark'] .canvas-wrapper { background: #222; border-color: var(--secondary); }
        canvas { display: block; width: 100%; height: 100%; border-radius: 50%; }

        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: var(--secondary); text-align: center; }
        .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
        button {
            background: var(--primary); color: var(--btn-text); border: none;
            padding: 12px; border-radius: 8px; font-weight: 600; cursor: pointer;
            flex: 1; transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        button.secondary { background: transparent; border: 1px solid var(--text); color: var(--text); }
        button.active { background: var(--secondary); border: 2px solid var(--text); }
        button.action { background: var(--accent); color: #000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .slider-row { margin-bottom: 15px; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; font-weight: bold; }
        input[type="range"] { width: 100%; accent-color: var(--secondary); }
        
        #progressSlider {
            -webkit-appearance: none; width: 100%; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none;
        }
        #progressSlider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--secondary); cursor: pointer;
        }

        details { background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; }
        summary { cursor: pointer; font-weight: bold; font-size: 13px; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        input[type="number"] { width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; font-family: monospace;}

        #status-toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 3000;
        }
        .success { background: var(--accent) !important; color: #000 !important; }
        .error { background: var(--danger) !important; color: #fff !important; }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 0 5px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-tog { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-tog:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-tog { background-color: var(--secondary); }
        input:checked + .slider-tog:before { transform: translateX(18px); }

    </style>
</head>
<body data-theme="light">

    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Designs</a> 
        <a href="/controls">Drawing</a>
        <a href="/led_controls">LED Controls</a>
        <a href="/ai_builder">AI Builder</a>
        <a href="/terminal">Terminal</a>
    </div>

    <div class="nav-bar">
        <button style="flex:0; background:none; font-size:24px; color:var(--text); padding:0;" onclick="openNav()">‚ò∞</button>
        <h1 style="margin:0; font-size:1.2rem;">Sand Controller</h1>
        <button style="flex:0; background:none; font-size:20px;" onclick="toggleTheme()">‚òÄÔ∏è</button>
    </div>

    <div class="app-container">
        
        <div class="drawing-panel">
            <div class="canvas-wrapper" id="canvasContainer">
                <canvas id="drawCanvas"></canvas>
            </div>
            <div id="coordDisplay" style="position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none;">X:0 Y:0</div>
        </div>

        <div class="controls-panel">
            <h2>Tools</h2>
            
            <div class="toggle-row">
                <span style="font-weight:600; font-size:13px;">üñãÔ∏è Smart Pen Mode</span>
                <label class="switch">
                    <input type="checkbox" id="smartPenMode" checked>
                    <span class="slider-tog"></span>
                </label>
            </div>

            <div class="btn-group">
                <button id="btnDraw" onclick="setTool('draw')" class="active">‚úèÔ∏è Draw</button>
                <button id="btnErase" onclick="setTool('erase')" class="secondary">üßº Erase</button>
            </div>

            <div class="btn-group">
                <input type="file" id="imgUpload" accept="image/*" style="display:none" onchange="handleImageUpload(this)">
                <button class="secondary" onclick="document.getElementById('imgUpload').click()">‚ú® Trace Image</button>
            </div>

            <div class="btn-group">
                <button onclick="undo()" class="secondary">‚Ü∂ Undo</button>
                <button onclick="clearCanvas()" class="secondary" style="color:var(--danger); border-color:var(--danger);">‚úñ Clear</button>
            </div>

            <hr style="border:0; border-top:1px solid #ddd; margin: 15px 0;">
            
             <div class="slider-row">
                <div class="slider-header"><span>SYMMETRY</span> <span id="symVal">1x</span></div>
                <input type="range" id="symSlider" min="1" max="12" value="1" step="1" oninput="updateUI()">
            </div>

            <div class="slider-row">
                <div class="slider-header"><span>SIMULATION (Start ‚Æï Finish)</span> <span id="progVal">100%</span></div>
                <input type="range" id="progressSlider" min="0" max="100" value="100" oninput="render()">
            </div>

            <button class="action" onclick="prepareGCode()" style="margin-bottom:15px; font-size:1.1em;">‚öôÔ∏è Prepare Path</button>

            <div style="text-align:center; font-size:12px; margin-bottom:10px; color:#666;">
                Status: <span id="statusTxt" style="font-weight:bold; color:var(--primary);">Drawing Mode</span>
            </div>

            <div class="toggle-row" style="background:rgba(0,0,0,0.03); padding:8px; border-radius:8px; margin-bottom:10px;">
                <span style="font-weight:600; font-size:13px;">‚ú® Auto-Clear Before Run</span>
                <label class="switch">
                    <input type="checkbox" id="autoClearMode" checked>
                    <span class="slider-tog"></span>
                </label>
            </div>

            <div class="btn-group">
                <button onclick="sendToTable()" class="active">üöÄ Run</button>
                <button onclick="saveToServer()" class="secondary">üíæ Save to Pi</button>
            </div>
            
            <div class="btn-group">
                <button onclick="downloadThetaRho()" class="secondary" style="border-color:#2ecc71; color:#2ecc71;">üì• Copy .THR</button>
            </div>

            <details>
                <summary>‚öôÔ∏è Machine Settings</summary>
                <div class="settings-grid">
                    <div><label>Radius</label><input type="number" id="cfgRadius" value="202.6" onchange="resizeCanvas()"></div>
                    <div><label>Center (us)</label><input type="number" id="cfgCenterDelay" value="500"></div>
                    <div><label>Rim (us)</label><input type="number" id="cfgPerimDelay" value="3000"></div>
                    <div><label>Steps/Deg</label><input type="number" id="cfgStepsPerDeg" value="8.888888"></div>
                    <div><label>Arm 1</label><input type="number" id="cfgL1" value="101.3"></div>
                    <div><label>Arm 2</label><input type="number" id="cfgL2" value="101.3"></div>
                    <div><label>Gear Ratio</label><input type="number" id="cfgGearRatio" value="1.125"></div>
                    <div><label>Resolution</label><input type="number" id="cfgResolution" value="1.0"></div>
                </div>
            </details>
        </div>
    </div>

    <div id="status-toast"></div>

    <script>
        let rawPoints = []; 
        let processedPoints = []; 
        let historyStack = [];
        let isDrawing = false;
        let currentTool = 'draw';
        let origin = {x:0, y:0};
        let scale = 1;
        let generatedGCode = null;
        let generatedThr = null;

        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_URL = window.location.origin;

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('pointerdown', startDraw);
            canvas.addEventListener('pointermove', moveDraw);
            canvas.addEventListener('pointerup', endDraw);
            canvas.addEventListener('pointerleave', endDraw);
            canvas.style.touchAction = "none";
            
            updateUI();
        }

        // --- DRAWING LOGIC ---
        function startDraw(e) {
            e.preventDefault();
            const smart = document.getElementById('smartPenMode').checked;
            if(smart) {
                if(e.pointerType === 'pen') setTool('draw');
                else if(e.pointerType === 'touch') setTool('erase');
            }
            saveState();
            isDrawing = true;
            canvas.setPointerCapture(e.pointerId);
            processPointer(e);
            resetStatus();
        }

        function moveDraw(e) {
            e.preventDefault();
            const pos = getPos(e);
            document.getElementById('coordDisplay').textContent = `X:${pos.x.toFixed(0)} Y:${pos.y.toFixed(0)}`;
            if(!isDrawing) { render(); drawCursor(pos); return; }
            processPointer(e);
        }

        function endDraw(e) {
            if(!isDrawing) return;
            isDrawing = false;
            if(currentTool === 'draw') rawPoints.push({type:'break'});
            canvas.releasePointerCapture(e.pointerId);
            render();
        }

        function getPos(e) {
            return {
                x: (e.offsetX - origin.x) / scale,
                y: -(e.offsetY - origin.y) / scale
            };
        }

        function processPointer(e) {
            const p = getPos(e);
            if(currentTool === 'draw') {
                rawPoints.push({x: p.x, y: p.y, type: 'point'});
            } else {
                const r = 10;
                rawPoints = rawPoints.filter(pt => {
                    if(pt.type === 'break') return true;
                    return Math.hypot(pt.x - p.x, pt.y - p.y) > r;
                });
            }
            render();
            if(currentTool==='erase') drawCursor(p);
        }

        function drawCursor(p) {
            if(currentTool !== 'erase') return;
            const r = 10 * scale;
            const px = origin.x + p.x * scale;
            const py = origin.y - p.y * scale;
            ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2);
            ctx.strokeStyle = "#999"; ctx.fillStyle = "rgba(200,200,200,0.3)";
            ctx.stroke(); ctx.fill();
        }

        function resetStatus() {
            generatedGCode = null;
            generatedThr = null;
            processedPoints = [];
            document.getElementById('statusTxt').innerText = "Drawing Mode";
            document.getElementById('statusTxt').style.color = "orange";
            document.getElementById('progressSlider').value = 100;
        }

        // --- RENDERER ---
        function render() {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            ctx.clearRect(0, 0, w, h);
            
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const sym = parseInt(document.getElementById('symSlider').value);
            const dark = document.body.getAttribute('data-theme') === 'dark';
            const prog = parseInt(document.getElementById('progressSlider').value);
            document.getElementById('progVal').textContent = prog + '%';

            ctx.save();
            ctx.translate(origin.x, origin.y);

            // Table Circle
            ctx.beginPath(); ctx.arc(0, 0, tableR*scale, 0, Math.PI*2);
            ctx.strokeStyle = dark ? '#444' : '#ddd'; ctx.lineWidth = 2; ctx.stroke();

            const showingFinal = (processedPoints.length > 0);
            const dataToShow = showingFinal ? processedPoints : rawPoints;
            const limit = Math.floor(dataToShow.length * (prog/100));
            const color = showingFinal ? '#ff0000' : (dark ? 'cyan' : '#007bff');

            ctx.lineWidth = 1.5;
            
            const loopCount = showingFinal ? 1 : sym;

            for(let s=0; s<loopCount; s++) {
                const ang = s * (Math.PI*2/sym);
                ctx.save(); 
                if(!showingFinal) ctx.rotate(ang); 
                
                ctx.beginPath();
                ctx.strokeStyle = color;
                
                let isMove = true;
                for(let i=0; i<limit; i++) {
                    const p = dataToShow[i];
                    if(p.type === 'break' || p.type === 'exit') { isMove = true; continue; }
                    
                    const px = p.x * scale;
                    const py = -p.y * scale;
                    
                    if(isMove) { ctx.moveTo(px, py); isMove = false; }
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                
                if(limit > 0 && limit < dataToShow.length) {
                    const tip = dataToShow[limit];
                    if(tip.type !== 'break' && tip.type !== 'exit') {
                        ctx.beginPath(); 
                        ctx.arc(tip.x*scale, -tip.y*scale, 4, 0, Math.PI*2);
                        ctx.fillStyle = color; ctx.fill();
                    }
                }
                ctx.restore();
            }
            ctx.restore();
        }

        // --- AI TRACER (High Contrast) ---
        function handleImageUpload(input) {
            const file = input.files[0];
            if(!file) return;
            showToast("Scanning & Enhancing...", "info");
            saveState();

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const tCan = document.createElement('canvas');
                    const MAX = 1000;
                    let tw = img.width, th = img.height;
                    if(tw>th && tw>MAX){ th*=MAX/tw; tw=MAX; } 
                    else if(th>MAX){ tw*=MAX/th; th=MAX; }
                    
                    tCan.width = tw; tCan.height = th;
                    const tCtx = tCan.getContext('2d');
                    
                    tCtx.fillStyle = "white"; tCtx.fillRect(0,0,tw,th);
                    tCtx.drawImage(img, 0, 0, tw, th);
                    
                    const imgData = tCtx.getImageData(0,0,tw,th);
                    const d = imgData.data;
                    for (let i=0; i<d.length; i+=4) {
                        const r=d[i], g=d[i+1], b=d[i+2];
                        const v = 0.2126*r + 0.7152*g + 0.0722*b;
                        const val = (v > 128) ? 255 : 0;
                        d[i] = d[i+1] = d[i+2] = val;
                    }
                    tCtx.putImageData(imgData, 0, 0);
                    
                    ImageTracer.imageToSVG(tCan.toDataURL(), function(svgStr){
                        processTrace(svgStr, tw, th);
                    }, { ltres:0.1, qtres:0.1, pathomit:5, colorsampling:0, numberofcolors:2, mincolorratio:0.02 });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processTrace(svgStr, imgW, imgH) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgStr, "image/svg+xml");
            const paths = doc.getElementsByTagName("path");
            let strokes = [];
            const res = 2.0; 

            for(let i=0; i<paths.length; i++) {
                const p = paths[i];
                const len = p.getTotalLength();
                if(len < 5) continue; 
                
                let pts = [];
                let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;

                for(let d=0; d<=len; d+=res) {
                    const pt = p.getPointAtLength(d);
                    pts.push({x: pt.x, y: pt.y});
                    if(pt.x<minX) minX=pt.x; if(pt.x>maxX) maxX=pt.x;
                    if(pt.y<minY) minY=pt.y; if(pt.y>maxY) maxY=pt.y;
                }
                
                const w = maxX - minX;
                const h = maxY - minY;
                if (w > imgW * 0.98 || h > imgH * 0.98) continue; 
                strokes.push(pts);
            }

            if(strokes.length === 0) return showToast("No shapes found", "error");

            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            strokes.flat().forEach(p => {
                if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
            });
            
            const contentW = maxX - minX;
            const contentH = maxY - minY;
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const scaleFac = (tableR * 2 * 0.9) / Math.max(contentW, contentH);
            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;

            let normalizedStrokes = strokes.map(s => {
                return s.map(p => ({
                    x: (p.x - cx) * scaleFac,
                    y: -(p.y - cy) * scaleFac 
                })).filter(p => Math.hypot(p.x, p.y) < tableR);
            });

            rawPoints = [];
            normalizedStrokes.forEach(s => {
                rawPoints.push({type:'break'});
                s.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'}));
            });
            rawPoints.push({type:'break'});

            resetStatus();
            showToast("Trace Loaded (Click Prepare)", "info");
            render();
        }

        // --- SIMPLIFIED OPTIMIZER (v28 - Robust Logic) ---
        async function prepareGCode() {
            if(rawPoints.length === 0) return showToast("Draw something first!", "error");
            showToast("Calculating Optimized Path...", "info");

            await new Promise(r => setTimeout(r, 50));

            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const sym = parseInt(document.getElementById('symSlider').value);
            
            // --- STEP 1: PARSE SHAPES ---
            let shapes = [];
            let curShape = [];
            rawPoints.forEach(p => {
                if(p.type === 'break' || p.type === 'exit') {
                    if(curShape.length > 0) shapes.push(curShape);
                    curShape = [];
                } else {
                    curShape.push({x:p.x, y:p.y});
                }
            });
            if(curShape.length > 0) shapes.push(curShape);

            // --- STEP 2: SYMMETRY ---
            let pool = [];
            for(let s=0; s<sym; s++) {
                const ang = s * (Math.PI*2/sym);
                const c = Math.cos(ang), si = Math.sin(ang);
                shapes.forEach(sh => {
                    let newSh = sh.map(p => ({
                        x: p.x*c - p.y*si,
                        y: p.x*si + p.y*c
                    }));
                    pool.push(newSh);
                });
            }

            if(pool.length === 0) return;

            // --- STEP 3: METADATA & CLOSURE ---
            let shapeMeta = pool.map((s, idx) => {
                const dStartEnd = Math.hypot(s[0].x - s[s.length-1].x, s[0].y - s[s.length-1].y);
                const isClosed = dStartEnd < 15.0; // Moderate tolerance for loops
                if(isClosed) {
                    s[s.length-1] = {x: s[0].x, y: s[0].y}; // Force close
                }
                return { id: idx, points: s, isClosed: isClosed };
            });

            // --- STEP 4: GREEDY NEAREST NEIGHBOR ---
            // "Recalculate best starting/ending points to decrease travel lines"
            
            let unvisited = new Set(shapeMeta.map(m => m.id));
            let optimizedPath = [];
            let currentHead = {x: tableR, y: 0}; // Start at Rim
            
            // Start with shape closest to Rim
            let startId = -1, minD = Infinity;
            for(let m of shapeMeta) {
                 let d = distSq(currentHead, m.points[0]);
                 if(d < minD) { minD = d; startId = m.id; }
            }
            
            let currentMeta = shapeMeta[startId];
            unvisited.delete(startId);
            
            let currentPoints = [...currentMeta.points];
            // If closed loop, rotate so start is closest to Rim
            if(currentMeta.isClosed) currentPoints = rotateToClosest(currentPoints, currentHead);
            // If open line, flip if end is closer to Rim
            else if (distSq(currentHead, currentPoints[currentPoints.length-1]) < distSq(currentHead, currentPoints[0])) {
                currentPoints.reverse();
            }

            optimizedPath.push(currentPoints);
            currentHead = currentPoints[currentPoints.length-1];

            while(unvisited.size > 0) {
                let bestNextId = -1;
                let bestEntryMode = 'start'; 
                let bestLoopIdx = -1;
                let minJumpDist = Infinity;
                let bestBacktrackIdx = -1; // Index in CURRENT shape to backtrack to

                // Check every unvisited shape
                for(let id of unvisited) {
                    const cand = shapeMeta[id];

                    // Check connections from the TAIL of current shape
                    // We check every 5th point backwards up to 20% of shape length (Retrace Limit)
                    let retraceLimit = Math.floor(currentPoints.length * 0.8); // Stop at 80% mark (go back 20%)
                    if (retraceLimit < 0) retraceLimit = 0;

                    for(let i=currentPoints.length-1; i >= retraceLimit; i-=3) {
                        let exitPt = currentPoints[i];

                        if(cand.isClosed) {
                            // Loop: check all points
                            for(let k=0; k<cand.points.length; k+=4) {
                                let d = distSq(exitPt, cand.points[k]);
                                if(d < minJumpDist) {
                                    minJumpDist = d; bestNextId = id; bestEntryMode = 'loop_idx'; bestLoopIdx = k; bestBacktrackIdx = i;
                                }
                            }
                        } else {
                            // Line: check start/end
                            let dStart = distSq(exitPt, cand.points[0]);
                            if(dStart < minJumpDist) {
                                minJumpDist = dStart; bestNextId = id; bestEntryMode = 'start'; bestBacktrackIdx = i;
                            }
                            let dEnd = distSq(exitPt, cand.points[cand.points.length-1]);
                            if(dEnd < minJumpDist) {
                                minJumpDist = dEnd; bestNextId = id; bestEntryMode = 'end'; bestBacktrackIdx = i;
                            }
                        }
                    }
                }

                if(bestNextId !== -1) {
                    // 1. Perform Backtrack if optimal exit wasn't the last point
                    if(bestBacktrackIdx < currentPoints.length - 1) {
                        let backtrackSeg = [];
                        for(let k=currentPoints.length-2; k>=bestBacktrackIdx; k--) {
                            backtrackSeg.push(currentPoints[k]);
                        }
                        optimizedPath.push(backtrackSeg);
                    }

                    // 2. Add next shape
                    let nextMeta = shapeMeta[bestNextId];
                    let nextPoints = [...nextMeta.points];
                    
                    if(bestEntryMode === 'loop_idx') {
                        nextPoints = rotateArray(nextPoints, bestLoopIdx);
                    } else if(bestEntryMode === 'end') {
                        nextPoints.reverse();
                    }

                    optimizedPath.push(nextPoints);
                    currentPoints = nextPoints;
                    currentHead = currentPoints[currentPoints.length-1];
                    unvisited.delete(bestNextId);
                } else {
                    break; 
                }
            }

            // --- STEP 5: CONNECT & EXPORT ---
            processedPoints = [];
            
            // Rim Entry
            let startP = optimizedPath[0][0];
            let ang = Math.atan2(startP.y, startP.x);
            processedPoints.push({x: tableR*Math.cos(ang), y: tableR*Math.sin(ang), type:'point'});

            // Add all path segments
            for(let pts of optimizedPath) {
                pts.forEach(p => processedPoints.push({x:p.x, y:p.y, type:'point'}));
            }

            // Exit to Rim
            let lastP = processedPoints[processedPoints.length-1];
            let exAng = Math.atan2(lastP.y, lastP.x);
            processedPoints.push({x: tableR*Math.cos(exAng), y: tableR*Math.sin(exAng), type:'exit'});

            // Simplification
            processedPoints = simplifyPath(processedPoints, 0.5);

            generateKinematicsGCode(processedPoints);
            
            document.getElementById('statusTxt').innerText = "AI Path: Optimized";
            document.getElementById('statusTxt').style.color = "#2ecc71";
            document.getElementById('progressSlider').value = 0;
            render(); 
            showToast("Path Optimized!", "success");
        }

        // --- UTILS ---
        function distSq(p1, p2) { return (p1.x-p2.x)**2 + (p1.y-p2.y)**2; }

        function rotateToClosest(points, target) {
            let bestIdx = 0, minD = Infinity;
            for(let i=0; i<points.length; i+=3) {
                let d = distSq(points[i], target);
                if(d < minD) { minD = d; bestIdx = i; }
            }
            return rotateArray(points, bestIdx);
        }

        function rotateArray(arr, idx) {
            if(idx === 0) return [...arr];
            let p1 = arr.slice(idx);
            let p2 = arr.slice(0, idx);
            let n = p1.concat(p2);
            n.push({x:n[0].x, y:n[0].y});
            return n;
        }

        function simplifyPath(points, tolerance) {
            if(points.length < 3) return points;
            let newPts = [points[0]];
            let lastP = points[0];
            for(let i=1; i<points.length-1; i++) {
                let p = points[i];
                let dist = Math.hypot(p.x - lastP.x, p.y - lastP.y);
                if(dist > tolerance) {
                    newPts.push(p);
                    lastP = p;
                }
            }
            newPts.push(points[points.length-1]);
            return newPts;
        }

        // --- G-CODE GENERATION ---
        function generateKinematicsGCode(pathPoints) {
            const L1 = parseFloat(document.getElementById('cfgL1').value);
            const L2 = parseFloat(document.getElementById('cfgL2').value);
            const gearRatio = parseFloat(document.getElementById('cfgGearRatio').value);
            const stepsPerDeg = parseFloat(document.getElementById('cfgStepsPerDeg').value);
            const tableRadius = parseFloat(document.getElementById('cfgRadius').value);
            const centerDelay = parseFloat(document.getElementById('cfgCenterDelay').value);
            const perimDelay = parseFloat(document.getElementById('cfgPerimDelay').value);
            const res = parseFloat(document.getElementById('cfgResolution').value) || 1.0;

            const stepsPerRad = stepsPerDeg * (180 / Math.PI);

            let commands = [];
            let prevBase = 0;
            let prevElbow = 0;
            
            let fullPath = [{x:0, y:0}].concat(pathPoints); 

            for (let i = 0; i < fullPath.length - 1; i++) {
                let p1 = fullPath[i];
                let p2 = fullPath[i+1];
                
                if (p2.type === 'exit') commands.push("M0"); 

                let dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                let steps = Math.ceil(dist / res);
                steps = Math.max(1, steps);

                for (let j = 1; j <= steps; j++) {
                    let t = j / steps;
                    let x = p1.x + (p2.x - p1.x) * t;
                    let y = p1.y + (p2.y - p1.y) * t;

                    let ik = calculateIK(x, y, prevBase, prevElbow, L1, L2, gearRatio, stepsPerRad);
                    
                    let dBase = Math.round(ik.base_steps - prevBase);
                    let dElbow = Math.round(ik.elbow_steps - prevElbow);

                    if (dBase !== 0 || dElbow !== 0) {
                        let distFromCenter = Math.hypot(x, y);
                        let rFactor = distFromCenter / tableRadius;
                        if (rFactor > 1.0) rFactor = 1.0;
                        
                        let calculatedDelay = centerDelay + ((perimDelay - centerDelay) * rFactor);
                        calculatedDelay = Math.round(calculatedDelay);

                        commands.push(`G1 ${dElbow} ${dBase} ${calculatedDelay}`);

                        prevBase += dBase;
                        prevElbow += dElbow;
                    }
                }
            }

            generatedGCode = commands.join('\n');
            
            // --- THETA-RHO GENERATION ---
            let thrLines = [];
            thrLines.push("# format: thetarho"); 
            
            let prevTheta = 0;
            let cumulativeTheta = 0;
            let isFirst = true;

            for(let p of pathPoints) {
                if(p.type !== 'exit') {
                    let rho = Math.hypot(p.x, p.y) / tableRadius;
                    if(rho > 1.0) rho = 1.0; 
                    let rawTheta = Math.atan2(p.y, p.x);
                    
                    if(isFirst) {
                        cumulativeTheta = rawTheta;
                        prevTheta = rawTheta;
                        isFirst = false;
                    } else {
                        let diff = rawTheta - prevTheta;
                        while (diff <= -Math.PI) diff += 2 * Math.PI;
                        while (diff > Math.PI) diff -= 2 * Math.PI;
                        cumulativeTheta += diff;
                        prevTheta = rawTheta;
                    }
                    
                    thrLines.push(`${cumulativeTheta.toFixed(5)} ${rho.toFixed(5)}`);
                }
            }
            generatedThr = thrLines.join('\n');
        }

        // --- KINEMATICS ENGINE ---
        
        function getShortestRotation(raw, last) {
            let diff = (raw - last) / (2 * Math.PI);
            let offset = Math.round(diff);
            return raw - (offset * 2 * Math.PI);
        }

        function calculateIK(x, y, lastBaseSteps, lastElbowSteps, L1, L2, gearRatio, stepsPerRad) {
            let dist = Math.hypot(x, y);
            const maxReach = L1 + L2;
            
            if (dist > maxReach) {
                x = (x / dist) * maxReach;
                y = (y / dist) * maxReach;
                dist = maxReach;
            }

            if (dist < 1.0) { 
                const targetBaseSteps = lastBaseSteps; 
                const currentBaseAngle = -lastBaseSteps / stepsPerRad;
                const targetElbowSteps = -(Math.PI + gearRatio * currentBaseAngle) * stepsPerRad;
                return { base_steps: targetBaseSteps, elbow_steps: targetElbowSteps };
            }

            const lastT1 = -lastBaseSteps / stepsPerRad; 
            let cosBend = (dist*dist - L1*L1 - L2*L2) / (2 * L1 * L2);
            cosBend = Math.max(-1, Math.min(1, cosBend));
            
            const bend1 = Math.acos(cosBend);
            const bend2 = -Math.acos(cosBend);

            const k1_1 = L1 + L2 * Math.cos(bend1);
            const k2_1 = L2 * Math.sin(bend1);
            let t1_1 = Math.atan2(y, x) - Math.atan2(k2_1, k1_1);
            t1_1 = getShortestRotation(t1_1, lastT1);

            const k1_2 = L1 + L2 * Math.cos(bend2);
            const k2_2 = L2 * Math.sin(bend2);
            let t1_2 = Math.atan2(y, x) - Math.atan2(k2_2, k1_2);
            t1_2 = getShortestRotation(t1_2, lastT1);

            const b1_steps = -t1_1 * stepsPerRad;
            const e1_steps = -(bend1 + gearRatio * t1_1) * stepsPerRad;
            const b2_steps = -t1_2 * stepsPerRad;
            const e2_steps = -(bend2 + gearRatio * t1_2) * stepsPerRad;

            const cost1 = Math.abs(b1_steps - lastBaseSteps) + Math.abs(e1_steps - lastElbowSteps);
            const cost2 = Math.abs(b2_steps - lastBaseSteps) + Math.abs(e2_steps - lastElbowSteps);

            return (cost1 <= cost2) ? { base_steps: b1_steps, elbow_steps: e1_steps } 
                                    : { base_steps: b2_steps, elbow_steps: e2_steps };
        }

        // --- ACTIONS ---
        async function sendToTable() {
            if(!generatedGCode) return showToast("Click 'Prepare Path' first!", "error");
            
            let finalCode = generatedGCode;
            const autoClear = document.getElementById('autoClearMode').checked;

            if(autoClear) {
                showToast("Fetching Clear Pattern...", "info");
                try {
                    let response = await fetch('./designs/clear.TXT');
                    if(!response.ok) response = await fetch('./designs/clear.txt'); 
                    
                    if(response.ok) {
                        const clearCode = await response.text();
                        finalCode = clearCode + "\n" + finalCode;
                        showToast("Auto-Clear Added.", "success");
                    } else {
                        showToast("Clear file not found!", "error");
                    }
                } catch(e) {
                    console.error(e);
                    showToast("Clear file error (check console)", "error");
                }
            }

            showToast("Sending...", "info");
            fetch(BASE_URL + '/send_gcode_block', {
                method:'POST', headers:{'Content-Type':'application/json'},
                body: JSON.stringify({gcode: finalCode, speed_override: null})
            }).then(r=>r.json()).then(d=>{
                if(d.success) showToast("Sent Successfully!", "success");
                else showToast("Error: " + d.error, "error");
            }).catch(()=>showToast("Network Error", "error"));
        }

        async function saveToServer() {
            if(!generatedGCode) return showToast("Click 'Prepare Path' first!", "error");
            let filename = prompt("Name your design:", "pattern");
            if(!filename) return;
            showToast("Saving to server...", "info");
            try {
                const response = await fetch(BASE_URL + '/save_design', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: filename, gcode: generatedGCode })
                });
                const data = await response.json();
                if(data.success) showToast("Saved to Designs!", "success");
                else showToast("Server Error: " + (data.error || "Unknown"), "error");
            } catch (e) {
                console.error(e);
                showToast("Network/Server Error", "error");
            }
        }
        
        function downloadThetaRho() {
            if(!generatedThr) return showToast("Click 'Prepare Path' first!", "error");
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(generatedThr).then(() => {
                    showToast("Copied Theta-Rho to Clipboard!", "success");
                }).catch(() => fallbackCopyTextToClipboard(generatedThr));
            } else {
                fallbackCopyTextToClipboard(generatedThr);
            }
        }

        function fallbackCopyTextToClipboard(text) {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.top = "0"; textArea.style.left = "0"; textArea.style.position = "fixed"; textArea.style.opacity = "0";
            document.body.appendChild(textArea);
            textArea.focus(); textArea.select();
            try {
                var successful = document.execCommand('copy');
                if(successful) showToast("Copied (Fallback Method)!", "success");
                else showToast("Copy failed, downloading...", "error");
            } catch (err) {
                const blob = new Blob([text], {type:'text/plain'});
                const a = document.createElement('a');
                a.download = 'pattern.thr'; a.href = URL.createObjectURL(blob); a.click();
            }
            document.body.removeChild(textArea);
        }

        // --- UTILS ---
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const size = container.getBoundingClientRect().width;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            ctx.scale(dpr, dpr);
            origin = { x: size/2, y: size/2 };
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            scale = (size/2) / (tableR * 1.1); 
            render();
        }
        function saveState() {
            if(historyStack.length>10) historyStack.shift();
            historyStack.push(JSON.stringify(rawPoints));
        }
        function undo() {
            if(historyStack.length===0) return;
            rawPoints = JSON.parse(historyStack.pop());
            resetStatus();
            render();
        }
        function clearCanvas() {
            saveState();
            rawPoints = [];
            resetStatus();
            render();
        }
        function setTool(t) {
            currentTool = t;
            document.getElementById('btnDraw').className = t==='draw'?'active':'secondary';
            document.getElementById('btnErase').className = t==='erase'?'active':'secondary';
        }
        function updateUI() {
            document.getElementById('symVal').textContent = document.getElementById('symSlider').value + 'x';
            render();
        }
        function showToast(msg, type) {
            const t = document.getElementById('status-toast');
            t.textContent = msg; t.className = type; t.style.opacity = 1;
            setTimeout(()=>t.style.opacity=0, 3000);
        }
        function openNav() { document.getElementById("mySidebar").style.width = "250px"; }
        function closeNav() { document.getElementById("mySidebar").style.width = "0"; }
        function toggleTheme() {
            const b = document.body;
            b.setAttribute('data-theme', b.getAttribute('data-theme')==='dark'?'light':'dark');
            render();
        }

        init();
    </script>
</body>
</html>
