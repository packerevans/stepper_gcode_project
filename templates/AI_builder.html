<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Sandify (Theta-Rho Output)</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

    <style>
        :root {
            --primary: #d2b48c; 
            --secondary: #b08d5c; 
            --bg: #f4f4f4; 
            --panel: #ffffff; 
            --text: #333;
            --accent: #2ecc71;
            --danger: #e74c3c;
            --btn-text: #fff;
        }
        body[data-theme='dark'] {
            --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --btn-text: #000;
        }

        body {
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: var(--bg); color: var(--text);
            margin: 0; padding: 0; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
        }

        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--panel);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100;
        }
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background-color: var(--primary); overflow-x: hidden;
            transition: 0.3s; padding-top: 60px; z-index: 2000;
            box-shadow: 4px 0 10px rgba(0,0,0,0.3);
        }
        .sidebar a {
            padding: 15px 24px; text-decoration: none; font-size: 18px;
            color: #fff; display: block; font-weight: 500;
        }

        .app-container {
            display: flex; flex-direction: column; height: 100%; width: 100%;
            padding: 10px; box-sizing: border-box; gap: 10px; overflow-y: auto;
        }
        @media (min-width: 768px) {
            .app-container { flex-direction: row; overflow: hidden; }
            .drawing-panel { flex: 2; border-radius: 16px; background: var(--panel); position: relative; }
            .controls-panel { flex: 1; max-width: 400px; border-radius: 16px; background: var(--panel); padding: 20px; overflow-y: auto; }
        }
        @media (max-width: 767px) {
            .drawing-panel { width: 100%; aspect-ratio: 1/1; border-radius: 16px; background: var(--panel); flex-shrink: 0; }
            .controls-panel { flex: 1; border-radius: 16px; background: var(--panel); padding: 15px; }
        }

        .canvas-wrapper {
            position: relative; width: 95%; height: 95%; margin: auto;
            aspect-ratio: 1/1; border-radius: 50%;
            border: 4px solid var(--primary); background: #fff;
            touch-action: none; cursor: crosshair; overflow: hidden;
            top: 50%; transform: translateY(-50%);
        }
        body[data-theme='dark'] .canvas-wrapper { background: #222; border-color: var(--secondary); }
        canvas { display: block; width: 100%; height: 100%; border-radius: 50%; }

        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: var(--secondary); text-align: center; }
        .btn-group { display: flex; gap: 8px; margin-bottom: 12px; }
        button {
            background: var(--primary); color: var(--btn-text); border: none;
            padding: 12px; border-radius: 8px; font-weight: 600; cursor: pointer;
            flex: 1; transition: 0.2s; display: flex; align-items: center; justify-content: center;
        }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        button.secondary { background: transparent; border: 1px solid var(--text); color: var(--text); }
        button.active { background: var(--secondary); border: 2px solid var(--text); }
        button.action { background: var(--accent); color: #000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .slider-row { margin-bottom: 15px; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; font-weight: bold; }
        input[type="range"] { width: 100%; accent-color: var(--secondary); }
        
        #progressSlider {
            -webkit-appearance: none; width: 100%; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none;
        }
        #progressSlider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--secondary); cursor: pointer;
        }

        details { background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; }
        summary { cursor: pointer; font-weight: bold; font-size: 13px; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        input[type="number"] { width: 100%; padding: 5px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; font-family: monospace;}

        #status-toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 3000;
        }
        .success { background: var(--accent) !important; color: #000 !important; }
        .error { background: var(--danger) !important; color: #fff !important; }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 0 5px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-tog { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-tog:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-tog { background-color: var(--secondary); }
        input:checked + .slider-tog:before { transform: translateX(18px); }

    </style>
</head>
<body data-theme="light">

    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Designs</a> 
        <a href="/controls">Drawing</a>
        <a href="/led_controls">LED Controls</a>
        <a href="/ai_builder">AI Builder</a>
        <a href="/terminal">Terminal</a>
    </div>

    <div class="nav-bar">
        <button style="flex:0; background:none; font-size:24px; color:var(--text); padding:0;" onclick="openNav()">‚ò∞</button>
        <h1 style="margin:0; font-size:1.2rem;">AI to Theta-Rho</h1>
        <button style="flex:0; background:none; font-size:20px;" onclick="toggleTheme()">‚òÄÔ∏è</button>
    </div>

    <div class="app-container">
        
        <div class="drawing-panel">
            <div class="canvas-wrapper" id="canvasContainer">
                <canvas id="drawCanvas"></canvas>
            </div>
            <div id="coordDisplay" style="position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none;">X:0 Y:0</div>
        </div>

        <div class="controls-panel">
            <h2>Tools</h2>
            
            <div class="toggle-row">
                <span style="font-weight:600; font-size:13px;">üñãÔ∏è Smart Pen Mode</span>
                <label class="switch">
                    <input type="checkbox" id="smartPenMode" checked>
                    <span class="slider-tog"></span>
                </label>
            </div>

            <div class="btn-group">
                <button id="btnDraw" onclick="setTool('draw')" class="active">‚úèÔ∏è Draw</button>
                <button id="btnErase" onclick="setTool('erase')" class="secondary">üßº Erase</button>
            </div>

            <div class="btn-group">
                <input type="file" id="imgUpload" accept="image/*" style="display:none" onchange="handleImageUpload(this)">
                <button class="secondary" onclick="document.getElementById('imgUpload').click()">‚ú® Trace Image</button>
            </div>

            <div class="btn-group">
                <button onclick="undo()" class="secondary">‚Ü∂ Undo</button>
                <button onclick="clearCanvas()" class="secondary" style="color:var(--danger); border-color:var(--danger);">‚úñ Clear</button>
            </div>

            <hr style="border:0; border-top:1px solid #ddd; margin: 15px 0;">
            
             <div class="slider-row">
                <div class="slider-header"><span>SYMMETRY</span> <span id="symVal">1x</span></div>
                <input type="range" id="symSlider" min="1" max="12" value="1" step="1" oninput="updateUI()">
            </div>

            <div class="slider-row">
                <div class="slider-header"><span>PREVIEW</span> <span id="progVal">100%</span></div>
                <input type="range" id="progressSlider" min="0" max="100" value="100" oninput="render()">
            </div>

            <button class="action" onclick="prepareGCode()" style="margin-bottom:15px; font-size:1.1em;">‚öôÔ∏è Prepare .thr File</button>

            <div style="text-align:center; font-size:12px; margin-bottom:10px; color:#666;">
                Status: <span id="statusTxt" style="font-weight:bold; color:var(--primary);">Drawing Mode</span>
            </div>

            <div class="btn-group">
                <button onclick="downloadGcode()" class="active">üíæ Download .thr</button>
            </div>
            <p style="font-size:11px; color:#666; text-align:center; margin-top:5px;">
                Use the downloaded file in <b>Sand Table Controller v17</b>
            </p>

            <details>
                <summary>‚öôÔ∏è Table Settings</summary>
                <div class="settings-grid">
                    <div><label>Radius (mm)</label><input type="number" id="cfgRadius" value="202.6" onchange="resizeCanvas()"></div>
                    <div><label>Interpolation</label><input type="number" id="cfgResolution" value="1.0"></div>
                </div>
            </details>
        </div>
    </div>

    <div id="status-toast"></div>

    <script>
        let rawPoints = []; 
        let processedPoints = []; 
        let historyStack = [];
        let isDrawing = false;
        let currentTool = 'draw';
        let origin = {x:0, y:0};
        let scale = 1;
        let generatedThr = null;

        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('pointerdown', startDraw);
            canvas.addEventListener('pointermove', moveDraw);
            canvas.addEventListener('pointerup', endDraw);
            canvas.addEventListener('pointerleave', endDraw);
            canvas.style.touchAction = "none";
            
            updateUI();
        }

        // --- DRAWING LOGIC ---
        function startDraw(e) {
            e.preventDefault();
            const smart = document.getElementById('smartPenMode').checked;
            if(smart) {
                if(e.pointerType === 'pen') setTool('draw');
                else if(e.pointerType === 'touch') setTool('erase');
            }
            saveState();
            isDrawing = true;
            canvas.setPointerCapture(e.pointerId);
            processPointer(e);
            resetStatus();
        }

        function moveDraw(e) {
            e.preventDefault();
            const pos = getPos(e);
            document.getElementById('coordDisplay').textContent = `X:${pos.x.toFixed(0)} Y:${pos.y.toFixed(0)}`;
            if(!isDrawing) { render(); drawCursor(pos); return; }
            processPointer(e);
        }

        function endDraw(e) {
            if(!isDrawing) return;
            isDrawing = false;
            if(currentTool === 'draw') rawPoints.push({type:'break'});
            canvas.releasePointerCapture(e.pointerId);
            render();
        }

        function getPos(e) {
            return {
                x: (e.offsetX - origin.x) / scale,
                y: -(e.offsetY - origin.y) / scale
            };
        }

        function processPointer(e) {
            const p = getPos(e);
            if(currentTool === 'draw') {
                rawPoints.push({x: p.x, y: p.y, type: 'point'});
            } else {
                const r = 10;
                rawPoints = rawPoints.filter(pt => {
                    if(pt.type === 'break') return true;
                    return Math.hypot(pt.x - p.x, pt.y - p.y) > r;
                });
            }
            render();
            if(currentTool==='erase') drawCursor(p);
        }

        function drawCursor(p) {
            if(currentTool !== 'erase') return;
            const r = 10 * scale;
            const px = origin.x + p.x * scale;
            const py = origin.y - p.y * scale;
            ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2);
            ctx.strokeStyle = "#999"; ctx.fillStyle = "rgba(200,200,200,0.3)";
            ctx.stroke(); ctx.fill();
        }

        function resetStatus() {
            generatedThr = null;
            processedPoints = [];
            document.getElementById('statusTxt').innerText = "Drawing Mode";
            document.getElementById('statusTxt').style.color = "orange";
            document.getElementById('progressSlider').value = 100;
        }

        // --- RENDERER ---
        function render() {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            ctx.clearRect(0, 0, w, h);
            
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const sym = parseInt(document.getElementById('symSlider').value);
            const dark = document.body.getAttribute('data-theme') === 'dark';
            const prog = parseInt(document.getElementById('progressSlider').value);
            document.getElementById('progVal').textContent = prog + '%';

            ctx.save();
            ctx.translate(origin.x, origin.y);

            // Table Circle
            ctx.beginPath(); ctx.arc(0, 0, tableR*scale, 0, Math.PI*2);
            ctx.strokeStyle = dark ? '#444' : '#ddd'; ctx.lineWidth = 2; ctx.stroke();

            const showingFinal = (processedPoints.length > 0);
            const dataToShow = showingFinal ? processedPoints : rawPoints;
            const limit = Math.floor(dataToShow.length * (prog/100));
            const color = showingFinal ? '#ff0000' : (dark ? 'cyan' : '#007bff');

            ctx.lineWidth = 1.5;
            
            const loopCount = showingFinal ? 1 : sym;

            for(let s=0; s<loopCount; s++) {
                const ang = s * (Math.PI*2/sym);
                ctx.save(); 
                if(!showingFinal) ctx.rotate(ang); 
                
                ctx.beginPath();
                ctx.strokeStyle = color;
                
                let isMove = true;
                for(let i=0; i<limit; i++) {
                    const p = dataToShow[i];
                    if(p.type === 'break' || p.type === 'exit') { isMove = true; continue; }
                    
                    const px = p.x * scale;
                    const py = -p.y * scale;
                    
                    if(isMove) { ctx.moveTo(px, py); isMove = false; }
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                
                if(limit > 0 && limit < dataToShow.length) {
                    const tip = dataToShow[limit];
                    if(tip.type !== 'break' && tip.type !== 'exit') {
                        ctx.beginPath(); 
                        ctx.arc(tip.x*scale, -tip.y*scale, 4, 0, Math.PI*2);
                        ctx.fillStyle = color; ctx.fill();
                    }
                }
                ctx.restore();
            }
            ctx.restore();
        }

        // --- AI TRACER ---
        function handleImageUpload(input) {
            const file = input.files[0];
            if(!file) return;
            showToast("Scanning...", "info");
            saveState();

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const tCan = document.createElement('canvas');
                    const MAX = 1000;
                    let tw = img.width, th = img.height;
                    if(tw>th && tw>MAX){ th*=MAX/tw; tw=MAX; } 
                    else if(th>MAX){ tw*=MAX/th; th=MAX; }
                    
                    tCan.width = tw; tCan.height = th;
                    const tCtx = tCan.getContext('2d');
                    tCtx.fillStyle = "white"; tCtx.fillRect(0,0,tw,th);
                    tCtx.filter = "grayscale(100%) contrast(150%)";
                    tCtx.drawImage(img, 0, 0, tw, th);
                    
                    ImageTracer.imageToSVG(tCan.toDataURL(), function(svgStr){
                        processTrace(svgStr, tw, th);
                    }, { ltres:0.5, qtres:0.5, pathomit:2, colorsampling:2, numberofcolors:2 });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processTrace(svgStr, imgW, imgH) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgStr, "image/svg+xml");
            const paths = doc.getElementsByTagName("path");
            let strokes = [];
            const res = 2.0; 

            for(let i=0; i<paths.length; i++) {
                const p = paths[i];
                const len = p.getTotalLength();
                if(len < 5) continue; 
                
                let pts = [];
                let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;

                for(let d=0; d<=len; d+=res) {
                    const pt = p.getPointAtLength(d);
                    pts.push({x: pt.x, y: pt.y});
                    if(pt.x<minX) minX=pt.x; if(pt.x>maxX) maxX=pt.x;
                    if(pt.y<minY) minY=pt.y; if(pt.y>maxY) maxY=pt.y;
                }
                
                const w = maxX - minX;
                const h = maxY - minY;
                if (w > imgW * 0.98 || h > imgH * 0.98) continue; 
                strokes.push(pts);
            }

            if(strokes.length === 0) return showToast("No shapes found", "error");

            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
            strokes.flat().forEach(p => {
                if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
            });
            
            const contentW = maxX - minX;
            const contentH = maxY - minY;
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const scaleFac = (tableR * 2 * 0.9) / Math.max(contentW, contentH);
            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;

            let normalizedStrokes = strokes.map(s => {
                return s.map(p => ({
                    x: (p.x - cx) * scaleFac,
                    y: -(p.y - cy) * scaleFac 
                })).filter(p => Math.hypot(p.x, p.y) < tableR);
            });

            rawPoints = [];
            normalizedStrokes.forEach(s => {
                rawPoints.push({type:'break'});
                s.forEach(p => rawPoints.push({x:p.x, y:p.y, type:'point'}));
            });
            rawPoints.push({type:'break'});

            resetStatus();
            showToast("Trace Loaded", "info");
            render();
        }

        // --- OPTIMIZER (XY PATHS) ---
        function prepareGCode() {
            if(rawPoints.length === 0) return showToast("Draw something first!", "error");
            showToast("Optimizing Path...", "info");

            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const sym = parseInt(document.getElementById('symSlider').value);
            
            // 1. Group raw points into shapes
            let shapes = [];
            let curShape = [];
            rawPoints.forEach(p => {
                if(p.type === 'break' || p.type === 'exit') {
                    if(curShape.length > 0) shapes.push(curShape);
                    curShape = [];
                } else {
                    curShape.push(p);
                }
            });
            if(curShape.length > 0) shapes.push(curShape);

            // 2. Symmetry
            let pool = [];
            for(let s=0; s<sym; s++) {
                const ang = s * (Math.PI*2/sym);
                const c = Math.cos(ang), si = Math.sin(ang);
                shapes.forEach(sh => {
                    let newSh = sh.map(p => ({
                        x: p.x*c - p.y*si,
                        y: p.x*si + p.y*c,
                        type: 'point'
                    }));
                    pool.push(newSh);
                });
            }

            // 3. Simple Optimization (Join Nearest)
            // Start at max distance from center to begin on outside
            let bestShapeIdx = -1, maxDist = -1;
            for (let i=0; i<pool.length; i++) {
                if (Math.hypot(pool[i][0].x, pool[i][0].y) > maxDist) {
                    maxDist = Math.hypot(pool[i][0].x, pool[i][0].y);
                    bestShapeIdx = i;
                }
            }
            if (bestShapeIdx === -1) bestShapeIdx = 0;

            let sortedShapes = [];
            let current = pool.splice(bestShapeIdx, 1)[0];
            sortedShapes.push(current);

            while(pool.length > 0) {
                let lastPt = current[current.length-1];
                let bestNextIdx = -1;
                let minDist = Infinity;
                let reverse = false;

                for(let i=0; i<pool.length; i++) {
                    let s = pool[i];
                    let dStart = Math.hypot(lastPt.x - s[0].x, lastPt.y - s[0].y);
                    let dEnd = Math.hypot(lastPt.x - s[s.length-1].x, lastPt.y - s[s.length-1].y);
                    
                    if(dStart < minDist) { minDist = dStart; bestNextIdx = i; reverse = false; }
                    if(dEnd < minDist) { minDist = dEnd; bestNextIdx = i; reverse = true; }
                }

                let nextShape = pool[bestNextIdx];
                if(reverse) nextShape.reverse();
                
                // Linear connection (add points between shapes)
                const res = parseFloat(document.getElementById('cfgResolution').value) || 1.0;
                let jumpDist = minDist;
                let steps = Math.ceil(jumpDist/res);
                for(let k=1; k<=steps; k++) {
                    let t = k/steps;
                    sortedShapes.push([{
                        x: lastPt.x + (nextShape[0].x - lastPt.x)*t,
                        y: lastPt.y + (nextShape[0].y - lastPt.y)*t,
                        type: 'point'
                    }]);
                }

                sortedShapes.push(nextShape);
                current = nextShape;
                pool.splice(bestNextIdx, 1);
            }

            // Flatten
            processedPoints = [];
            sortedShapes.forEach(s => s.forEach(p => processedPoints.push(p)));

            // 4. Generate Theta-Rho
            generatedThr = generateThetaRho(processedPoints);
            
            document.getElementById('statusTxt').innerText = "Theta-Rho Ready";
            document.getElementById('statusTxt').style.color = "green";
            render(); 
            showToast("Conversion Complete!", "success");
        }

        // --- CORE: THETA-RHO CONVERTER (SANDIFY STYLE) ---
        function generateThetaRho(points) {
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            let lines = ["# format: thetarho"]; // Header for script.html auto-detect
            
            let prevRawTheta = 0;
            let cumulativeTheta = 0;
            
            // Initialize with the first point's angle
            // This prevents the table from spinning wildly to get to the start
            if (points.length > 0) {
                const first = points[0];
                prevRawTheta = Math.atan2(first.y, first.x);
                cumulativeTheta = prevRawTheta;
            }

            for (let i = 0; i < points.length; i++) {
                let p = points[i];
                let x = p.x;
                let y = p.y;
                
                // Calculate Rho (Normalized 0 to 1)
                let r = Math.hypot(x, y);
                let rho = r / tableR;
                if (rho > 1.0) rho = 1.0; // Clamp to table edge
                
                // Calculate Theta (Continuous/Unwrapped)
                let rawTheta = Math.atan2(y, x);
                let delta = rawTheta - prevRawTheta;
                
                // Normalize delta to be the shortest path (-PI to +PI)
                while (delta <= -Math.PI) delta += 2 * Math.PI;
                while (delta > Math.PI) delta -= 2 * Math.PI;
                
                cumulativeTheta += delta;
                prevRawTheta = rawTheta;
                
                // Output format: angle(radians)  radius(0-1)
                lines.push(`${cumulativeTheta.toFixed(5)} ${rho.toFixed(5)}`);
            }
            
            return lines.join('\n');
        }

        // --- ACTIONS ---
        function downloadGcode() {
            if(!generatedThr) return showToast("Click 'Prepare' first!", "error");
            const blob = new Blob([generatedThr], {type:'text/plain'});
            const a = document.createElement('a');
            a.download = 'sandify_pattern.thr'; 
            a.href = URL.createObjectURL(blob); 
            a.click();
        }

        // --- UTILS ---
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const size = container.getBoundingClientRect().width;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            ctx.scale(dpr, dpr);
            origin = { x: size/2, y: size/2 };
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            scale = (size/2) / (tableR * 1.1); 
            render();
        }
        function saveState() {
            if(historyStack.length>10) historyStack.shift();
            historyStack.push(JSON.stringify(rawPoints));
        }
        function undo() {
            if(historyStack.length===0) return;
            rawPoints = JSON.parse(historyStack.pop());
            resetStatus();
            render();
        }
        function clearCanvas() {
            saveState();
            rawPoints = [];
            resetStatus();
            render();
        }
        function setTool(t) {
            currentTool = t;
            document.getElementById('btnDraw').className = t==='draw'?'active':'secondary';
            document.getElementById('btnErase').className = t==='erase'?'active':'secondary';
        }
        function updateUI() {
            document.getElementById('symVal').textContent = document.getElementById('symSlider').value + 'x';
            render();
        }
        function showToast(msg, type) {
            const t = document.getElementById('status-toast');
            t.textContent = msg; t.className = type; t.style.opacity = 1;
            setTimeout(()=>t.style.opacity=0, 3000);
        }
        function openNav() { document.getElementById("mySidebar").style.width = "250px"; }
        function closeNav() { document.getElementById("mySidebar").style.width = "0"; }
        function toggleTheme() {
            const b = document.body;
            b.setAttribute('data-theme', b.getAttribute('data-theme')==='dark'?'light':'dark');
            render();
        }

        init();
    </script>
</body>
</html>
