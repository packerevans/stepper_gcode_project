<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Packers Sand Table Control (Universal Tracer)</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

    <style>
        /* --- Root Variables --- */
        :root {
            --color-primary: #d2b48c; 
            --color-secondary: #b08d5c; 
            --color-background: #f0f0f0; 
            --color-surface: #ffffff; 
            --color-text: #333333;
            --color-shadow: rgba(0, 0, 0, 0.08);
            --border-radius: 16px;
            --color-input-bg: #f9f9f9;
            --color-input-border: #ccc;
            --color-danger: #ff6b6b;
            --color-success: #4caf50;
            --color-accent: #8e44ad;
        }

        body[data-theme='dark'] {
            --color-background: #121212;
            --color-surface: #1e1e1e;
            --color-text: #e0e0e0;
            --color-shadow: rgba(0, 0, 0, 0.3);
            --color-input-bg: #2c2c2c;
            --color-input-border: #444;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--color-background);
            color: var(--color-text);
            margin: 0; padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
            overscroll-behavior: none;
        }

        /* --- Navigation --- */
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background-color: var(--color-primary); overflow-x: hidden;
            transition: 0.3s; padding-top: 60px; z-index: 2000;
            box-shadow: 4px 0 10px var(--color-shadow);
        }
        .sidebar a {
            padding: 15px 24px; text-decoration: none; font-size: 18px;
            color: #fff; display: block; transition: 0.2s; font-weight: 500;
        }
        .sidebar a:hover { background-color: var(--color-secondary); }

        .nav-bar {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: var(--color-surface);
            box-shadow: 0 2px 5px var(--color-shadow); z-index: 100;
            flex-shrink: 0;
        }

        .menu-btn { font-size: 20px; cursor: pointer; background: none; border: none; color: var(--color-text); }
        .theme-btn { font-size: 20px; cursor: pointer; background: none; border: none; }

        /* --- Layout Grid --- */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            gap: 10px;
            overflow-y: auto;
        }

        @media (min-width: 768px), (orientation: landscape) {
            .app-container {
                flex-direction: row;
                align-items: stretch;
                overflow: hidden;
            }
            .drawing-panel {
                flex: 2;
                display: flex;
                justify-content: center;
                align-items: center;
                background: var(--color-surface);
                border-radius: var(--border-radius);
                box-shadow: 0 4px 10px var(--color-shadow);
                position: relative;
                overflow: hidden;
            }
            .controls-panel {
                flex: 1;
                min-width: 300px;
                max-width: 400px;
                background: var(--color-surface);
                border-radius: var(--border-radius);
                box-shadow: 0 4px 10px var(--color-shadow);
                padding: 20px;
                overflow-y: auto;
            }
        }

        @media (max-width: 767px) and (orientation: portrait) {
            .drawing-panel {
                width: 100%;
                aspect-ratio: 1/1;
                max-height: 50vh;
                background: var(--color-surface);
                border-radius: var(--border-radius);
                display: flex; justify-content: center; align-items: center;
                flex-shrink: 0;
            }
            .controls-panel {
                width: 100%;
                background: var(--color-surface);
                border-radius: var(--border-radius);
                padding: 15px;
                flex-grow: 1;
                padding-bottom: 80px; 
            }
        }

        /* --- Canvas Container --- */
        .canvas-wrapper {
            position: relative;
            width: 95%; 
            height: 95%;
            aspect-ratio: 1 / 1; 
            max-width: 90vmin; 
            max-height: 90vmin;
            border-radius: 50%;
            border: 4px solid var(--color-primary);
            background: #fff;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
            touch-action: none; 
            cursor: crosshair;
            margin: auto;
            overflow: hidden; 
        }
        body[data-theme='dark'] .canvas-wrapper {
            background: #222; 
            border-color: var(--color-secondary);
        }
        canvas { display: block; width: 100%; height: 100%; border-radius: 50%; }

        /* --- Controls UI --- */
        h2 { margin: 0 0 15px 0; font-size: 1.2rem; color: var(--color-secondary); text-align: center; }
        
        label { font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--color-text); display: block; margin-bottom: 4px;}

        .btn-group { display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; }
        
        button {
            background-color: var(--color-primary); color: white;
            border: none; padding: 10px 15px; border-radius: 8px; font-size: 14px;
            cursor: pointer; transition: 0.2s; font-weight: 600; flex-grow: 1;
            box-shadow: 0 2px 4px var(--color-shadow);
            display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        button:hover { background-color: var(--color-secondary); transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        
        button.secondary { background-color: transparent; border: 1px solid var(--color-text); color: var(--color-text); box-shadow: none; opacity: 0.7;}
        button.secondary:hover { opacity: 1; background: var(--color-input-bg); }
        
        button.active-tool { 
            background-color: var(--color-secondary); 
            border: 2px solid var(--color-secondary);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        button.ai-btn {
            background: linear-gradient(135deg, #8e44ad, #3498db);
            color: white; border: none;
        }
        button.ai-btn:hover { filter: brightness(1.1); }

        /* Toggle Switch */
        .toggle-row {
            display: flex; justify-content: space-between; align-items: center;
            background: var(--color-input-bg); padding: 8px 12px;
            border-radius: 8px; margin-bottom: 10px;
            font-size: 13px; font-weight: 600;
        }
        .switch { position: relative; display: inline-block; width: 40px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; transition: .4s; border-radius: 22px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--color-secondary); }
        input:checked + .slider:before { transform: translateX(18px); }

        /* Sliders */
        .slider-control { margin-bottom: 15px; }
        .slider-header { display: flex; justify-content: space-between; margin-bottom: 5px; }
        input[type="range"] { width: 100%; accent-color: var(--color-secondary); }
        
        #progressSlider {
            height: 8px; border-radius: 4px; background: #ddd; outline: none; -webkit-appearance: none;
        }
        #progressSlider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--color-secondary); cursor: pointer;
        }

        /* Info Stats */
        .stats-row {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;
            background: var(--color-input-bg); padding: 10px; border-radius: 8px;
        }
        .stat-item { text-align: center; }
        .stat-val { font-weight: bold; font-size: 14px; font-family: monospace; }

        /* Status Banner */
        #status-banner {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #333; color: white; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; z-index: 3000;
            pointer-events: none; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .status-success { background: #4caf50 !important; }
        .status-error { background: #ff4444 !important; }

        /* Details/Summary */
        details {
            background: var(--color-input-bg); padding: 10px; border-radius: 8px;
            margin-bottom: 10px; border: 1px solid var(--color-input-border);
        }
        summary { cursor: pointer; font-weight: 600; font-size: 13px; outline: none; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        input[type="number"] {
            width: 100%; padding: 6px; border-radius: 4px; border: 1px solid var(--color-input-border);
            background: var(--color-surface); color: var(--color-text); box-sizing: border-box;
        }
        
        #traceInput { display: none; }
        #insertModeNotice { display: none; background: var(--color-accent); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px; margin-bottom: 5px; }

    </style>
</head>
<body data-theme="light">

    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Designs</a> 
        <a href="/controls">Drawing</a>
        <a href="/led_controls">LED Controls</a>
        <a href="/ai_builder">AI Builder</a>
        <a href="/terminal">Terminal</a>
    </div>

    <div class="nav-bar">
        <button class="menu-btn" onclick="openNav()">‚ò∞</button>
        <h1 style="margin:0; font-size:1.2rem;">Sand Controller</h1>
        <button class="theme-btn" id="themeToggle" onclick="toggleTheme()">‚òÄÔ∏è</button>
    </div>

    <div class="app-container">
        
        <div class="drawing-panel">
            <div class="canvas-wrapper" id="canvasContainer">
                <canvas id="drawCanvas"></canvas>
            </div>
            <div id="coordDisplay" style="position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.5); color:white; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none;">X:0 Y:0</div>
        </div>

        <div class="controls-panel">
            <h2>Controls</h2>
            
            <div class="toggle-row" title="Pen Draws, Finger Erases">
                <span>üñãÔ∏è Smart Pen Mode</span>
                <label class="switch">
                    <input type="checkbox" id="smartPenMode" checked>
                    <span class="slider"></span>
                </label>
            </div>

            <div class="btn-group">
                <button id="drawToolBtn" onclick="setTool('draw')" class="active-tool">‚úèÔ∏è Draw</button>
                <button id="eraseToolBtn" onclick="setTool('erase')" class="secondary">üßº Eraser</button>
            </div>

            <div class="btn-group">
                <input type="file" id="traceInput" accept="image/*" onchange="handleImageUpload(this)">
                <button class="ai-btn" onclick="document.getElementById('traceInput').click()">‚ú® AI Vector Trace</button>
            </div>
            
            <div class="btn-group">
                <button onclick="undo()" class="secondary">‚Ü∂ Undo</button>
                <button onclick="clearCanvas()" class="secondary" style="color:var(--color-danger); border-color:var(--color-danger);">‚úñ Clear</button>
            </div>

            <div class="slider-control" style="background: var(--color-input-bg); padding: 10px; border-radius: 8px;">
                <div class="slider-header">
                    <label>Simulation Progress</label>
                    <span id="progressVal" style="font-size:12px;">100%</span>
                </div>
                <div id="insertModeNotice">‚ú® INSERT MODE: Inserting at closest Break</div>
                <input type="range" id="progressSlider" min="0" max="100" value="100" oninput="updateSimulationView()">
            </div>

            <div class="slider-control">
                <div class="slider-header"><label>Smoothing</label><span id="smoothVal">2mm</span></div>
                <input type="range" id="smoothSlider" min="1" max="10" value="2" oninput="updateUI(); generateCode();">
            </div>

            <div class="slider-control">
                <div class="slider-header"><label>Symmetry</label><span id="symVal">1x</span></div>
                <input type="range" id="symSlider" min="1" max="12" value="1" step="1" oninput="updateUI(); render(); generateCode();">
            </div>

            <div class="stats-row">
                <div class="stat-item"><label>Est. Time</label><div class="stat-val" id="timeEstimate">0s</div></div>
                <div class="stat-item"><label>Points</label><div class="stat-val" id="pointCount">0</div></div>
            </div>

            <details>
                <summary>‚öôÔ∏è Machine Settings</summary>
                <div class="settings-grid">
                    <div><label>Radius (mm)</label><input type="number" id="cfgRadius" value="202.6" onchange="resizeCanvas(); generateCode();"></div>
                    
                    <div><label>Center Delay (us)</label><input type="number" id="cfgCenterDelay" value="500" onchange="generateCode()"></div>
                    <div><label>Perim Delay (us)</label><input type="number" id="cfgPerimDelay" value="3000" onchange="generateCode()"></div>
                    
                    <div><label>Arm 1</label><input type="number" id="cfgL1" value="101.3"></div>
                    <div><label>Arm 2</label><input type="number" id="cfgL2" value="101.3"></div>
                    <div><label>Gear Ratio</label><input type="number" id="cfgGear" value="1.125"></div>
                    <div><label>Min Delay</label><input type="number" id="cfgMinDelay" value="50"></div>
                </div>
            </details>

            <div style="margin-top:20px;">
                <div class="btn-group">
                    <button onclick="sendToTable()" style="background-color: var(--color-success);">üöÄ Run</button>
                    <button onclick="downloadGcode()" class="secondary">üíæ Save</button>
                    <button onclick="copyToClipboard()" class="secondary">üìã Copy</button>
                </div>
            </div>

            <textarea id="stepsOutput" style="position:absolute; left:-9999px;"></textarea>
        </div>
    </div>

    <div id="status-banner"></div>

    <script>
        // --- STATE ---
        let isDrawing = false;
        let currentTool = 'draw';
        let rawPoints = []; 
        let historyStack = []; 
        
        let simulatedPath = [];  
        let generatedGCode = "";
        let origin = { x: 0, y: 0 };
        let scale = 1;
        
        // UI State
        let cursorPosition = { x: 0, y: 0, visible: false };
        
        // INSERT MODE VARS
        let simLimitIndex = -1; 
        let insertModeActive = false;
        let insertStrokeBuffer = []; 
        
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_URL = window.location.origin;
        
        const ERASER_RADIUS_MM = 3.75; 
        const PEN_OFFSET_X = 5; 
        const PEN_OFFSET_Y = 3; 

        // --- INIT ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('pointerdown', handlePointerDown);
            canvas.addEventListener('pointermove', handlePointerMove);
            canvas.addEventListener('pointerup', endInput);
            canvas.addEventListener('pointerleave', endInput);
            canvas.style.touchAction = "none";

            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.setAttribute('data-theme', savedTheme);
            document.getElementById('themeToggle').textContent = savedTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
            
            updateUI();
            render();
        }

        // --- HISTORY / UNDO ---
        function saveState() {
            if(historyStack.length > 20) historyStack.shift();
            historyStack.push(JSON.stringify(rawPoints));
        }

        function undo() {
            if(historyStack.length === 0) return;
            const state = historyStack.pop();
            rawPoints = JSON.parse(state);
            generateCode();
            render();
        }

        // --- POINTERS ---
        function handlePointerDown(e) {
            e.preventDefault();
            const isSmartMode = document.getElementById('smartPenMode').checked;
            
            if (isSmartMode) {
                if (e.pointerType === 'pen') setTool('draw');
                else if (e.pointerType === 'touch') setTool('erase');
            }

            saveState(); 
            isDrawing = true;
            canvas.setPointerCapture(e.pointerId);
            
            if(insertModeActive) insertStrokeBuffer = [];
            processInput(e);
        }

        function handlePointerMove(e) {
            e.preventDefault();
            const pos = getPointerPos(e);
            cursorPosition = { x: pos.px, y: pos.py, visible: true };
            
            if (!isDrawing) {
                render(); 
                return;
            }
            processInput(e);
        }

        function endInput(e) {
            if (!isDrawing) return;
            isDrawing = false;
            
            if(currentTool === 'draw') {
                if(insertModeActive && insertStrokeBuffer.length > 0) {
                    performInsertion();
                } else {
                    rawPoints.push({ type: 'break' });
                    generateCode(); 
                }
            } else {
                generateCode();
            }
            canvas.releasePointerCapture(e.pointerId);
        }

        function getPointerPos(e) {
            return { px: e.offsetX, py: e.offsetY };
        }

        function processInput(e) {
            const rawPx = e.offsetX;
            const rawPy = e.offsetY;
            
            const offsetPx = rawPx + PEN_OFFSET_X;
            const offsetPy = rawPy + PEN_OFFSET_Y;
            
            const mx = (offsetPx - origin.x) / scale;
            const my = -(offsetPy - origin.y) / scale; 
            
            document.getElementById('coordDisplay').textContent = `X:${mx.toFixed(0)} Y:${my.toFixed(0)}`;
            
            if (currentTool === 'draw') {
                if(insertModeActive) insertStrokeBuffer.push({x:mx, y:my, type:'point'});
                else rawPoints.push({ x: mx, y: my, type: 'point' });
            } else {
                eraseAt(mx, my);
            }
            render();
        }

        // --- SMART INSERT LOGIC ---
        function findInsertionIndex() {
            if(simulatedPath.length === 0) return rawPoints.length;
            
            let limit = simLimitIndex >= 0 ? simLimitIndex : simulatedPath.length - 1;
            if(limit > simulatedPath.length-1) limit = simulatedPath.length-1;
            const simTip = simulatedPath[limit];

            let closestIdx = rawPoints.length;
            let minDist = Infinity;

            if(rawPoints.length > 0) {
                let startD = Math.hypot(rawPoints[0].x - simTip.x, rawPoints[0].y - simTip.y);
                if(startD < minDist) { minDist = startD; closestIdx = 0; }

                for(let i=0; i<rawPoints.length; i++) {
                    if(rawPoints[i].type === 'break') {
                        if(i > 0 && rawPoints[i-1].type !== 'break') {
                            let d = Math.hypot(rawPoints[i-1].x - simTip.x, rawPoints[i-1].y - simTip.y);
                            if(d < minDist) { minDist = d; closestIdx = i; } 
                        }
                    }
                }
            }
            return closestIdx;
        }

        function performInsertion() {
            let idx = findInsertionIndex();
            let toAdd = [];
            if(idx > 0 && rawPoints[idx-1].type !== 'break') toAdd.push({type:'break'});
            toAdd = toAdd.concat(insertStrokeBuffer);
            if(idx < rawPoints.length && rawPoints[idx].type !== 'break') toAdd.push({type:'break'});
            
            rawPoints.splice(idx, 0, ...toAdd);
            insertStrokeBuffer = [];

            document.getElementById('progressSlider').value = 100;
            updateSimulationView(); 
            generateCode();
            showToast("Inserted at closest break!", 'success');
        }

        // --- CANVAS ---
        function resizeCanvas() {
            const wrapper = document.getElementById('canvasContainer');
            const size = wrapper.getBoundingClientRect().width;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            ctx.scale(dpr, dpr);
            
            origin = { x: size/2, y: size/2 }; 
            const tableR = parseFloat(document.getElementById('cfgRadius').value) || 202.6;
            scale = (size / 2) / (tableR * 1.05); 
            render();
        }

        function render() {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);
            ctx.clearRect(0, 0, width, height);
            
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const symCount = parseInt(document.getElementById('symSlider').value);
            const isDark = document.body.getAttribute('data-theme') === 'dark';

            ctx.save();
            ctx.translate(origin.x, origin.y);
            
            // Table
            ctx.beginPath(); ctx.arc(0, 0, tableR * scale, 0, Math.PI * 2);
            ctx.strokeStyle = isDark ? '#444' : '#ddd'; ctx.lineWidth = 2; ctx.stroke();
            
            // Input (Ghost)
            ctx.strokeStyle = isDark ? 'rgba(0, 255, 255, 0.3)' : 'rgba(0, 100, 255, 0.2)';
            ctx.lineWidth = 2;
            for(let s=0; s<symCount; s++) {
                const angle = s * (Math.PI * 2 / symCount);
                ctx.save(); ctx.rotate(angle);
                ctx.beginPath();
                let isMove = true;
                for(let p of rawPoints) {
                    if(p.type === 'break') { isMove = true; continue; }
                    const px = p.x * scale; const py = -p.y * scale;
                    if(isMove) { ctx.moveTo(px, py); isMove = false; }
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                
                if(insertStrokeBuffer.length > 0) {
                    ctx.beginPath(); ctx.strokeStyle = '#8e44ad'; ctx.lineWidth=3;
                    let isMoveB = true;
                    for(let p of insertStrokeBuffer) {
                        const px = p.x*scale; const py = -p.y*scale;
                        if(isMoveB){ctx.moveTo(px,py); isMoveB=false;} else ctx.lineTo(px,py);
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Simulation
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            
            if(simulatedPath.length > 0) {
                let limit = simLimitIndex >= 0 ? simLimitIndex : simulatedPath.length - 1;
                if(limit > simulatedPath.length-1) limit = simulatedPath.length-1;
                
                ctx.beginPath();
                ctx.moveTo(simulatedPath[0].x * scale, -simulatedPath[0].y * scale);
                for(let i=1; i<=limit; i++) {
                    ctx.lineTo(simulatedPath[i].x * scale, -simulatedPath[i].y * scale);
                }
                ctx.stroke();

                const end = simulatedPath[limit];
                ctx.fillStyle = insertModeActive ? '#8e44ad' : '#fff'; 
                ctx.strokeStyle = insertModeActive ? '#fff' : '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(end.x*scale, -end.y*scale, insertModeActive?6:4, 0, Math.PI*2);
                ctx.fill(); ctx.stroke();
            }

            ctx.restore();

            // Eraser Visual
            if(currentTool === 'erase' && cursorPosition.visible) {
                ctx.beginPath();
                ctx.arc(cursorPosition.x + PEN_OFFSET_X, cursorPosition.y + PEN_OFFSET_Y, ERASER_RADIUS_MM * scale, 0, Math.PI*2);
                ctx.fillStyle = "rgba(150, 150, 150, 0.4)";
                ctx.strokeStyle = "#888";
                ctx.lineWidth = 1;
                ctx.fill(); ctx.stroke();
            }

            document.getElementById('pointCount').textContent = rawPoints.length;
        }

        // --- SLIDER & TOOLS ---
        function updateSimulationView() {
            const pct = parseInt(document.getElementById('progressSlider').value);
            document.getElementById('progressVal').textContent = pct + '%';
            
            if(pct < 100) {
                simLimitIndex = Math.floor((pct / 100) * (simulatedPath.length - 1));
                insertModeActive = true;
                document.getElementById('insertModeNotice').style.display = 'block';
            } else {
                simLimitIndex = -1;
                insertModeActive = false;
                document.getElementById('insertModeNotice').style.display = 'none';
            }
            render();
        }

        function eraseAt(ex, ey) {
            const r = ERASER_RADIUS_MM; 
            rawPoints = rawPoints.filter(p => {
                if(p.type === 'break') return true;
                return Math.hypot(p.x - ex, p.y - ey) > r;
            });
            for(let i=rawPoints.length-1; i>0; i--) {
                if(rawPoints[i].type === 'break' && rawPoints[i-1].type === 'break') rawPoints.splice(i,1);
            }
        }

        function undoLastStroke() {
            if(rawPoints.length > 0 && rawPoints[rawPoints.length-1].type === 'break') rawPoints.pop();
            while(rawPoints.length > 0) {
                if(rawPoints[rawPoints.length-1].type === 'break') break;
                rawPoints.pop();
            }
            render(); generateCode();
        }

        function clearCanvas() {
            saveState();
            rawPoints = []; simulatedPath = []; generatedGCode = "";
            document.getElementById('timeEstimate').textContent = "0s";
            render();
        }

        // --- UPDATED AI VECTOR TRACER (FIXED FOR ALL IMAGES) ---
        function handleImageUpload(input) {
            const file = input.files[0];
            if(!file) return;
            
            showToast("Processing Image...");
            
            const reader = new FileReader();
            reader.onload = function(e) {
                // Pre-process: Resize to max 800px to prevent mobile crash
                // and to standardize input for the tracer
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const MAX_SIZE = 800;
                    let w = img.width;
                    let h = img.height;
                    
                    if (w > h) {
                        if (w > MAX_SIZE) { h *= MAX_SIZE / w; w = MAX_SIZE; }
                    } else {
                        if (h > MAX_SIZE) { w *= MAX_SIZE / h; h = MAX_SIZE; }
                    }
                    
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = "white"; // Force white background
                    ctx.fillRect(0, 0, w, h);
                    ctx.drawImage(img, 0, 0, w, h);
                    
                    // Trace resized data
                    const resizedData = canvas.toDataURL('image/png');
                    runTracer(resizedData);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function runTracer(imageData) {
            // Settings: Balanced for both Elephant (smooth) and Tree (detail)
            const options = {
                ltres: 0.5,       
                qtres: 0.5,       
                pathomit: 1,      // 1 = Skip only 1px noise
                colorsampling: 1, 
                numberofcolors: 2, 
                mincolorratio: 0,
                colorquantcycles: 0,
                blurradius: 0,    
                blurdelta: 10
            };

            ImageTracer.imageToSVG(imageData, function(svgString) {
                processSVGToSandPoints(svgString);
            }, options);
        }

        function processSVGToSandPoints(svgString) {
            saveState();

            const parser = new DOMParser();
            const doc = parser.parseFromString(svgString, "image/svg+xml");
            const svgEl = doc.documentElement;
            
            // --- CRITICAL FIX: Robust Dimension Parsing ---
            // ImageTracer often skips width/height and only provides viewBox
            let svgWidth = parseFloat(svgEl.getAttribute("width"));
            let svgHeight = parseFloat(svgEl.getAttribute("height"));
            
            if (!svgWidth || isNaN(svgWidth) || !svgHeight || isNaN(svgHeight)) {
                const viewBox = svgEl.getAttribute("viewBox");
                if (viewBox) {
                    const parts = viewBox.split(/\s+|,/).map(parseFloat);
                    if(parts.length >= 4) {
                        svgWidth = parts[2];
                        svgHeight = parts[3];
                    }
                }
            }
            
            // Absolute Fallback (prevents NaN math)
            if (!svgWidth || isNaN(svgWidth)) svgWidth = 1000;
            if (!svgHeight || isNaN(svgHeight)) svgHeight = 1000;
            
            const paths = svgEl.getElementsByTagName("path");
            let newPoints = [];
            
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            // Fit to table with 5% padding
            const scaleFactor = (tableR * 2 * 0.95) / Math.max(svgWidth, svgHeight);
            
            const offX = -svgWidth / 2;
            const offY = -svgHeight / 2;

            let pathCount = 0;
            for(let i = 0; i < paths.length; i++) {
                const path = paths[i];
                let totalLen = 0;
                try { totalLen = path.getTotalLength(); } catch(e) { continue; }
                
                // Keep almost everything (threshold 2)
                if(totalLen < 2) continue; 
                pathCount++;

                newPoints.push({type: 'break'});
                
                // Resolution: 1.5mm is a good balance
                const resolution = 1.5; 
                
                for (let dist = 0; dist <= totalLen; dist += resolution) {
                    const pt = path.getPointAtLength(dist);
                    
                    const tx = (pt.x + offX) * scaleFactor;
                    const ty = -(pt.y + offY) * scaleFactor; 

                    if (Math.hypot(tx, ty) < tableR) {
                        newPoints.push({ x: tx, y: ty, type: 'point' });
                    }
                }
            }

            if(newPoints.length > 0) {
                newPoints.push({type: 'break'});
                rawPoints = newPoints; 
                showToast(`Trace Success: ${pathCount} paths found`, 'success');
                render(); 
                generateCode();
            } else {
                console.log("SVG Debug:", svgString);
                showToast("No valid paths found. Try high contrast image.", 'error');
            }
        }


        // --- ENGINE (Updated with V17 Mechanics) ---
        function generateCode() {
            if(rawPoints.length === 0) return;
            
            const L1 = parseFloat(document.getElementById('cfgL1').value);
            const L2 = parseFloat(document.getElementById('cfgL2').value);
            const gearRatio = parseFloat(document.getElementById('cfgGear').value);
            const tableR = parseFloat(document.getElementById('cfgRadius').value);
            const minDelay = parseFloat(document.getElementById('cfgMinDelay').value);
            const smoothDist = parseFloat(document.getElementById('smoothSlider').value);
            const symCount = parseInt(document.getElementById('symSlider').value);
            
            // Speed Settings
            const centerDelay = parseFloat(document.getElementById('cfgCenterDelay').value);
            const perimDelay = parseFloat(document.getElementById('cfgPerimDelay').value);

            // Corrected Scale (1/16th Microstepping)
            const STEPS_PER_DEG = 8.888888;
            const STEPS_PER_RAD = STEPS_PER_DEG * (180/Math.PI);

            let points = [];
            for (let s = 0; s < symCount; s++) {
                const ang = s * (Math.PI * 2 / symCount);
                const cos = Math.cos(ang), sin = Math.sin(ang);
                for(let p of rawPoints) {
                    if(p.type === 'break') { points.push({type:'break'}); continue; }
                    points.push({x: p.x * cos - p.y * sin, y: p.x * sin + p.y * cos});
                }
                if(s < symCount-1) points.push({type:'break'});
            }

            let clean = [];
            let lastP = null;
            
            let firstPoint = points.find(p => p.type !== 'break');
            if(firstPoint) {
                const ang = Math.atan2(firstPoint.y, firstPoint.x);
                clean.push({x: tableR * Math.cos(ang), y: tableR * Math.sin(ang)});
                lastP = clean[0];
            } else {
                clean.push({x: tableR, y: 0});
                lastP = clean[0];
            }

            for(let p of points) {
                if(p.type === 'break') continue; 
                let d = Math.hypot(p.x, p.y);
                if(d > tableR) { let r = tableR/d; p.x*=r; p.y*=r; }
                if(!lastP) { clean.push(p); lastP = p; }
                else {
                    if(Math.hypot(p.x - lastP.x, p.y - lastP.y) >= smoothDist) {
                        clean.push(p); lastP = p;
                    }
                }
            }

            let lastPoint = clean[clean.length-1];
            if(lastPoint) {
                const ang = Math.atan2(lastPoint.y, lastPoint.x);
                clean.push({x: tableR * Math.cos(ang), y: tableR * Math.sin(ang)});
            }
            
            if(clean.length < 2) return;

            let interp = [clean[0]];
            for(let i=0; i<clean.length-1; i++) {
                let p1 = clean[i], p2 = clean[i+1];
                let dist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                let steps = Math.max(1, Math.ceil(dist/1.0)); 
                for(let k=1; k<=steps; k++) {
                    let t = k/steps;
                    interp.push({ x: p1.x+(p2.x-p1.x)*t, y: p1.y+(p2.y-p1.y)*t });
                }
            }

            let cmds = [];
            let prevB = 0, prevE = 0, totalTime = 0;
            let start = calcIK(interp[0].x, interp[0].y, 0, 0, L1, L2, gearRatio, STEPS_PER_RAD);
            prevB = start.b; prevE = start.e;
            
            simulatedPath = [];
            simulatedPath.push(calcFK(prevB, prevE, L1, L2, gearRatio, STEPS_PER_RAD));

            for(let i=1; i<interp.length; i++) {
                let p = interp[i], prevP = interp[i-1];
                let ik = calcIK(p.x, p.y, prevB, prevE, L1, L2, gearRatio, STEPS_PER_RAD);
                let db = Math.round(ik.b - prevB);
                let de = Math.round(ik.e - prevE);

                if(db !== 0 || de !== 0) {
                    
                    // --- SPEED SCALING LOGIC (FROM V16/17) ---
                    let distFromCenter = Math.hypot(p.x, p.y);
                    let rFactor = distFromCenter / tableR;
                    if(rFactor > 1.0) rFactor = 1.0;
                    
                    // Linear scaling
                    let delay = centerDelay + ((perimDelay - centerDelay) * rFactor);
                    if(delay < minDelay) delay = minDelay;
                    
                    // BRESENHAM FIX: No dividing by 2!
                    cmds.push(`G1 ${de} ${db} ${Math.round(delay)}`);
                    
                    let maxSteps = Math.max(Math.abs(db), Math.abs(de));
                    totalTime += (maxSteps * delay); // Single delay per step
                    
                    prevB += db; prevE += de;
                    simulatedPath.push(calcFK(prevB, prevE, L1, L2, gearRatio, STEPS_PER_RAD));
                }
            }

            generatedGCode = cmds.join('\n');
            document.getElementById('stepsOutput').value = generatedGCode;
            
            let sec = Math.round(totalTime / 1000000);
            let min = Math.floor(sec/60); sec = sec%60;
            document.getElementById('timeEstimate').textContent = `${min}m ${sec}s`;
            
            render();
        }

        function getShortestRot(r, l) {
            let d = (r - l) / (2*Math.PI);
            let o = Math.round(d);
            return r - (o * 2 * Math.PI);
        }

        // --- ROBUST INVERSE KINEMATICS (V17 Singularity Logic) ---
        function calcIK(x, y, lb, le, l1, l2, gr, spr) {
            let d = Math.hypot(x, y);
            let max = l1+l2;
            if(d > max) { x = x*max/d; y = y*max/d; d=max; }
            
            // Center Pass-Through Fix:
            // If near center, force base to stay put and just fold elbow
            if(d < 1.0) {
                // Keep base angle, calculate fold
                let currentBaseAngle = -lb / spr;
                // Target is effectively a fold (PI internal angle) relative to base
                let targetElbow = -(Math.PI + gr * currentBaseAngle) * spr;
                return { b: lb, e: targetElbow };
            }

            let lt1 = -lb / spr;
            let cb = (d*d - l1*l1 - l2*l2)/(2*l1*l2);
            cb = Math.max(-1, Math.min(1, cb));
            let b1 = Math.acos(cb), b2 = -Math.acos(cb);
            let k1_1 = l1 + l2*Math.cos(b1), k2_1 = l2*Math.sin(b1);
            let t1_1 = getShortestRot(Math.atan2(y,x) - Math.atan2(k2_1, k1_1), lt1);
            let k1_2 = l1 + l2*Math.cos(b2), k2_2 = l2*Math.sin(b2);
            let t1_2 = getShortestRot(Math.atan2(y,x) - Math.atan2(k2_2, k1_2), lt1);
            let bs1 = -t1_1 * spr, es1 = -(b1 + gr*t1_1) * spr;
            let bs2 = -t1_2 * spr, es2 = -(b2 + gr*t1_2) * spr;
            let c1 = Math.abs(bs1-lb) + Math.abs(es1-le);
            let c2 = Math.abs(bs2-lb) + Math.abs(es2-le);
            return (c1<=c2) ? {b:bs1, e:es1} : {b:bs2, e:es2};
        }

        function calcFK(b, e, l1, l2, gr, spr) {
            let a = -b/spr;
            let comb = -e/spr;
            let beta = comb - (gr*a);
            return {
                x: l1*Math.cos(a) + l2*Math.cos(a+beta),
                y: l1*Math.sin(a) + l2*Math.sin(a+beta)
            };
        }

        function updateUI() {
            document.getElementById('smoothVal').textContent = document.getElementById('smoothSlider').value + 'mm';
            document.getElementById('symVal').textContent = document.getElementById('symSlider').value + 'x';
        }
        function setTool(t) {
            currentTool = t;
            document.getElementById('drawToolBtn').className = t==='draw'?'active-tool':'secondary';
            document.getElementById('eraseToolBtn').className = t==='erase'?'active-tool':'secondary';
        }
        function showToast(msg, type='info') {
            const b = document.getElementById('status-banner');
            b.textContent = msg; 
            b.className = type === 'success' ? 'status-success' : (type === 'error' ? 'status-error' : 'status-info');
            b.style.opacity = 1;
            setTimeout(()=> b.style.opacity = 0, 3000);
        }
        function copyToClipboard() {
            if(!generatedGCode) return showToast("Draw something first!");
            document.getElementById('stepsOutput').select();
            document.execCommand('copy');
            showToast("Copied to clipboard!", 'success');
        }
        function downloadGcode() {
            if(!generatedGCode) return showToast("Draw something first!");
            const blob = new Blob([generatedGCode], {type:'text/plain'});
            const a = document.createElement('a');
            a.download = 'pattern.txt'; a.href = URL.createObjectURL(blob); a.click();
        }
        function sendToTable() {
            if(!generatedGCode) return showToast("Draw something first!");
            showToast("Sending...");
            fetch(`${BASE_URL}/send_gcode_block`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({gcode: generatedGCode, speed_override: null}) // Important: null speed override
            }).then(r=>r.json()).then(d=>{
                if(d.success) showToast("Sent Successfully!", 'success');
                else showToast("Error: " + d.error, 'error');
            }).catch(e=>showToast("Net Error", 'error'));
        }
        function openNav() { document.getElementById("mySidebar").style.width = "200px"; }
        function closeNav() { document.getElementById("mySidebar").style.width = "0"; }
        function toggleTheme() {
            const b = document.body;
            const n = b.getAttribute('data-theme')==='dark'?'light':'dark';
            b.setAttribute('data-theme', n); localStorage.setItem('theme', n);
            document.getElementById('themeToggle').textContent = n==='dark'?'üåô':'‚òÄÔ∏è';
            render();
        }

        init();
    </script>
</body>
</html>
