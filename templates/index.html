<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Packers Sand Table Control</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">

    <style>
        /* --- Root Variables --- */
        :root {
            --color-primary: #d2b48c; /* Khaki/Tan */
            --color-secondary: #b08d5c; /* Darker Tan */
            --color-background: #f0f0f0; 
            --color-surface: #ffffff; 
            --color-text: #333333;
            --color-shadow: rgba(0, 0, 0, 0.08);
            --border-radius: 12px;
            --color-input-bg: #f9f9f9;
            --color-input-border: #ccc;
        }

        body[data-theme='dark'] {
            --color-background: #1e1e1e;
            --color-surface: #2c2c2c;
            --color-text: #e0e0e0;
            --color-shadow: rgba(255, 255, 255, 0.08);
            --color-input-bg: #333;
            --color-input-border: #555;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--color-background);
            color: var(--color-text);
            margin: 0; padding: 0;
            transition: background 0.3s, color 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        /* --- Sidebar & Nav --- */
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background-color: var(--color-primary); overflow-x: hidden;
            transition: 0.3s; padding-top: 60px; z-index: 1000;
            box-shadow: 2px 0 5px var(--color-shadow);
        }
        .sidebar a {
            padding: 15px 24px; text-decoration: none; font-size: 18px;
            color: var(--color-text); display: block; transition: 0.2s; font-weight: 500;
        }
        .sidebar a:hover { background-color: var(--color-secondary); color: var(--color-surface); }

        /* --- Square Menu Button (Top Left) --- */
        .openbtn {
            font-size: 20px; 
            cursor: pointer; 
            background-color: var(--color-primary);
            color: var(--color-text); 
            border: none; 
            border-radius: 8px; 
            position: fixed;
            top: 15px; left: 15px; 
            z-index: 1100; 
            box-shadow: 0 2px 5px var(--color-shadow);
            width: 45px; 
            height: 45px; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            padding: 0;
            line-height: 1;
        }

        #themeToggle {
            position: fixed; top: 15px; right: 15px; background: var(--color-surface);
            color: var(--color-text); border: 1px solid var(--color-text);
            padding: 8px; border-radius: 50%; z-index: 1200;
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            transition: background 0.3s; cursor: pointer;
        }

        /* --- Main Content Wrapper --- */
        .main-content {
            margin-left: 0; transition: margin-left 0.3s; 
            /* Reduced top padding from 80px to 60px */
            padding: 60px 15px 20px 15px; 
            width: 100%; 
            display: flex; flex-direction: column; align-items: center;
            box-sizing: border-box;
        }

        h1 { color: var(--color-secondary); margin-bottom: 15px; font-weight: 300; text-align: center; font-size: 1.8rem; }
        
        /* --- Status Banner --- */
        #status-banner {
            width: 100%; max-width: 700px; padding: 12px; border-radius: var(--border-radius); margin-bottom: 15px;
            text-align: center; font-weight: 600; opacity: 0; transition: opacity 0.3s;
            min-height: 20px; line-height: 1.5; pointer-events: none;
        }
        .status-success { background-color: #d4edda; color: #155724; }
        .status-error { background-color: #f8d7da; color: #721c24; }
        body[data-theme='dark'] .status-success { background-color: #14521f; color: #d4edda; }
        body[data-theme='dark'] .status-error { background-color: #630c17; color: #f8d7da; }

        /* --- Card Layout --- */
        .card {
            background: var(--color-surface);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 10px var(--color-shadow);
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%; max-width: 700px; 
            box-sizing: border-box;
        }

        /* --- Drawing Area --- */
        .canvas-container-outer {
            width: 100%; display: flex; justify-content: center; padding: 10px 0;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%; max-width: 100%; aspect-ratio: 1 / 1;
            border-radius: 50%; border: 4px solid var(--color-primary);
            overflow: hidden; background: #fff; cursor: crosshair;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1); touch-action: none; 
        }

        body[data-theme='dark'] .canvas-wrapper {
            background: #222; border-color: var(--color-secondary);
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* --- Controls --- */
        label { font-weight: 600; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
        .hidden-output { position: absolute; left: -9999px; opacity: 0; }

        button {
            background-color: var(--color-primary); color: var(--color-text);
            border: none; padding: 12px; border-radius: 8px; font-size: 15px;
            cursor: pointer; transition: 0.2s; font-weight: 600; width: 100%;
            box-shadow: 0 2px 5px var(--color-shadow);
        }
        button:hover { background-color: var(--color-secondary); transform: translateY(-1px); }
        
        button.secondary { background-color: transparent; border: 2px solid var(--color-primary); color: var(--color-text); }
        button.secondary:hover { background-color: var(--color-primary); color: var(--color-text); }

        button.square-btn {
            width: 48px; flex-shrink: 0; font-size: 24px; padding: 0;
            display: flex; align-items: center; justify-content: center; line-height: 1;
        }

        .export-container {
            margin-top: 10px; padding: 15px;
            border: 2px dashed var(--color-input-border);
            border-radius: var(--border-radius);
            display: flex; flex-direction: column; gap: 10px;
        }

        .btn-group { display: flex; gap: 10px; }
        .btn-group.tight { gap: 5px; }

        .slider-control {
            display: flex; align-items: center; gap: 10px;
            font-size: 14px;
        }
        input[type="range"] { flex-grow: 1; accent-color: var(--color-secondary); }

    </style>
</head>
<body data-theme="light">

    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Designs</a> 
        <a href="/controls">Drawing</a>
        <a href="{{ url_for('led_controls') }}">LED Controls</a>
        <a href="{{ url_for('AI_builder') }}">AI Builder</a>
        <a href="/terminal">Terminal</a>
    </div>

    <button class="openbtn" onclick="openNav()">‚ò∞</button>
    
    <button id="themeToggle" onclick="toggleTheme()">
        <span id="themeIcon">‚òÄÔ∏è</span>
    </button>

    <div class="main-content">
        <h1>Machine Drawing Pad</h1>

        <div id="status-banner"></div>

        <div class="card">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <label>Workspace (~203mm)</label>
                <span id="coordDisplay" style="font-family:monospace; font-size:12px;">X: 0, Y: 0</span>
            </div>
            
            <div class="canvas-container-outer">
                <div class="canvas-wrapper" id="canvasContainer">
                    <canvas id="drawCanvas"></canvas>
                </div>
            </div>

            <div class="slider-control">
                <label>Smoothing</label>
                <input type="range" id="smoothSlider" min="1" max="10" value="2" title="Higher values reduce point count">
                <span id="smoothVal">2px</span>
            </div>

            <div class="slider-control">
                <label>Symmetry</label>
                <input type="range" id="symSlider" min="1" max="12" value="1" step="1" title="Mirrors drawing radially">
                <span id="symVal">1x</span>
            </div>

            <div class="btn-group">
                <button onclick="undoLastStroke()" class="secondary square-btn" title="Undo">‚Ü∂</button>
                <button onclick="clearCanvas()" class="secondary">Clear</button>
                <button onclick="generateCode()">Generate Code</button>
            </div>

            <textarea id="stepsOutput" class="hidden-output"></textarea>

            <div class="export-container">
                <label style="color:var(--color-secondary);">Export</label>
                <div class="btn-group">
                    <button onclick="copyToClipboard('stepsOutput')">üìã Copy Code</button>
                    <button onclick="sendToTable()">üöÄ Send to Table</button>
                </div>
                
                <div class="btn-group tight" style="margin-top:5px;">
                    <button class="secondary" style="font-size:12px; padding:8px;" onclick="sendCommandSimple('PAUSE')">Pause</button>
                    <button class="secondary" style="font-size:12px; padding:8px;" onclick="sendCommandSimple('RESUME')">Resume</button>
                    <button class="secondary" style="font-size:12px; padding:8px;" onclick="sendCommandSimple('CLEAR')">Clear Queue</button>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const L1 = 101.3; 
        const L2 = 101.3; 
        const MAX_REACH = L1 + L2;
        const GEAR_RATIO = 9 / 8; 
        const STEPS_PER_DEG = 3200 / 360;
        const STEPS_PER_RAD = STEPS_PER_DEG * (180 / Math.PI);
        const LINEAR_RESOLUTION = 7.0; // mm
        
        const BASE_URL = window.location.origin;

        // --- STATE ---
        let isDrawing = false;
        let rawPoints = [];
        let simulatedPath = [];
        let animFrameId = null;
        let fadeLevel = 0; 
        let targetFadeLevel = 0;
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1; 
        let origin = { x: 0, y: 0 };

        // --- INITIALIZATION ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', () => { resizeCanvas(); });
            
            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDraw);
            canvas.addEventListener('mouseleave', endDraw);
            canvas.addEventListener('touchstart', (e) => { if(e.cancelable) e.preventDefault(); startDraw(e.touches[0]); }, {passive: false});
            canvas.addEventListener('touchmove', (e) => { if(e.cancelable) e.preventDefault(); draw(e.touches[0]); }, {passive: false});
            canvas.addEventListener('touchend', endDraw);

            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.setAttribute('data-theme', savedTheme);
            document.getElementById('themeToggle').textContent = savedTheme === 'dark' ? 'üåô' : '‚òÄÔ∏è';

            document.getElementById('smoothSlider').addEventListener('input', (e) => {
                document.getElementById('smoothVal').textContent = e.target.value + 'px';
            });

            // NEW LISTENER FOR SYMMETRY
            document.getElementById('symSlider').addEventListener('input', (e) => {
                document.getElementById('symVal').textContent = e.target.value + 'x';
                render(); // Re-render to show new symmetry immediately
            });

            requestAnimationFrame(animateLoop);
        }

        // --- UI LOGIC ---
        function openNav() {
            document.getElementById("mySidebar").style.width = "200px";
            if(window.innerWidth > 600) document.querySelector(".main-content").style.marginLeft = "200px";
        }
        function closeNav() {
            document.getElementById("mySidebar").style.width = "0";
            document.querySelector(".main-content").style.marginLeft = "0";
        }
        function toggleTheme() {
            const b = document.body;
            const n = b.getAttribute('data-theme')==='dark'?'light':'dark';
            b.setAttribute('data-theme', n); localStorage.setItem('theme', n);
            document.getElementById('themeToggle').textContent = n==='dark'?'üåô':'‚òÄÔ∏è';
            render();
        }

        function showStatus(message, isSuccess = true) {
            const banner = document.getElementById('status-banner');
            banner.textContent = message;
            banner.className = isSuccess ? 'status-success' : 'status-error';
            banner.style.opacity = '1';
            setTimeout(() => { banner.style.opacity = '0'; }, 5000);
        }

        // --- NETWORK LOGIC ---
        async function sendToTable() {
            const code = document.getElementById('stepsOutput').value;
            if (!code) { alert("Generate code first!"); return; }

            showStatus("Sending...", true);
            try {
                const response = await fetch(`${BASE_URL}/send_gcode_block`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ 
                        gcode: code,
                        speed_override: 1000 
                    })
                });
                
                const data = await response.json();
                if (data.success) showStatus("Sent successfully!", true);
                else showStatus("Error: " + data.error, false);

            } catch (e) {
                showStatus("Network Error: " + e.message, false);
            }
        }

        function sendCommandSimple(cmd) {
            fetch(`${BASE_URL}/send`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ command: cmd })
            })
            .then(r => r.json())
            .then(d => {
                if(d.success) showStatus(cmd + " sent", true);
                else showStatus("Error: " + d.error, false);
            })
            .catch(e => showStatus("Error: " + e.message, false));
        }

        // --- ANIMATION & DRAWING ---
        function animateLoop() {
            const speed = 0.1; 
            if(Math.abs(fadeLevel - targetFadeLevel) > 0.001) {
                fadeLevel += (targetFadeLevel - fadeLevel) * speed;
                render();
            } else {
                fadeLevel = targetFadeLevel;
            }
            requestAnimationFrame(animateLoop);
        }

        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const rect = container.getBoundingClientRect();
            const size = rect.width; 
            canvas.width = size; canvas.height = size; 
            origin = { x: size / 2, y: size / 2 };
            scale = (size / 2) / (MAX_REACH * 1.05); 
            render();
        }

        function drawGrid() {
            ctx.save();
            ctx.translate(origin.x, origin.y);
            ctx.fillStyle = '#d2b48c';
            ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = document.body.getAttribute('data-theme') === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.arc(0,0, L1 * scale, 0, Math.PI*2); ctx.stroke();
            ctx.restore();
        }

        // Helper to rotate points for drawing/generating
        function rotatePoint(x, y, angleRad) {
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            return {
                x: x * cos - y * sin,
                y: x * sin + y * cos
            };
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            const symCount = parseInt(document.getElementById('symSlider').value);

            // Sim Layer (Gray) - Already fully generated, just draw it
            if(simulatedPath.length > 0 && fadeLevel > 0.01) {
                ctx.save();
                const opacity = fadeLevel * 0.8; 
                ctx.strokeStyle = document.body.getAttribute('data-theme') === 'dark' ? `rgba(255,255,255,${opacity})` : `rgba(0,0,0,${opacity})`;
                ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.beginPath();
                const start = mmToPx(simulatedPath[0].x, simulatedPath[0].y);
                ctx.moveTo(start.x, start.y);
                for(let i=1; i<simulatedPath.length; i++) {
                    const p = mmToPx(simulatedPath[i].x, simulatedPath[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
                ctx.restore();
            }

            // Drawing Layer (Color) - Apply Symmetry Here
            if(rawPoints.length > 0) {
                ctx.save();
                const opacity = 1.0 - (fadeLevel * 0.9);
                ctx.globalAlpha = opacity;
                ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--color-secondary');

                // Loop through symmetry axes
                for(let s = 0; s < symCount; s++) {
                    const angle = s * (Math.PI * 2 / symCount);
                    
                    ctx.beginPath();
                    let isNextMove = true;
                    for(let p of rawPoints) {
                        if(p.type === 'break') { isNextMove = true; continue; }
                        
                        // Rotate the point mathmatically
                        const rP = rotatePoint(p.x, p.y, angle);
                        const px = mmToPx(rP.x, rP.y);

                        if(isNextMove) { ctx.moveTo(px.x, px.y); isNextMove = false; } 
                        else { ctx.lineTo(px.x, px.y); }
                    }
                    ctx.stroke();
                }
                ctx.restore(); 
            }
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
                // --- COORDINATE CONVERSION (UPDATED) ---
        // We added a Negative (-) sign to the X calculations below.
        // This flips the internal math so the machine draws mirrored, fixing backwards text.

        function pxToMm(px, py) { 
            return { 
                x: -(px - origin.x) / scale, // Added negative sign here
                y: -(py - origin.y) / scale 
            }; 
        }

        function mmToPx(mx, my) { 
            return { 
                x: origin.x - (mx * scale),  // Changed + to - here to match
                y: origin.y - (my * scale) 
            }; 
        }

        function startDraw(e) {
            isDrawing = true;
            targetFadeLevel = 0; 
            document.getElementById('stepsOutput').value = '';
            const pos = getPos(e); addPoint(pos.x, pos.y); render();
        }
        function draw(e) {
            if (!isDrawing) return;
            const pos = getPos(e); const mm = pxToMm(pos.x, pos.y);
            document.getElementById('coordDisplay').textContent = `X: ${mm.x.toFixed(1)}, Y: ${mm.y.toFixed(1)}`;
            addPoint(pos.x, pos.y); render();
        }
        function endDraw() { if(isDrawing) { isDrawing = false; rawPoints.push({type: 'break'}); } }
        function addPoint(px, py) {
            const mm = pxToMm(px, py);
            const dist = Math.hypot(mm.x, mm.y);
            if(dist > MAX_REACH) { const ratio = MAX_REACH / dist; mm.x *= ratio; mm.y *= ratio; }
            rawPoints.push({ x: mm.x, y: mm.y, type: 'point' });
        }

        function undoLastStroke() {
            targetFadeLevel = 0; document.getElementById('stepsOutput').value = '';
            if(rawPoints.length > 0 && rawPoints[rawPoints.length-1].type === 'break') rawPoints.pop();
            while(rawPoints.length > 0) {
                if(rawPoints[rawPoints.length - 1].type === 'break') break;
                rawPoints.pop();
            }
            render();
        }

        function clearCanvas() {
            targetFadeLevel = 0; simulatedPath = []; rawPoints = [];
            document.getElementById('stepsOutput').value = ''; render();
        }

        // --- KINEMATICS & GENERATION ---
        function getShortestRotation(raw, last) {
            let diff = (raw - last) / (2*Math.PI);
            let offset = Math.round(diff);
            return raw - (offset * 2 * Math.PI);
        }

        function calculateIK(x, y, lastBase=0, lastElbow=0) {
            let D = Math.hypot(x, y);
            const maxR = L1 + L2;
            let cx = x, cy = y;
            if(D > maxR) { cx = x*maxR/D; cy = y*maxR/D; D = maxR; }
            
            const lastT1 = -lastBase / STEPS_PER_RAD;
            const lastBend = (-lastElbow / STEPS_PER_RAD) - (GEAR_RATIO * lastT1);
            let finalT1, finalBend;

            if (D < 0.1) {
                finalBend = lastBend > 0 ? Math.PI : -Math.PI;
                let rawT1 = (D < 1e-6) ? lastT1 : Math.atan2(y,x);
                finalT1 = getShortestRotation(rawT1, lastT1);
                cx=0; cy=0;
            } else {
                let cosBend = (D*D - L1*L1 - L2*L2) / (2*L1*L2);
                cosBend = Math.max(-1, Math.min(1, cosBend));
                const bend1 = -Math.acos(cosBend);
                const k1_1 = L1 + L2 * Math.cos(bend1);
                const k2_1 = L2 * Math.sin(bend1);
                const rawT1_1 = Math.atan2(cy, cx) - Math.atan2(k2_1, k1_1);
                const t1_1 = getShortestRotation(rawT1_1, lastT1);
                const bend2 = Math.acos(cosBend);
                const k1_2 = L1 + L2 * Math.cos(bend2);
                const k2_2 = L2 * Math.sin(bend2);
                const rawT1_2 = Math.atan2(cy, cx) - Math.atan2(k2_2, k1_2);
                const t1_2 = getShortestRotation(rawT1_2, lastT1);
                const b1 = -t1_1 * STEPS_PER_RAD;
                const e1 = -(bend1 + GEAR_RATIO*t1_1) * STEPS_PER_RAD;
                const b2 = -t1_2 * STEPS_PER_RAD;
                const e2 = -(bend2 + GEAR_RATIO*t1_2) * STEPS_PER_RAD;
                const cost1 = Math.abs(b1-lastBase) + Math.abs(e1-lastElbow);
                const cost2 = Math.abs(b2-lastBase) + Math.abs(e2-lastElbow);
                if(cost1 <= cost2) { finalT1=t1_1; finalBend=bend1; }
                else { finalT1=t1_2; finalBend=bend2; }
            }

            const alpha = finalT1;
            const beta = finalBend + (GEAR_RATIO * alpha);
            return { 
                base_steps: -alpha * STEPS_PER_RAD,
                elbow_steps: -beta * STEPS_PER_RAD,
                clamped_x: cx, clamped_y: cy
            };
        }

        function calculateFK(p0, b, e) {
            const a = -b / STEPS_PER_RAD;
            const beta = -e / STEPS_PER_RAD;
            const t1 = a;
            const tb = beta - (GEAR_RATIO * a);
            const t2 = t1 + tb;
            const p1 = { x: p0.x + L1*Math.cos(t1), y: p0.y + L1*Math.sin(t1) };
            const p2 = { x: p1.x + L2*Math.cos(t2), y: p1.y + L2*Math.sin(t2) };
            return { p2 };
        }

        function smoothCommands(cmds, sensitivity) {
            if(cmds.length === 0) return [];
            const out = [];
            let curr = {...cmds[0]};
            for(let i=1; i<cmds.length; i++) {
                const next = cmds[i];
                let combine = false;
                if(curr.delay == next.delay) {
                     const sB1 = Math.sign(curr.base), sB2 = Math.sign(next.base);
                     const sE1 = Math.sign(curr.elbow), sE2 = Math.sign(next.elbow);
                     if(curr.base === 0 && next.base === 0 && sE1 === sE2) combine = true;
                     else if(curr.elbow === 0 && next.elbow === 0 && sB1 === sB2) combine = true;
                     else if(curr.base !== 0 && next.base !== 0 && curr.elbow !== 0 && next.elbow !== 0) {
                         const r1 = curr.elbow/curr.base; 
                         const r2 = next.elbow/next.base;
                         if(Math.abs(r1-r2) < sensitivity && sB1===sB2) combine = true;
                     }
                }
                if(combine) { curr.elbow += next.elbow; curr.base += next.base; } 
                else { out.push(curr); curr = {...next}; }
            }
            out.push(curr);
            return out;
        }

        const lerp = (a, b, t) => a + (b - a) * t;

        function getClosestPerimeterPoint(target) {
            const dist = Math.hypot(target.x, target.y);
            if(dist === 0) return { x: MAX_REACH, y: 0 };
            const ratio = MAX_REACH / dist;
            return { x: target.x * ratio, y: target.y * ratio };
        }

        function generateCode() {
            if(rawPoints.length === 0) { alert("Draw something first!"); return; }
            targetFadeLevel = 1.0;

            const inputSmoothDist = parseFloat(document.getElementById('smoothSlider').value);
            const symCount = parseInt(document.getElementById('symSlider').value);

            const delay = 1000; 
            const smoothingSensitivity = 0.000001; 
            
            // 1. EXPAND RAW POINTS BASED ON SYMMETRY
            let expandedPoints = [];
            
            for(let s = 0; s < symCount; s++) {
                const angle = s * (Math.PI * 2 / symCount);
                
                for(let p of rawPoints) {
                    if(p.type === 'break') {
                        expandedPoints.push({type: 'break'});
                    } else {
                        const rP = rotatePoint(p.x, p.y, angle);
                        expandedPoints.push({ x: rP.x, y: rP.y, type: 'point' });
                    }
                }
                // Add a break between rotations to separate the segments logic
                if(s < symCount - 1) expandedPoints.push({type: 'break'});
            }

            // 2. PROCESS INTO SEGMENTS (Standard Logic)
            let segments = [];
            let currentSegment = [];
            let lastP = null;

            for(let p of expandedPoints) {
                if(p.type === 'break') {
                    if(currentSegment.length > 0) segments.push(currentSegment);
                    currentSegment = []; lastP = null; continue;
                }
                if(!lastP) { currentSegment.push(p); lastP = p; continue; }
                const d = Math.hypot(p.x - lastP.x, p.y - lastP.y);
                if(d >= inputSmoothDist) { currentSegment.push(p); lastP = p; }
            }
            if(currentSegment.length > 0) segments.push(currentSegment);
            if(segments.length === 0) return;

            // 3. LINK SEGMENTS (DIRECT CONNECT)
            // We keep the entry/exit to perimeter so it doesn't drag to the start,
            // but between segments, we connect directly.
            let augmentedPoints = [];
            
            // Calculate entry from perimeter to the very first point
            const entryPoint = getClosestPerimeterPoint(segments[0][0]);
            augmentedPoints.push(entryPoint);
            
            for(let i=0; i<segments.length; i++) {
                // DIRECT CONNECTION:
                // We simply concatenate the segments. The interpolation step (Step 4)
                // will automatically draw a line from the last point of segment[i-1]
                // to the first point of segment[i].
                augmentedPoints = augmentedPoints.concat(segments[i]);
            }
            
            // Calculate exit to perimeter from the very last point
            const exitPoint = getClosestPerimeterPoint(segments[segments.length-1][segments[segments.length-1].length-1]);
            augmentedPoints.push(exitPoint);

            // 4. INTERPOLATE
            let interp = [augmentedPoints[0]];
            for(let i=0; i<augmentedPoints.length-1; i++) {
                const p1 = augmentedPoints[i], p2 = augmentedPoints[i+1];
                const dist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                const steps = Math.max(1, Math.ceil(dist/LINEAR_RESOLUTION));
                for(let j=1; j<=steps; j++) {
                    let t = j/steps;
                    interp.push({ x: lerp(p1.x,p2.x,t), y: lerp(p1.y,p2.y,t) });
                }
            }

            // 5. IK & GCODE GENERATION
            let genCmds = [];
            let prevB = 0, prevE = 0;
            const start = calculateIK(interp[0].x, interp[0].y, 0, 0);

            prevB = start.base_steps; 
            prevE = start.elbow_steps;

            for(let i=1; i<interp.length; i++) {
                const ik = calculateIK(interp[i].x, interp[i].y, prevB, prevE);
                const rb = Math.round(ik.base_steps - prevB);
                const re = Math.round(ik.elbow_steps - prevE);
                if(rb!==0 || re!==0) genCmds.push({elbow:re, base:rb, delay:delay});
                prevB = ik.base_steps; prevE = ik.elbow_steps;
            }

            let smoothed = genCmds;
            let lastLen = -1;
            while(smoothed.length !== lastLen) {
                lastLen = smoothed.length;
                smoothed = smoothCommands(smoothed, smoothingSensitivity);
            }

            document.getElementById('stepsOutput').value = smoothed.map(c => `G1 ${c.elbow} ${c.base} ${c.delay}`).join('\n');
            
            simulateFromSteps(smoothed, start);
        }


        function simulateFromSteps(stepsList, startState) {
            simulatedPath = [];
            let currentB = startState ? startState.base_steps : 0;
            let currentE = startState ? startState.elbow_steps : 0;
            const p0 = {x:0, y:0}; 

            const startFK = calculateFK(p0, currentB, currentE);
            simulatedPath.push(startFK.p2);

            for(let s of stepsList) {
                currentB += s.base; currentE += s.elbow;
                const result = calculateFK(p0, currentB, currentE);
                simulatedPath.push(result.p2); 
            }
        }

        function copyToClipboard(id) {
            const el = document.getElementById(id);
            if(!el.value) { alert("Nothing to copy yet! Draw and Generate first."); return; }
            el.select();
            document.execCommand('copy');
            const btn = document.querySelector('button[onclick^="copyToClipboard"]');
            const originalText = btn.textContent;
            btn.textContent = "‚úÖ Copied!";
            btn.style.backgroundColor = "var(--color-secondary)";
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.backgroundColor = "var(--color-primary)";
            }, 1000);
        }

        init();
    </script>
</body>
</html>
