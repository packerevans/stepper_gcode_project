<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Constant Speed Sand Converter v3</title>
<style>
    :root {
        --bg: #f4f4f9;
        --panel: #ffffff;
        --text: #333;
        --accent: #b08d5c; /* Sand color */
        --accent-hover: #967548;
        --border: #ddd;
    }
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg);
        color: var(--text);
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    h1 { margin-top: 0; color: var(--accent); }
    .container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        max-width: 1200px;
        width: 100%;
    }
    @media (max-width: 768px) {
        .container { grid-template-columns: 1fr; }
    }
    .card {
        background: var(--panel);
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    .full-width { grid-column: 1 / -1; }
    
    label { font-weight: 600; font-size: 0.9em; display: block; margin-bottom: 5px; }
    input[type="number"], select {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--border);
        border-radius: 6px;
        box-sizing: border-box;
    }
    textarea {
        width: 100%;
        height: 150px;
        padding: 10px;
        border: 1px solid var(--border);
        border-radius: 6px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
        box-sizing: border-box;
    }
    
    button {
        background-color: var(--accent);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1em;
        transition: background 0.2s;
    }
    button:hover { background-color: var(--accent-hover); }
    button.secondary {
        background-color: transparent;
        border: 2px solid var(--accent);
        color: var(--accent);
    }
    button.secondary:hover { background-color: rgba(176, 141, 92, 0.1); }

    .canvas-container {
        position: relative;
        width: 100%;
        padding-top: 100%; /* 1:1 Aspect Ratio */
        background: #fff;
        border: 1px solid var(--border);
        border-radius: 8px;
    }
    canvas {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        border-radius: 8px;
    }
    .status-bar {
        padding: 15px;
        background: #eef;
        border-left: 5px solid var(--accent);
        border-radius: 4px;
        font-size: 0.95em;
        color: #445;
        line-height: 1.5;
        white-space: pre-wrap;
    }
    .settings-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }
</style>
</head>
<body>

<h1>Sand Table Converter v3</h1>

<div class="container">
    <!-- Input Section -->
    <div class="card">
        <h2>1. Input</h2>
        <div>
            <label>Upload File (.thr, .gcode, .txt)</label>
            <input type="file" id="fileInput" accept=".thr,.gcode,.txt,.nc">
        </div>
        <div>
            <label>Input Format Strategy</label>
            <select id="inputFormat">
                <option value="auto">Auto-Detect (Recommended)</option>
                <option value="thr">Theta-Rho (.thr) - Radians & Normalized</option>
                <option value="polar_gcode">Polar G-Code (G1 R A) - mm & Degrees</option>
                <option value="cartesian">Cartesian (G1 X Y)</option>
            </select>
        </div>
        <textarea id="inputData" placeholder="Paste code or upload file here..."></textarea>
        <div class="status-bar" id="inputStats">Waiting for data...</div>
    </div>

    <!-- Settings Section -->
    <div class="card">
        <h2>2. Machine Settings</h2>
        <div class="settings-grid">
            <div>
                <label>Table Max Radius (mm)</label>
                <input type="number" id="tableRadius" value="202.6">
            </div>
            <div>
                <label>Target Speed (mm/s)</label>
                <input type="number" id="targetSpeed" value="20" title="How fast the ball moves visually">
            </div>
            <div>
                <label>Arm 1 Length (mm)</label>
                <input type="number" id="L1" value="101.3">
            </div>
            <div>
                <label>Arm 2 Length (mm)</label>
                <input type="number" id="L2" value="101.3">
            </div>
            <div>
                <label>Gear Ratio</label>
                <input type="number" id="gearRatio" value="1.125" step="0.001"> <!-- 9/8 = 1.125 -->
            </div>
            <div>
                <label>Steps per Degree</label>
                <input type="number" id="stepsPerDeg" value="8.888888" step="0.000001"> <!-- 3200/360 -->
            </div>
            <div>
                <label>Min Motor Delay (us)</label>
                <input type="number" id="minDelay" value="200" title="Prevents motors from stalling if speed calculation asks for infinite speed">
            </div>
        </div>
        <label>Interpolation Resolution (mm)</label>
        <input type="number" id="resolution" value="1.0" title="Smaller values make smoother curves but larger files">
        <button onclick="processData()">Convert & Simulate</button>
    </div>

    <!-- Simulation Section -->
    <div class="card full-width">
        <h2>3. Simulation & Output</h2>
        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 300px;">
                <label>Visual Preview</label>
                <div class="canvas-container">
                    <canvas id="simCanvas"></canvas>
                </div>
                <div style="margin-top:10px; display:flex; gap:10px;">
                     <button class="secondary" onclick="playSimulation()">▶ Play</button>
                     <button class="secondary" onclick="stopSimulation()">⏹ Stop</button>
                     <input type="range" id="simSlider" min="0" max="100" value="0" style="flex-grow:1;">
                </div>
            </div>
            <div style="flex: 1; min-width: 300px;">
                <label>Output Code</label>
                <textarea id="outputData" style="height: 400px;" readonly placeholder="Converted G-code will appear here..."></textarea>
                <button onclick="copyOutput()" style="margin-top: 10px;">Copy to Clipboard</button>
                <button onclick="downloadOutput()" class="secondary" style="margin-top: 10px;">Download File (.txt)</button>
            </div>
        </div>
    </div>
</div>

<script>
// --- GLOBAL CONSTANTS & STATE ---
let RAW_COORDS = []; // {x, y} in mm
let GENERATED_COMMANDS = []; // {elbow, base, delay}
let ARM_STATES = []; // For simulation
let animId = null;

// --- DOM ELEMENTS ---
const fileInput = document.getElementById('fileInput');
const inputData = document.getElementById('inputData');
const outputData = document.getElementById('outputData');
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const simSlider = document.getElementById('simSlider');

// --- INITIALIZATION ---
window.onload = function() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            inputData.value = e.target.result;
            processData();
        };
        reader.readAsText(file);
    });

    simSlider.addEventListener('input', (e) => {
        stopSimulation();
        const idx = Math.floor((parseFloat(e.target.value) / 100) * (ARM_STATES.length - 1));
        drawSimulation(idx);
    });
};

function resizeCanvas() {
    const container = canvas.parentElement;
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    if (ARM_STATES.length > 0) {
        const idx = Math.floor((parseFloat(simSlider.value) / 100) * (ARM_STATES.length - 1));
        drawSimulation(idx);
    }
}

// --- CORE LOGIC: PARSING & CONVERSION ---

function processData() {
    // 1. Get Settings
    const tableRadius = parseFloat(document.getElementById('tableRadius').value);
    const res = parseFloat(document.getElementById('resolution').value);
    const format = document.getElementById('inputFormat').value;
    
    const text = inputData.value;
    const lines = text.split('\n');
    
    RAW_COORDS = [];
    
    // 2. Parse Input
    let mode = format;
    if (mode === 'auto') {
        // Simple heuristic
        if (text.includes('thetarho')) mode = 'thr';
        else if (text.match(/G1.*R/i)) mode = 'polar_gcode';
        else if (text.match(/G1.*X/i)) mode = 'cartesian';
        else mode = 'thr'; // Default to thr if it looks like raw numbers
    }

    document.getElementById('inputStats').innerText = `Detected Mode: ${mode}`;

    for (let line of lines) {
        line = line.trim();
        if (!line || line.startsWith('#') || line.startsWith(';')) continue;

        let x = 0, y = 0;

        if (mode === 'thr') {
            // Regex for "Theta Rho" (Space separated numbers)
            // Example: 1.57080 1.00000
            const parts = line.trim().split(/\s+/);
            if (parts.length >= 2 && !isNaN(parseFloat(parts[0]))) {
                let theta = parseFloat(parts[0]); // Radians
                let rho = parseFloat(parts[1]);   // Normalized 0-1
                
                // Scale Rho to Table Dimensions
                let r_mm = rho * tableRadius;
                
                x = r_mm * Math.cos(theta);
                y = r_mm * Math.sin(theta);
                RAW_COORDS.push({x, y});
            }
        } 
        else if (mode === 'polar_gcode') {
            // G1 R100 A90
            const match = line.match(/G1\s+.*R([\d.-]+).*A([\d.-]+)/i);
            if (match) {
                let r = parseFloat(match[1]);
                let deg = parseFloat(match[2]);
                let rad = deg * (Math.PI / 180);
                x = r * Math.cos(rad);
                y = r * Math.sin(rad);
                RAW_COORDS.push({x, y});
            }
        }
        else {
            // Cartesian G1 X10 Y10
            const match = line.match(/G1\s+.*X([\d.-]+).*Y([\d.-]+)/i);
            if (match) {
                x = parseFloat(match[1]);
                y = parseFloat(match[2]);
                RAW_COORDS.push({x, y});
            }
        }
    }

    if (RAW_COORDS.length === 0) {
        alert("No valid coordinates found. Check input format.");
        return;
    }

    // 3. Interpolate (Smooth the path)
    let interpolated = [RAW_COORDS[0]];
    for (let i = 0; i < RAW_COORDS.length - 1; i++) {
        let p1 = RAW_COORDS[i];
        let p2 = RAW_COORDS[i+1];
        let dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        let steps = Math.ceil(dist / res);
        steps = Math.max(1, steps);
        
        for (let j = 1; j <= steps; j++) {
            let t = j / steps;
            interpolated.push({
                x: p1.x + (p2.x - p1.x) * t,
                y: p1.y + (p2.y - p1.y) * t
            });
        }
    }

    // 4. Inverse Kinematics & Step Generation
    generateSteps(interpolated);
}

function generateSteps(pathPoints) {
    const L1 = parseFloat(document.getElementById('L1').value);
    const L2 = parseFloat(document.getElementById('L2').value);
    const gearRatio = parseFloat(document.getElementById('gearRatio').value);
    const stepsPerDeg = parseFloat(document.getElementById('stepsPerDeg').value);
    
    // Velocity Settings
    const targetSpeedMmSec = parseFloat(document.getElementById('targetSpeed').value); // mm/s
    const minDelayUs = parseFloat(document.getElementById('minDelay').value); // us
    
    const stepsPerRad = stepsPerDeg * (180 / Math.PI);

    GENERATED_COMMANDS = [];
    let prevBase = 0;
    let prevElbow = 0;
    let totalTimeUs = 0;
    
    // Store Cartesian of previous point to calc distance
    let prevX = pathPoints[0].x;
    let prevY = pathPoints[0].y;

    // Calculate starting position steps (Reset simulation to here)
    let startIK = calculateIK(pathPoints[0].x, pathPoints[0].y, 0, 0, L1, L2, gearRatio, stepsPerRad);
    prevBase = startIK.base_steps;
    prevElbow = startIK.elbow_steps;

    // Loop through points
    for (let i = 1; i < pathPoints.length; i++) {
        let p = pathPoints[i];
        
        // 1. Inverse Kinematics to get Steps
        let ik = calculateIK(p.x, p.y, prevBase, prevElbow, L1, L2, gearRatio, stepsPerRad);
        
        let dBase = Math.round(ik.base_steps - prevBase);
        let dElbow = Math.round(ik.elbow_steps - prevElbow);

        if (dBase !== 0 || dElbow !== 0) {
            
            // 2. CONSTANT VELOCITY CALCULATION
            // A. How far are we physically moving in this interpolation segment?
            let distanceMm = Math.hypot(p.x - prevX, p.y - prevY);
            
            // B. How long should this take? (Time = Distance / Speed)
            let timeSeconds = distanceMm / targetSpeedMmSec;
            
            // C. Find the dominant axis (the one moving the most steps)
            let maxSteps = Math.max(Math.abs(dBase), Math.abs(dElbow));
            
            // D. Calculate Delay (Time / Steps) converted to Microseconds
            let calculatedDelay = 1000; 
            if (maxSteps > 0 && timeSeconds > 0) {
                calculatedDelay = (timeSeconds * 1000000) / maxSteps;
            }
            
            // E. Clamp to safety limit (prevents motor stall)
            if (calculatedDelay < minDelayUs) calculatedDelay = minDelayUs;
            
            // Round to integer for clean G-Code
            calculatedDelay = Math.round(calculatedDelay);

            GENERATED_COMMANDS.push({
                elbow: dElbow,
                base: dBase,
                delay: calculatedDelay
            });
            
            // Accumulate Total Time (Steps * Delay)
            totalTimeUs += (maxSteps * calculatedDelay);

            // Update State
            prevBase += dBase;
            prevElbow += dElbow;
            prevX = p.x;
            prevY = p.y;
        }
    }

    // 5. Format Output
    const outputText = GENERATED_COMMANDS.map(c => `G1 ${c.elbow} ${c.base} ${c.delay}`).join('\n');
    outputData.value = outputText;
    
    // 6. Update Status Bar with Time Estimate
    const totalSeconds = totalTimeUs / 1000000;
    const h = Math.floor(totalSeconds / 3600);
    const m = Math.floor((totalSeconds % 3600) / 60);
    const s = Math.floor(totalSeconds % 60);
    
    const timeString = `${h}h ${m}m ${s}s`;
    
    document.getElementById('inputStats').innerText += `\n✅ Generated ${GENERATED_COMMANDS.length} commands`;
    document.getElementById('inputStats').innerText += `\n⏱ Estimated Run Time: ${timeString}`;

    // 7. Prepare Simulation
    prepareSimulation(L1, L2, stepsPerRad, gearRatio);
}

// --- KINEMATICS ---

function getShortestRotation(raw, last) {
    let diff = (raw - last) / (2 * Math.PI);
    let offset = Math.round(diff);
    return raw - (offset * 2 * Math.PI);
}

function calculateIK(x, y, lastBaseSteps, lastElbowSteps, L1, L2, gearRatio, stepsPerRad) {
    let dist = Math.hypot(x, y);
    const maxReach = L1 + L2;
    
    // Clamp to reachable area
    if (dist > maxReach) {
        x = (x / dist) * maxReach;
        y = (y / dist) * maxReach;
        dist = maxReach;
    }

    // Previous angles in radians (Converted from steps)
    const lastT1 = -lastBaseSteps / stepsPerRad; 
    
    // Law of Cosines for "Elbow" internal angle
    let cosBend = (dist*dist - L1*L1 - L2*L2) / (2 * L1 * L2);
    cosBend = Math.max(-1, Math.min(1, cosBend));
    
    // Two possible solutions: Elbow Right vs Elbow Left
    const bend1 = Math.acos(cosBend);
    const bend2 = -Math.acos(cosBend);

    // Calculate Theta1 (Base angle) for both solutions
    const k1_1 = L1 + L2 * Math.cos(bend1);
    const k2_1 = L2 * Math.sin(bend1);
    let t1_1 = Math.atan2(y, x) - Math.atan2(k2_1, k1_1);
    t1_1 = getShortestRotation(t1_1, lastT1);

    const k1_2 = L1 + L2 * Math.cos(bend2);
    const k2_2 = L2 * Math.sin(bend2);
    let t1_2 = Math.atan2(y, x) - Math.atan2(k2_2, k1_2);
    t1_2 = getShortestRotation(t1_2, lastT1);

    // Calculate resulting steps for both solutions to find shortest move
    const b1_steps = -t1_1 * stepsPerRad;
    const e1_steps = -(bend1 + gearRatio * t1_1) * stepsPerRad;

    const b2_steps = -t1_2 * stepsPerRad;
    const e2_steps = -(bend2 + gearRatio * t1_2) * stepsPerRad;

    const cost1 = Math.abs(b1_steps - lastBaseSteps) + Math.abs(e1_steps - lastElbowSteps);
    const cost2 = Math.abs(b2_steps - lastBaseSteps) + Math.abs(e2_steps - lastElbowSteps);

    if (cost1 <= cost2) {
        return { base_steps: b1_steps, elbow_steps: e1_steps };
    } else {
        return { base_steps: b2_steps, elbow_steps: e2_steps };
    }
}

function calculateFK(baseSteps, elbowSteps, L1, L2, gearRatio, stepsPerRad) {
    // Reverse the IK mapping
    const alpha = -baseSteps / stepsPerRad;
    const combined = -elbowSteps / stepsPerRad;
    const beta = combined - (gearRatio * alpha);
    
    const elbowX = L1 * Math.cos(alpha);
    const elbowY = L1 * Math.sin(alpha);
    
    const endX = elbowX + L2 * Math.cos(alpha + beta);
    const endY = elbowY + L2 * Math.sin(alpha + beta);
    
    return { x1: elbowX, y1: elbowY, x2: endX, y2: endY };
}

// --- VISUALIZATION ---

function prepareSimulation(L1, L2, stepsPerRad, gearRatio) {
    ARM_STATES = [];
    let curBase = 0;
    let curElbow = 0;

    // Initial state
    ARM_STATES.push(calculateFK(0, 0, L1, L2, gearRatio, stepsPerRad));

    // Integrate commands
    for(let cmd of GENERATED_COMMANDS) {
        curBase += cmd.base;
        curElbow += cmd.elbow;
        ARM_STATES.push(calculateFK(curBase, curElbow, L1, L2, gearRatio, stepsPerRad));
    }
    
    drawSimulation(0);
}

function drawSimulation(index) {
    const width = canvas.width;
    const height = canvas.height;
    const tableRadius = parseFloat(document.getElementById('tableRadius').value);
    
    // Clear
    ctx.clearRect(0, 0, width, height);
    
    // Setup Transform (Center 0,0)
    ctx.save();
    ctx.translate(width/2, height/2);
    const scale = (width/2) / (tableRadius * 1.1); // Fit table with margin
    ctx.scale(scale, -scale); // Flip Y

    // Draw Table
    ctx.beginPath();
    ctx.arc(0, 0, tableRadius, 0, Math.PI*2);
    ctx.strokeStyle = "#ddd";
    ctx.lineWidth = 2 / scale;
    ctx.stroke();

    // Draw Input Path (Blue)
    if (RAW_COORDS.length > 0) {
        ctx.beginPath();
        ctx.strokeStyle = "rgba(0, 100, 255, 0.3)";
        ctx.lineWidth = 1 / scale;
        ctx.moveTo(RAW_COORDS[0].x, RAW_COORDS[0].y);
        for(let i=1; i<RAW_COORDS.length; i++) {
            ctx.lineTo(RAW_COORDS[i].x, RAW_COORDS[i].y);
        }
        ctx.stroke();
    }

    // Draw Arm Trace (Red)
    if (ARM_STATES.length > 0) {
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
        ctx.lineWidth = 1.5 / scale;
        // Draw trace up to current index
        ctx.moveTo(ARM_STATES[0].x2, ARM_STATES[0].y2);
        for(let i=1; i<=index; i++) {
             ctx.lineTo(ARM_STATES[i].x2, ARM_STATES[i].y2);
        }
        ctx.stroke();

        // Draw Arm Itself
        const state = ARM_STATES[index];
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4 / scale;
        ctx.lineCap = "round";
        
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(state.x1, state.y1);
        ctx.lineTo(state.x2, state.y2);
        ctx.stroke();

        // Joints
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
        ctx.beginPath(); ctx.arc(0,0, 6/scale, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(state.x1, state.y1, 5/scale, 0, Math.PI*2); ctx.fill();
    }
    
    ctx.restore();
}

// --- UTILS ---
function playSimulation() {
    if (animId) return;
    let i = parseInt(simSlider.value) / 100 * (ARM_STATES.length - 1);
    
    function loop() {
        i += 5; // Speed
        if (i >= ARM_STATES.length) i = 0;
        simSlider.value = (i / ARM_STATES.length) * 100;
        drawSimulation(Math.floor(i));
        animId = requestAnimationFrame(loop);
    }
    loop();
}

function stopSimulation() {
    if (animId) cancelAnimationFrame(animId);
    animId = null;
}

function copyOutput() {
    outputData.select();
    document.execCommand('copy');
    alert("Copied to clipboard!");
}

function downloadOutput() {
    const text = outputData.value;
    const blob = new Blob([text], { type: 'text/plain' });
    const anchor = document.createElement('a');
    anchor.download = 'converted_sand.txt';
    anchor.href = window.URL.createObjectURL(blob);
    anchor.click();
}

</script>
</body>
</html>

