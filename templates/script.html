<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2DOF Arm Kinematic Simulator & G-Code Converter</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
body {
font-family: 'Inter', sans-serif;
}
/* Style for the highlighted command in the list */
.command-item.active {
background-color: #3b82f6; /* bg-blue-600 */
color: white;
}
/* Ensure canvas is responsive and maintains aspect ratio */
canvas {
width: 100%;
height: 100%;
aspect-ratio: 1/1;
display: block;
border-radius: 0.5rem;
}
/* Custom scrollbar for logic editor */
textarea {
scrollbar-width: thin;
scrollbar-color: #4b5563 #1f2937;
}
/* Hide number input spinners */
input[type=number]::-webkit-inner-spin-button,
input[type=number]::-webkit-outer-spin-button {
-webkit-appearance: none;
margin: 0;
}
input[type=number] {
-moz-appearance: textfield;
}
</style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased">

<div class="max-w-7xl mx-auto p-4 lg:p-8">
    <header class="mb-6">
        <h1 class="text-3xl font-bold text-white">2DOF Arm Kinematic Simulator & G-Code Converter</h1>
        <p class="text-lg text-gray-400">Simulating a 2-motor arm with 101.3mm links and 9/8 gearing.</p>
    </header>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        
        <div class="lg:col-span-1 bg-gray-800 p-6 rounded-xl shadow-lg flex flex-col gap-6">
            
            <div class="bg-gray-900 p-4 rounded-lg border border-gray-700">
                <label for="gcodeConverterInput" class="block text-sm font-medium text-gray-300 mb-2">
                    1. Paste Cartesian (X, Y) G-Code
                </label>
                <textarea id="gcodeConverterInput" rows="8" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-gray-200 font-mono text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g.,&#10;G1 X203.2 Y0&#10;G1 X0 Y0&#10;G1 X0 Y203.2&#10;G1 X0 Y0">
G1 X203.2 Y0
G1 X0 Y0
G1 X0 Y203.2
G1 X0 Y0
G1 X203.2 Y0
</textarea>
                <button id="convertGCodeBtn" class="w-full mt-3 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md">
                    Convert, Scale & Load
                </button>
            </div>
            <div>
                <label for="commandsInput" class="block text-sm font-medium text-gray-300 mb-2">
                    2. Arm Commands (G1 Elbow Base StepDelay_μs)
                </label>
                <textarea id="commandsInput" rows="8" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-gray-200 font-mono text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., G1 0 800 1000&#10;G1 1600 0 500&#10;G1 0 -800 1000&#10;G1 -1600 0 2000">
G1 0 400 1000
G1 0 800 1000
G1 400 800 500
G1 400 400 500
G1 0 0 200
G1 -800 0 1000
G1 -800 -800 1000
G1 0 -800 500
G1 0 0 200
</textarea>
</div>

            <button id="loadCommandsBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md">
                Load & Reset Simulation
            </button>


            <div>
                <label class="block text-sm font-medium text-gray-300 mb-2">Playback</label>
                <div class="flex items-center gap-4 mb-2">
                    <button id="playBtn" class="bg-green-600 hover:bg-green-700 text-white p-2 rounded-full disabled:opacity-50" title="Play">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.002v3.996a1 1 0 001.555.832l3.197-1.998a1 1 0 000-1.664l-3.197-1.998z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button id="pauseBtn" class="bg-yellow-600 hover:bg-yellow-700 text-white p-2 rounded-full" title="Pause">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9 6a1 1 0 00-1 1v6a1 1 0 002 0V7a1 1 0 00-1-1zm2 0a1 1 0 00-1 1v6a1 1 0 002 0V7a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <span id="stepDisplay" class="font-mono text-sm text-gray-400">Step: 0 / 0</span>
                </div>
                <input id="commandSlider" type="range" min="0" max="0" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50">
            </div>
            
        </div>

        <div class="lg:col-span-2 flex flex-col gap-6">
            
            <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
                <canvas id="armCanvas" class="bg-gray-900"></canvas>
            </div>
            
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const canvas = document.getElementById('armCanvas');
        const ctx = canvas.getContext('2d');
        const commandsInput = document.getElementById('commandsInput');
        const loadCommandsBtn = document.getElementById('loadCommandsBtn');
        const commandSlider = document.getElementById('commandSlider');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stepDisplay = document.getElementById('stepDisplay');
        
        // *** NEW: Converter DOM elements ***
        const gcodeConverterInput = document.getElementById('gcodeConverterInput');
        const convertGCodeBtn = document.getElementById('convertGCodeBtn');

        // --- Simulation Constants ---
        const L1 = 101.3; // mm (Upper arm)
        const L2 = 101.3; // mm (Lower arm)
        const GEAR_RATIO = 9 / 8; // 1.125
        
        const STEPS_PER_DEG = 3200 / 360;
        const STEPS_PER_RAD = STEPS_PER_DEG * (180 / Math.PI);

        // --- Simulation State ---
        let commands = []; // List of {base, elbow} steps
        let cumulativeStates = []; // List of all arm states (pos, angles)
        let currentStep = 0; // The index of the *target* state
        let isAutoPlaying = false;
        
        // Animation state
        let animationFrameId = null;
        let animationStartTime = 0;
        let animationFromState = null;
        let animationToState = null;
        
        let origin = { x: 0, y: 0 };
        let worldScale = 1; // pixels per mm

        let tracePath = [];
        
        // Utility function for linear interpolation
        const lerp = (a, b, t) => a + (b - a) * t;

        // --- Core Functions ---

        /**
         * Initializes the simulation, sets up event listeners, and loads initial data.
         */
        function init() {
            // Set up event listeners
            loadCommandsBtn.addEventListener('click', loadCommands);
            commandSlider.addEventListener('input', handleSliderInput);
            playBtn.addEventListener('click', play);
            pauseBtn.addEventListener('click', pause);
            window.addEventListener('resize', debounce(resizeAndRedraw, 250));
            
            // *** NEW: Converter listener ***
            convertGCodeBtn.addEventListener('click', convertGCode);
            
            // Initial setup
            resizeCanvas();
            loadCommands(); // Load default commands from textarea
        }

        /**
         * Handles window resize. Recalculates canvas dimensions and world scale.
         */
        function resizeCanvas() {
            const parent = canvas.parentElement;
            const parentWidth = parent.clientWidth;
            const size = parentWidth > 32 ? parentWidth - 32 : parentWidth;
            
            canvas.width = size;
            canvas.height = size;

            origin.x = canvas.width / 2;
            origin.y = canvas.height / 2;
            
            const maxReach = (L1 + L2) * 1.1;
            worldScale = Math.min(canvas.width, canvas.height) / (maxReach * 2);

            ctx.resetTransform();
            ctx.translate(origin.x, origin.y);
            ctx.scale(worldScale, -worldScale); // Scale and flip Y
        }

        /**
         * Redraws the current state after a resize.
         */
        function resizeAndRedraw() {
            resizeCanvas();
            if (cumulativeStates.length > 0) {
                drawState(currentStep);
            }
        }

        // --- *** NEW: G-Code Converter Functions *** ---

        /**
         * Converts Cartesian (X,Y) G-Code into the arm's relative step commands.
         */
        function convertGCode() {
            const gcodeText = gcodeConverterInput.value;
            const lines = gcodeText.split('\n');
            const xyRegex = /G1\s+X(-?[\d.]+)\s+Y(-?[\d.]+)/i;
            
            let coords = [];
            let max_gcode_reach_sq = 0;

            // --- 1. Parse all coords and find max reach ---
            for (const line of lines) {
                const match = line.trim().match(xyRegex);
                if (match) {
                    const x = parseFloat(match[1]);
                    const y = parseFloat(match[2]);
                    coords.push({ x, y });
                    
                    const reach_sq = x*x + y*y;
                    if (reach_sq > max_gcode_reach_sq) {
                        max_gcode_reach_sq = reach_sq;
                    }
                }
            }

            if (coords.length === 0) {
                alert("No valid 'G1 X... Y...' commands found.");
                return;
            }

            // --- 2. Calculate scaling factor ---
            const max_gcode_reach = Math.sqrt(max_gcode_reach_sq);
            const arm_max_reach = L1 + L2;
            let scale_factor = 1.0;

            // Scale down to 98% of arm's max reach if G-code is too large
            if (max_gcode_reach > arm_max_reach) {
                scale_factor = (arm_max_reach * 0.98) / max_gcode_reach;
                console.log(`G-Code reach (${max_gcode_reach.toFixed(2)}mm) exceeds arm reach (${arm_max_reach}mm). Scaling by ${scale_factor.toFixed(3)}.`);
            }

            // --- 3. Convert scaled coords to relative arm commands ---
            let convertedCommands = [];
            let prev_base_steps = 0;
            let prev_elbow_steps = 0;

            // We must start from a known position. Let's use the IK for (L1+L2, 0).
            // But G-code often starts from (0,0), which is a singularity.
            // Let's assume the arm *starts* at the first G-code point.
            
            // Calculate the *first* point as an absolute move from (0,0)
            let firstPoint = true;
            
            try {
                for (const coord of coords) {
                    const scaled_x = coord.x * scale_factor;
                    const scaled_y = coord.y * scale_factor;

                    // Calculate the *absolute* steps required to reach this (x,y)
                    const { base_steps, elbow_steps } = calculateIK(scaled_x, scaled_y);
                    
                    let rel_base, rel_elbow;
                    
                    if (firstPoint) {
                        // For the first point, the relative move is from an assumed (0,0) steps start
                        // But let's just use the IK for the *home* position (e.g., X=100, Y=0)
                        // For simplicity, let's assume the first move is *absolute* from 0.
                        // Wait, no, the existing arm code `calculateAllStates` assumes 0,0 steps.
                        // So the first move IS relative to 0,0.
                        
                        // Let's reset the 'previous' state to 0 for the first command.
                        prev_base_steps = 0;
                        prev_elbow_steps = 0;
                        firstPoint = false; // Only do this for the *very first* command in the list
                    }

                    // Calculate the *relative* steps needed to get from previous point to current point
                    rel_base = Math.round(base_steps - prev_base_steps);
                    rel_elbow = Math.round(elbow_steps - prev_elbow_steps);
                    
                    // Format the new command (using a default 1000μs delay)
                    convertedCommands.push(`G1 ${rel_elbow} ${rel_base} 1000`);

                    // Update the "previous" state to this new *absolute* target
                    prev_base_steps = base_steps;
                    prev_elbow_steps = elbow_steps;
                }
            } catch (e) {
                alert(`Conversion Error: ${e.message}`);
                return;
            }

            // --- 4. Load into simulator ---
            commandsInput.value = convertedCommands.join('\n');
            loadCommandsBtn.click(); // Automatically click "Load & Reset"
        }

        /**
         * Inverse Kinematics: Calculates arm motor steps from (X, Y) position.
         */
        function calculateIK(x, y) {
            const D_sq = x*x + y*y;
            const D = Math.sqrt(D_sq);
            const arm_max_reach = L1 + L2;
            const arm_min_reach = Math.abs(L1 - L2);

            // --- 1. Check if reachable ---
            // Add a tiny 0.1mm tolerance for floating point errors
            if (D > arm_max_reach + 0.1) {
                throw new Error(`Point (X${x.toFixed(1)}, Y${y.toFixed(1)}) is outside max reach (${arm_max_reach}mm).`);
            }
            if (D < arm_min_reach - 0.1 && D > 0.1) { // Ignore singularity at (0,0)
                throw new Error(`Point (X${x.toFixed(1)}, Y${y.toFixed(1)}) is inside min reach (${arm_min_reach}mm).`);
            }
            
            // Handle singularity at origin
            if (D < 0.1) {
                // Return a "home" position, e.g., folded back
                // This is arbitrary, let's just return (0,0) steps
                return { base_steps: 0, elbow_steps: 0 };
            }

            // --- 2. Calculate angles ---
            // Use Law of Cosines to find the "bend" angle
            let cos_theta_bend = (D_sq - L1*L1 - L2*L2) / (2 * L1 * L2);
            // Clamp for floating point errors (e.g., -1.00000001)
            cos_theta_bend = Math.max(-1, Math.min(1, cos_theta_bend)); 
            
            // We'll use the "elbow up" solution, which corresponds to a negative bend angle
            // in a standard mathematical (Y-up) coordinate system.
            const theta_bend = -Math.acos(cos_theta_bend);

            // Find the angle for the first arm (theta1)
            const k1 = L1 + L2 * Math.cos(theta_bend);
            const k2 = L2 * Math.sin(theta_bend);
            
            const theta1 = Math.atan2(y, x) - Math.atan2(k2, k1);

            // --- 3. Convert angles to motor angles (alpha, beta) ---
            // From our FK logic:
            // theta1 = alpha_rad
            // theta_bend = beta_rad - (GEAR_RATIO * alpha_rad)
            
            const alpha_rad = theta1;
            const beta_rad = theta_bend + (GEAR_RATIO * alpha_rad);

            // --- 4. Convert motor angles (radians) to steps ---
            // From our FK logic (note the sign inversion):
            // alpha_rad = -base_steps / STEPS_PER_RAD
            // beta_rad = -elbow_steps / STEPS_PER_RAD

            const base_steps = -alpha_rad * STEPS_PER_RAD;
            const elbow_steps = -beta_rad * STEPS_PER_RAD;

            return { 
                base_steps: base_steps, 
                elbow_steps: elbow_steps 
            };
        }

        // --- *** END: G-Code Converter Functions *** ---


        /**
         * Parses commands from the textarea, calculates all states, and resets the UI.
         */
        function loadCommands() {
            pause();
            
            // --- Step 1: Parse Commands ---
            const text = commandsInput.value;
            
            commands = text.split('\n')
                .filter(line => line.trim().startsWith('G1')) // Check for G1
                .map(line => {
                    // Get parts after 'G1 '
                    const parts = line.trim().substring(2).trim().split(/\s+/).map(s => parseInt(s.trim(), 10));
                    // Expecting G1 {elbow} {base} {step_delay_us}
                    return { 
                        elbow: parts[0] || 0, 
                        base: parts[1] || 0, 
                        step_delay_us: parts[2] !== undefined ? parts[2] : 1000 
                    };
                });

            // --- Step 2: Calculate States ---
            calculateAllStates();

            // --- Step 3: Calculate the full, high-resolution trace path ---
            calculateTracePath();
            
            // --- Step 4: Update UI ---
            commandSlider.max = cumulativeStates.length - 1;
            commandSlider.value = 0;
            currentStep = 0;
            
            // --- Step 5: Draw Initial State ---
            drawState(0);
            
            // --- Step 6: Enable controls ---
            setControlsEnabled(cumulativeStates.length > 1);
        }

        // Enable/disable playback controls
        function setControlsEnabled(enabled) {
            playBtn.disabled = !enabled;
            commandSlider.disabled = !enabled;
        }

        /**
         * Pre-calculates the arm's position and angles for every step.
         */
        function calculateAllStates() {
            cumulativeStates = [];
            let total_base_steps = 0;
            let total_elbow_steps = 0;
            const p0 = { x: 0, y: 0 }; // Base pivot is always at origin

            // Add initial state (Step 0)
            cumulativeStates.push(calculateFK(p0, 0, 0));

            for (const cmd of commands) {
                total_base_steps += cmd.base;
                total_elbow_steps += cmd.elbow;
                
                const state = calculateFK(p0, total_base_steps, total_elbow_steps);
                state.command = cmd; // Store the *relative* command that led to this state
                cumulativeStates.push(state);
            }
        }

        /**
         * Pre-calculates the high-resolution path for the trace line.
         */
        function calculateTracePath() {
            tracePath = [];
            if (cumulativeStates.length < 2) return;

            tracePath.push(cumulativeStates[0].p2); 

            for (let i = 0; i < cumulativeStates.length - 1; i++) {
                const fromState = cumulativeStates[i];
                const toState = cumulativeStates[i+1];

                const base_delta = Math.abs(toState.target_base_steps - fromState.target_base_steps);
                const elbow_delta = Math.abs(toState.target_elbow_steps - fromState.target_elbow_steps);
                const max_step_delta = Math.max(base_delta, elbow_delta);

                const stepsPerSegment = Math.max(20, Math.ceil(max_step_delta / 100));

                for (let j = 1; j <= stepsPerSegment; j++) {
                    const progress = j / stepsPerSegment;
                    const interpolatedState = getInterpolatedState(fromState, toState, progress);
                    tracePath.push(interpolatedState.p2);
                }
            }
        }

        /**
         * Forward Kinematics: Calculates arm position from motor steps.
         */
        function calculateFK(p0, base_steps, elbow_steps) {
            // Convert steps to radians
            const alpha_rad = -base_steps / STEPS_PER_RAD; // Base motor angle
            const beta_rad = -elbow_steps / STEPS_PER_RAD;  // Elbow motor angle
            
            // --- *** LOCKED KINEMATIC LOGIC *** ---
            const theta1 = alpha_rad;
            const theta_bend = beta_rad - (GEAR_RATIO * alpha_rad);
            const theta2_global = theta1 + theta_bend;
            // --- *** END OF LOCKED LOGIC *** ---

            // Calculate elbow (p1) and end-effector (p2) positions
            const p1 = {
                x: p0.x + L1 * Math.cos(theta1),
                y: p0.y + L1 * Math.sin(theta1)
            };
            const p2 = {
                x: p1.x + L2 * Math.cos(theta2_global),
                y: p1.y + L2 * Math.sin(theta2_global)
            };

            return {
                p0, p1, p2,
                target_base_steps: base_steps,
                target_elbow_steps: elbow_steps,
                theta1_rad: theta1,
                theta_bend_rad: theta_bend,
                theta2_global_rad: theta2_global
            };
        }


        /**
         * Handles user input on the slider.
         */
        function handleSliderInput(e) {
            pause();
            const newStep = parseInt(e.target.value, 10);
            drawState(newStep); // Jump to the selected state
        }
        
        /**
         * Jumps to a specific step, cancels animation, and draws the final state.
         */
        function drawState(index) {
            pause(); // Stop any running animation
            currentStep = index;
            const state = cumulativeStates[index];
            if (!state) return;

            // Draw the final state
            clearCanvas();
            drawGrid();
            drawTrace();
            drawArm(state.p0, state.p1, state.p2);
            
            // Update UI to match this state
            updateUIForStep(index);
        }

        /**
         * Updates all UI elements (slider, info box, highlight) for a given step index.
         */
        function updateUIForStep(index) {
            const state = cumulativeStates[index];
            if (!state) return;
            
            commandSlider.value = index;
            stepDisplay.textContent = `Step: ${index} / ${cumulativeStates.length - 1}`;
        }

        /**
         * Clears the canvas.
         */
        function clearCanvas() {
            ctx.save();
            ctx.resetTransform();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore(); // Restore origin and scale
        }

        /**
         * Draws a grid and axes.
         */
        function drawGrid() {
            const maxRange = L1 + L2;
            const lineWidth = 1 / worldScale; // Keep lines 1px wide
            
            // Draw range circles
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = lineWidth;
            ctx.arc(0, 0, L1, 0, 2 * Math.PI);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, maxRange, 0, 2 * Math.PI);
            ctx.stroke();

            // Draw axes
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = lineWidth;
            ctx.moveTo(-maxRange * 1.1, 0);
            ctx.lineTo(maxRange * 1.1, 0);
            ctx.moveTo(0, -maxRange * 1.1);
            ctx.lineTo(0, maxRange * 1.1);
            ctx.stroke();
        }

        /**
         * Draws the trace from the pre-calculated tracePath.
         */
        function drawTrace() {
            if (tracePath.length < 2) return;

            const traceWidth = 2 / worldScale;
            
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.75)'; // White trace line
            ctx.lineWidth = traceWidth;
            
            ctx.moveTo(tracePath[0].x, tracePath[0].y);

            for (let i = 1; i < tracePath.length; i++) {
                ctx.lineTo(tracePath[i].x, tracePath[i].y);
            }
            
            ctx.stroke();
        }

        /**
         * Draws the arm segments and joints.
         */
        function drawArm(p0, p1, p2) {
            const armWidth = 6 / worldScale;
            const jointRadius = 8 / worldScale;
            
            // Draw L1 (Upper Arm)
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.strokeStyle = '#3b82f6'; // bg-blue-600
            ctx.lineWidth = armWidth;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Draw L2 (Lower Arm)
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = '#10b981'; // bg-emerald-500
            ctx.lineWidth = armWidth;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Draw Joints
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(p0.x, p0.y, jointRadius, 0, 2 * Math.PI); // Base Pivot
            ctx.fill();
            ctx.beginPath();
            ctx.arc(p1.x, p1.y, jointRadius, 0, 2 * Math.PI); // Elbow Joint
            ctx.fill();
            
            // End Effector
            ctx.fillStyle = '#f87171'; // bg-red-400
            ctx.beginPath();
            ctx.arc(p2.x, p2.y, jointRadius, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        /**
         * Factored out interpolation logic to be reusable.
         */
        function getInterpolatedState(from, to, progress) {
            // Interpolate angles, not positions, to maintain arm length
            const theta1_rad = lerp(from.theta1_rad, to.theta1_rad, progress);
            const theta_bend_rad = lerp(from.theta_bend_rad, to.theta_bend_rad, progress);
            const theta2_global_rad = lerp(from.theta2_global_rad, to.theta2_global_rad, progress);

            // Recalculate p1 and p2 based on interpolated angles
            const p0 = from.p0; // p0 is always (0,0)
            const p1 = {
                x: p0.x + L1 * Math.cos(theta1_rad),
                y: p0.y + L1 * Math.sin(theta1_rad)
            };
            const p2 = {
                x: p1.x + L2 * Math.cos(theta2_global_rad),
                y: p1.y + L2 * Math.sin(theta2_global_rad)
            };

            // Return a state object
            return { p0, p1, p2 };
        }

        /**
         * Draws an interpolated state during animation.
         */
        function drawInterpolatedState(from, to, progress) {
            const state = getInterpolatedState(from, to, progress);
            
            clearCanvas();
            drawGrid();
            drawTrace();
            drawArm(state.p0, state.p1, state.p2);
        }
        
        // --- Playback Controls ---

        function play() {
            if (isAutoPlaying) return;
            
            // If at the end, reset to start
            if (currentStep >= cumulativeStates.length - 1) {
                currentStep = 0;
                drawState(0);
            }
            
            isAutoPlaying = true;
            playNextCommand();
        }
        
        function pause() {
            isAutoPlaying = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        /**
         * Kicks off the animation to the next step.
         */
        function playNextCommand() {
            if (!isAutoPlaying || currentStep >= cumulativeStates.length - 1) {
                isAutoPlaying = false; // Stop at the end
                return;
            }
            
            animationFromState = cumulativeStates[currentStep];
            animationToState = cumulativeStates[currentStep + 1];
            animationStartTime = performance.now();
            
            currentStep++;
            
            const currentCommand = animationToState.command;
            
            const { elbow, base, step_delay_us } = currentCommand;
            const max_steps = Math.max(Math.abs(elbow), Math.abs(base));
            const duration_ms = (max_steps * step_delay_us) / 1000.0;
            
            commandSlider.value = currentStep;
            stepDisplay.textContent = `Step: ${currentStep} / ${cumulativeStates.length - 1}`;
            
            // Start the animation loop
            animationFrameId = requestAnimationFrame((t) => animateStep(t, duration_ms));
        }

        /**
         * The main animation loop, driven by requestAnimationFrame.
         */
        function animateStep(timestamp, duration_ms) {
            const elapsed = timestamp - animationStartTime;
            let progress = elapsed / duration_ms;

            if (duration_ms === 0) {
                progress = 1;
            }

            if (progress >= 1) {
                // Animation finished
                progress = 1;
                drawState(currentStep); // Draw the final, precise state
                
                if (isAutoPlaying) {
                    playNextCommand(); // Move to the next command
                }
            } else {
                // Animation in progress
                drawInterpolatedState(animationFromState, animationToState, progress);
                animationFrameId = requestAnimationFrame((t) => animateStep(t, duration_ms));
            }
        }

        // --- Utilities ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // --- Start the App ---
        init();
    });
</script>
</body>
</html>
