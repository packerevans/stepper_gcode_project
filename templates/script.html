<script>
        // --- Fixed Constants ---
        const L1_LENGTH = 101.6;
        const L2_LENGTH = 101.6;
        const MAX_REACH = L1_LENGTH + L2_LENGTH;
        const MIN_REACH = Math.abs(L1_LENGTH - L2_LENGTH);
        const DEG_TO_STEPS = 3200 / 360;
        const Q1_OFFSET_DEG = 90;  // Arm 1 "0" is 90deg (Up)
        const Q2_OFFSET_DEG = 180; // Arm 2 "0" is 180deg (Folded)
        const EPSILON = 1e-6; // Small value for float comparison
        // const SEGMENT_LENGTH = 5.0; // NO LONGER NEEDED

        // --- DOM Elements ---
        function getCalculatorElements() {
            return {
                initialXInput: document.getElementById('initialX'),
                initialYInput: document.getElementById('initialY'),
                convertButton: document.getElementById('convertButton'),
                inputGcodeEl: document.getElementById('inputGcode'),
                outputGcodeEl: document.getElementById('outputGcode'),
                copyButton: document.getElementById('copyButton'),
                copySuccess: document.getElementById('copySuccess'),
                canvas: document.getElementById('ikCanvas'),
                ctx: document.getElementById('ikCanvas') ? document.getElementById('ikCanvas').getContext('2d') : null,
                warningIndicator: document.getElementById('warningIndicator'),
                warningMessages: document.getElementById('warningMessages'),
                stepSlider: document.getElementById('stepSlider'),
                stepLabel: document.getElementById('stepLabel')
            };
        }
        
        // --- State ---
        let canvasSize = 0;
        let scale = 1;
        let originX = 0;
        let originY = 0;
        let globalPathSegments = []; // Stores the calculated path segments

        // --- Utility Functions ---
        function toDegrees(radians) {
            return radians * (180 / Math.PI);
        }
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        /**
         * Calculates Inverse Kinematics for a given point.
         * @returns {object} { solution1, solution2, clampedX, clampedY, isClamped, error }
         */
        function calculateIK(l1, l2, x, y) {
            let dSq = x * x + y * y;
            let d = Math.sqrt(dSq);
            let clampedX = x;
            let clampedY = y;
            let isClamped = false;
            
            // --- Clamping Logic ---
            if (d > MAX_REACH - EPSILON) {
                isClamped = true;
                const ratio = (MAX_REACH - EPSILON) / d; // Clamp slightly inside max
                clampedX = x * ratio;
                clampedY = y * ratio;
                d = MAX_REACH - EPSILON;
                dSq = d * d;
            } else if (d < MIN_REACH + EPSILON) {
                if (d < EPSILON) {
                    // At origin (0,0)
                } else {
                    isClamped = true;
                    const ratio = (MIN_REACH + EPSILON) / d; // Clamp slightly outside min
                    clampedX = x * ratio;
                    clampedY = y * ratio;
                    d = MIN_REACH + EPSILON;
                    dSq = d * d;
                }
            }

            // --- IK Calculation (on potentially clamped values) ---
            const cosQ2 = (dSq - l1 * l1 - l2 * l2) / (2 * l1 * l2);
            
            // Handle precision errors at max/min reach
            const clampedCosQ2 = Math.max(-1, Math.min(1, cosQ2));

            // Handle (0,0) singularity for q1
            if (d < EPSILON) {
                const home_q1_rad = toRadians(Q1_OFFSET_DEG); // 90 deg
                return {
                    solution1: { q1: home_q1_rad, q2: Math.acos(clampedCosQ2) }, // q2 = pi (Elbow Down)
                    solution2: { q1: home_q1_rad, q2: -Math.acos(clampedCosQ2) }, // q2 = -pi (Elbow Up)
                    clampedX, clampedY, isClamped
                };
            }
            
            // sol1 = Elbow Down (positive q2)
            const q2_rad_sol1 = Math.acos(clampedCosQ2);
            // sol2 = Elbow Up (negative q2)
            const q2_rad_sol2 = -Math.acos(clampedCosQ2);

            const k1_sol1 = l1 + l2 * Math.cos(q2_rad_sol1);
            const k2_sol1 = l2 * Math.sin(q2_rad_sol1);
            const q1_rad_sol1 = Math.atan2(clampedY, clampedX) - Math.atan2(k2_sol1, k1_sol1);

            const k1_sol2 = l1 + l2 * Math.cos(q2_rad_sol2);
            const k2_sol2 = l2 * Math.sin(q2_rad_sol2);
            const q1_rad_sol2 = Math.atan2(clampedY, clampedX) - Math.atan2(k2_sol2, k1_sol2);

            return {
                solution1: { q1: q1_rad_sol1, q2: q2_rad_sol1 }, // Elbow Down
                solution2: { q1: q1_rad_sol2, q2: q2_rad_sol2 }, // Elbow Up
                clampedX, clampedY, isClamped
            };
        }

        // --- Drawing Functions ---
        function resizeCanvas() {
            const { canvas, ctx, stepSlider } = getCalculatorElements();
            if (!canvas || !ctx) return; 
            
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            if (rect.width === 0) return; 
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvasSize = rect.width;
            originX = canvasSize / 2;
            originY = canvasSize / 2;
            drawToStep(stepSlider.value); 
        }

        function drawGrid() {
            const { canvas, ctx } = getCalculatorElements();
            if (!canvas || !ctx) return;
            scale = (canvasSize / 2) * 0.9 / MAX_REACH; 
            
            ctx.clearRect(0, 0, canvasSize, canvasSize);
            ctx.save();
            ctx.translate(originX, originY);
            
            // Grid, Axes, Reach Circle... (as before, no changes)
            const gridSize = 50 * scale;
            const steps = Math.ceil(originX / gridSize);
            ctx.beginPath();
            ctx.strokeStyle = '#e5e7eb'; // gray-200
            ctx.lineWidth = 1;
            for (let i = -steps; i <= steps; i++) {
                ctx.moveTo(i * gridSize, -originY); ctx.lineTo(i * gridSize, originY);
                ctx.moveTo(-originX, i * gridSize); ctx.lineTo(originX, i * gridSize);
            }
            ctx.stroke();
            ctx.beginPath();
            ctx.strokeStyle = '#9ca3af'; // gray-400
            ctx.lineWidth = 2;
            ctx.moveTo(-originX, 0); ctx.lineTo(originX, 0); // X Axis
            ctx.moveTo(0, -originY); ctx.lineTo(0, originY); // Y Axis
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0, 0, MAX_REACH * scale, 0, 2 * Math.PI);
            ctx.strokeStyle = '#3b82f6'; // blue-500
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();
        }

        // Draws just the path segments (lines)
        function drawPathSegments(segments) {
            const { canvas, ctx } = getCalculatorElements();
            if (!canvas || !ctx) return;
            ctx.save();
            ctx.translate(originX, originY);
            ctx.scale(1, -1); // Flip Y-axis

            for (const segment of segments) {
                // Do not draw "prep" moves, which have same start/end
                if (segment.startX === segment.endX && segment.startY === segment.endY) {
                    continue;
                }
                ctx.beginPath();
                ctx.moveTo(segment.startX * scale, segment.startY * scale);
                ctx.lineTo(segment.endX * scale, segment.endY * scale);
                
                // We're not interpolating, so all lines are "complex" arcs
                // Let's color them differently
                ctx.strokeStyle = segment.isClamped ? '#ef4444' : '#f97316'; // red-500 or orange-500
                ctx.lineWidth = 2;
                ctx.setLineDash([2, 4]); // Draw arcs as dashed lines
                ctx.stroke();
            }
            ctx.setLineDash([]);
            ctx.restore();
        }
        
        // Draws the arm at a specific X, Y cartesian coordinate AND solution
        function drawArmAtPosition(x, y, solution) {
            const { canvas, ctx } = getCalculatorElements();
            if (!canvas || !ctx) return;
            const result = calculateIK(L1_LENGTH, L2_LENGTH, x, y);
            if (result.error) return;

            const angles = (solution === 'down') ? result.solution1 : result.solution2;
            const { q1, q2 } = angles;
            const color = (solution === 'down') ? '#0ea5e9' : '#2563eb'; // 'up' is blue-600, 'down' is cyan-500

            const joint1X = (L1_LENGTH * Math.cos(q1)) * scale;
            const joint1Y = (L1_LENGTH * Math.sin(q1)) * scale;

            const endEffectorX = (L1_LENGTH * Math.cos(q1) + L2_LENGTH * Math.cos(q1 + q2)) * scale;
            const endEffectorY = (L1_LENGTH * Math.sin(q1) + L2_LENGTH * Math.sin(q1 + q2)) * scale;

            ctx.save();
            ctx.translate(originX, originY);
            ctx.scale(1, -1); // Flip Y-axis

            // Draw Arm 1
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(joint1X, joint1Y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Draw Arm 2
            ctx.beginPath();
            ctx.moveTo(joint1X, joint1Y);
            ctx.lineTo(endEffectorX, endEffectorY);
            ctx.strokeStyle = color;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // Draw Joints
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, 2 * Math.PI); // Base joint
            ctx.fillStyle = '#4b5563'; // gray-600
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(joint1X, joint1Y, 8, 0, 2 * Math.PI); // Elbow joint
            ctx.fillStyle = color;
            ctx.fill();
            
            // Draw Target Point
            ctx.beginPath();
            ctx.arc(endEffectorX, endEffectorY, 10, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.restore();
        }

        // Main drawing function: draws grid, path, and arm
        function drawToStep(stepIndex) {
            const { canvas, initialXInput, initialYInput } = getCalculatorElements();
            if (!canvas || !initialXInput || !initialYInput) return;
            
            stepIndex = parseInt(stepIndex, 10);
            drawGrid();

            const segmentsToDraw = globalPathSegments.slice(0, stepIndex);
            drawPathSegments(segmentsToDraw);

            let finalX, finalY, finalSolution;
            
            if (stepIndex === 0) {
                finalX = parseFloat(initialXInput.value || "203.2");
                finalY = parseFloat(initialYInput.value || "0");
                finalSolution = document.querySelector('input[name="solution"]:checked').value;
            } else {
                const lastSegment = segmentsToDraw[stepIndex - 1];
                finalX = lastSegment.endX;
                finalY = lastSegment.endY;
                finalSolution = lastSegment.endSolution; // Use the solution we ended up with
            }
            
            drawArmAtPosition(finalX, finalY, finalSolution);
        }

        // --- HELPER: Calculates motor steps from angle deltas ---
        function calculateGcode(startAngles, endAngles) {
            const delta_q1_deg = toDegrees(endAngles.q1 - startAngles.q1);
            const delta_q2_deg = toDegrees(endAngles.q2 - startAngles.q2);

            const delta_motor1_deg = delta_q1_deg;
            const delta_motor2_deg = delta_q1_deg + delta_q2_deg;
            
            const motor1_steps = Math.round(delta_motor1_deg * DEG_TO_STEPS);
            const motor2_steps = Math.round((0.125 * motor1_steps) + (delta_motor2_deg * DEG_TO_STEPS));
            
            // Avoid sending 0 0 commands
            if (motor1_steps === 0 && motor2_steps === 0) {
                return { gcode: null, motor1_steps: 0, motor2_steps: 0 };
            }
            
            const gcode = `G1 ${motor2_steps} ${motor1_steps} 1000`;
            return { gcode, motor1_steps, motor2_steps };
        }

        // --- HELPER: Calculates the "cost" (sum of squared motor change) ---
        function getAngleCost(anglesA, anglesB) {
            const delta_q1_deg = toDegrees(anglesB.q1 - anglesA.q1);
            const delta_q2_deg = toDegrees(anglesB.q2 - anglesA.q2);
            
            const delta_motor1_deg = delta_q1_deg;
            const delta_motor2_deg = delta_q1_deg + delta_q2_deg;
            
            // Return sum of squares
            return (delta_motor1_deg * delta_motor1_deg) + (delta_motor2_deg * delta_motor2_deg);
        }

        // --- *NEW* Main Conversion Logic (Lookahead at (0,0) only) ---
        function handleConversion() {
            const els = getCalculatorElements();
            if (!els.inputGcodeEl || !els.initialXInput || !els.initialYInput || !els.warningIndicator || !els.warningMessages || !els.outputGcodeEl || !els.stepSlider) {
                return;
            }

            const inputGcode = els.inputGcodeEl.value;
            const lines = inputGcode.split('\n');
            
            // Get the user's *initial* preferred solution
            let currentSolution = document.querySelector('input[name="solution"]:checked').value;
            
            let currentX = parseFloat(els.initialXInput.value || "203.2");
            let currentY = parseFloat(els.initialYInput.value || "0");
            
            // --- Reset state ---
            els.warningIndicator.classList.add('hidden');
            els.warningMessages.classList.add('hidden');
            els.warningMessages.querySelector('ul').innerHTML = '';
            globalPathSegments = []; // Clear previous path

            if (isNaN(currentX) || isNaN(currentY)) {
                // ... (error handling as before) ...
                return;
            }

            let outputGcode = [];
            let warnings = [];
            
            // --- Step 1: Parse all valid G1 commands first ---
            const g1Commands = [];
            for (const [index, line] of lines.entries()) {
                const trimmedLine = line.trim();
                const g1Match = trimmedLine.toUpperCase().match(/^G1\s+/);
                if (g1Match) {
                    const xMatch = trimmedLine.match(/X\s*(-?[\d\.]+)/i);
                    const yMatch = trimmedLine.match(/Y\s*(-?[\d\.]+)/i);
                    if (xMatch || yMatch) {
                        g1Commands.push({ line: trimmedLine, index: index + 1, xMatch, yMatch });
                    }
                }
            }

            // --- Step 2: Iterate through the parsed commands with lookahead ---
            for (let i = 0; i < g1Commands.length; i++) {
                const command = g1Commands[i];
                const nextCommand = (i + 1 < g1Commands.length) ? g1Commands[i+1] : null;

                const P_start = { x: currentX, y: currentY };
                
                // Determine target (P_mid)
                const targetX = command.xMatch ? parseFloat(command.xMatch[1]) : currentX;
                const targetY = command.yMatch ? parseFloat(command.yMatch[1]) : currentY;
                const P_mid = { x: targetX, y: targetY };

                // --- Calculate IK for this move (A -> B) ---
                const startResult = calculateIK(L1_LENGTH, L2_LENGTH, P_start.x, P_start.y);
                const midResult = calculateIK(L1_LENGTH, L2_LENGTH, P_mid.x, P_mid.y);

                if (startResult.error || midResult.error) {
                    warnings.push(`Line ${command.index} ('${command.line}'): Calculation failed.`);
                    continue;
                }
                if (midResult.isClamped) {
                    warnings.push(`Line ${command.index} ('${command.line}'): Target unreachable, clamped to (${midResult.clampedX.toFixed(2)}, ${midResult.clampedY.toFixed(2)}).`);
                }

                // Get angles based on the *current* solution
                const startAngles = (currentSolution === 'down') ? startResult.solution1 : startResult.solution2;
                const midAngles_current = (currentSolution === 'down') ? midResult.solution1 : midResult.solution2;
                
                // --- Add G-code for the A -> B move ---
                const moveGcode = calculateGcode(startAngles, midAngles_current);
                if(moveGcode.gcode) outputGcode.push(moveGcode.gcode);
                
                globalPathSegments.push({
                    startX: P_start.x,
                    startY: P_start.y,
                    endX: midResult.clampedX,
                    endY: midResult.clampedY,
                    isClamped: midResult.isClamped,
                    endSolution: currentSolution // Solution we *arrived* with
                });

                // Update current position to the (potentially clamped) midpoint
                currentX = midResult.clampedX;
                currentY = midResult.clampedY;

                // --- Lookahead Logic: Decide if a "prep" move is needed at P_mid ---
                
                // Check if we are at the origin
                const atOrigin = (currentX * currentX + currentY * currentY) < EPSILON;

                if (nextCommand && atOrigin) {
                    console.log(`Lookahead: At origin (0,0), checking for prep move.`);
                    // Determine next target (P_end)
                    const nextTargetX = nextCommand.xMatch ? parseFloat(nextCommand.xMatch[1]) : currentX; // Start from new currentX
                    const nextTargetY = nextCommand.yMatch ? parseFloat(nextCommand.yMatch[1]) : currentY; // Start from new currentY
                    const P_end = { x: nextTargetX, y: nextTargetY };

                    const endResult = calculateIK(L1_LENGTH, L2_LENGTH, P_end.x, P_end.y);
                    if (endResult.error) {
                        warnings.push(`Lookahead for Line ${nextCommand.index} failed.`);
                        continue;
                    }

                    // Get the *other* solution for P_mid
                    const otherSolution = (currentSolution === 'up') ? 'down' : 'up';
                    const midAngles_other = (otherSolution === 'down') ? midResult.solution1 : midResult.solution2;
                    
                    // Get both potential solution angles for P_end
                    const endAngles_current = (currentSolution === 'down') ? endResult.solution1 : endResult.solution2;
                    const endAngles_other = (otherSolution === 'down') ? endResult.solution1 : endResult.solution2;

                    // Calculate cost of B -> C (staying on current solution)
                    const cost_stay = getAngleCost(midAngles_current, endAngles_current);
                    
                    // Calculate cost of B -> C (switching to other solution)
                    const cost_switch = getAngleCost(midAngles_other, endAngles_other);

                    // --- Decision ---
                    if (cost_switch < cost_stay) {
                        console.log(`Lookahead: Prep move is cheaper. Adding.`);
                        // It's "cheaper" to switch. Add the prep move.
                        const prepGcode = calculateGcode(midAngles_current, midAngles_other);
                        if(prepGcode.gcode) outputGcode.push(prepGcode.gcode + ` ; Prep move at (0,0)`);

                        // Add a "dummy" segment for the slider (no length, but holds new solution)
                        globalPathSegments.push({
                            startX: currentX, startY: currentY,
                            endX: currentX, endY: currentY,
                            isClamped: false,
                            endSolution: otherSolution // Solution we are *switching* to
                        });
                        
                        // CRITICAL: Update the current solution for the *next* loop iteration
                        currentSolution = otherSolution;
                    } else {
                        console.log(`Lookahead: Staying with current solution is cheaper. No prep move.`);
                    }
                } else if (nextCommand) {
                    console.log(`Lookahead: Not at origin. Prep move disabled.`);
                }
            } // --- End of for loop ---

            // --- Finalize ---
            els.outputGcodeEl.value = outputGcode.join('\n');
            els.stepSlider.max = globalPathSegments.length;
            els.stepSlider.value = globalPathSegments.length;
            els.stepLabel.textContent = `${globalPathSegments.length} / ${globalPathSegments.length}`;
            drawToStep(globalPathSegments.length);

            // --- Show Warnings if any ---
            if (warnings.length > 0) {
                const uniqueWarnings = [...new Set(warnings)];
                els.warningIndicator.classList.remove('hidden');
                els.warningMessages.classList.remove('hidden');
                els.warningMessages.querySelector('ul').innerHTML = uniqueWarnings.map(w => `<li>${w}</li>`).join('');
            }
        }
        
        // --- Slider Event ---
        function handleSliderChange(event) {
            const { stepLabel, stepSlider } = getCalculatorElements();
            if (!stepLabel || !stepSlider) return;
            
            const step = event.target.value;
            stepLabel.textContent = `${step} / ${stepSlider.max}`;
            drawToStep(step);
        }

        // --- Copy Button Logic ---
        function setupCopyButton() {
            const { copyButton, outputGcodeEl, copySuccess } = getCalculatorElements();
            if (!copyButton || !outputGcodeEl || !copySuccess) return;

            copyButton.addEventListener('click', () => {
                const textToCopy = outputGcodeEl.value;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    copySuccess.classList.remove('hidden');
                    copyButton.classList.add('hidden');
                    setTimeout(() => {
                        copySuccess.classList.add('hidden');
                        copyButton.classList.remove('hidden');
                    }, 2000);
                }).catch(err => {
                    // Fallback for http or other issues
                    try {
                        const textArea = document.createElement('textarea');
                        textArea.value = textToCopy;
                        textArea.style.position = 'fixed'; 
                        textArea.style.opacity = '0';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        
                        copySuccess.classList.remove('hidden');
                        copyButton.classList.add('hidden');
                        setTimeout(() => {
                            copySuccess.classList.add('hidden');
                            copyButton.classList.remove('hidden');
                        }, 2000);
                    } catch (e) {
                         console.error('Fallback copy failed: ', e);
                    }
                });
            });
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            const { convertButton, stepSlider } = getCalculatorElements();
            
            if (convertButton) {
                convertButton.addEventListener('click', handleConversion);
                stepSlider.addEventListener('input', handleSliderChange);
                window.addEventListener('resize', resizeCanvas);
                setupCopyButton();
                
                setTimeout(() => {
                    resizeCanvas();
                    handleConversion(); // Run once on load
                }, 100);
            }
        });
    </script>
</body>
</html>
