<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coupled Arm Command Executor (End Effector Path)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use the Inter font family */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Import Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        /* Custom styles for a better-looking range slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #374151; /* gray-700 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }
        /* Style for the command list */
        .command-item {
            transition: all 0.2s ease-in-out;
            border-left: 4px solid transparent;
        }
        .command-item.highlight {
            background-color: #3b82f633; /* blue-500 with 20% opacity */
            border-left-color: #3b82f6; /* blue-500 */
        }
        /* Style for highlighting the text area */
        #full-gcode-output.highlight-line-error {
            border-color: #ef4444; /* red-500 */
            box-shadow: 0 0 10px #ef444466;
        }
        #full-gcode-output.highlight-line-success {
            border-color: #2ecc71; /* green-500 */
            box-shadow: 0 0 10px #2ecc7166;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-inter antialiased">

    <div class="max-w-7xl mx-auto p-4 md:p-8">
        <h1 class="text-3xl font-bold text-center text-white mb-8">
            Coupled Arm Command Executor (End Effector Path)
        </h1>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <div class="lg:col-span-1 bg-gray-800 p-6 rounded-2xl shadow-xl space-y-6">
                
                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">1. Coordinates (G-Code or X,Y)</h2>
                    <p class="text-sm text-gray-400 mb-2">Enter G1 X... Y... or X, Y pairs.</p>
                    <textarea id="coords-input" rows="5" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-200 resize-none" placeholder="G1 X50 Y50&#10;G1 X0 Y0&#10;G1 X-50 Y80"></textarea>
                    <button id="add-coords-btn" class="mt-3 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">
                        Set Path & Calculate Motor Commands
                    </button>
                </div>
                
                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">2. Arm Parameters</h2>
                    <div class="space-y-2">
                        <div class="flex justify-between items-center">
                            <label class="text-gray-400">Arm 1 Length (L1):</label>
                            <input type="text" value="101.3 mm" disabled class="bg-gray-700 text-gray-300 px-3 py-1 rounded-md w-28 text-right">
                        </div>
                        <div class="flex justify-between items-center">
                            <label class="text-gray-400">Arm 2 Length (L2):</label>
                            <input type="text" value="101.3 mm" disabled class="bg-gray-700 text-gray-300 px-3 py-1 rounded-md w-28 text-right">
                        </div>
                        <div class="flex justify-between items-center pt-2">
                            <label class="text-gray-400">Gearing:</label>
                            <input type="text" value="A2 = M2 + (M1 / 8)" disabled class="bg-gray-700 text-gray-300 px-3 py-1 rounded-md w-auto text-right">
                        </div>
                         <div class="flex justify-between items-center pt-2">
                            <label class="text-gray-400">Motor Solver:</label>
                            <input type="text" value="M2 = A2 - (M1 / 8)" disabled class="bg-gray-700 text-gray-300 px-3 py-1 rounded-md w-auto text-right">
                        </div>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">3. Animation Control</h2>
                    <div class="flex items-center space-x-4">
                        <button id="play-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all duration-200">
                            Play
                        </button>
                        <input type="range" id="time-slider" min="0" max="1000" value="0" step="1" class="w-full">
                    </div>
                    <p class="text-sm text-gray-400 mt-3 p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                        <strong>Animation Logic:</strong> The animation executes the commands by interpolating in <strong>Cartesian (X, Y) space</strong>, then solving for joint angles at each tiny step. This results in the arm's end-effector following a <strong>straight path</strong> (solid white line) between your target points, matching the dashed target path.
                    </p>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">4. Motor Command List</h2>
                    <div id="command-list-container" class="max-h-60 overflow-y-auto bg-gray-900/50 p-3 rounded-lg border border-gray-700 text-sm space-y-2">
                        <p class="text-gray-400">Commands will appear here...</p>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">5. Live Motor Command Status</h2>
                    <div class="bg-gray-900/50 p-4 rounded-lg border border-gray-700 space-y-3">
                        <div class="flex justify-between items-center text-lg">
                            <span class="text-gray-300 font-medium">Motor 1 (Base) Remaining:</span>
                            <span id="m1-output" class="font-mono text-cyan-300 text-xl font-bold">0.00°</span>
                        </div>
                        <div class="flex justify-between items-center text-lg">
                            <span class="text-gray-300 font-medium">Motor 2 (Elbow) Remaining:</span>
                            <span id="m2-output" class="font-mono text-purple-300 text-xl font-bold">0.00°</span>
                        </div>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">6. G-Code Program & Sender</h2>
                    <div class="bg-gray-900/50 p-4 rounded-lg border border-gray-700 space-y-3">
                        <p class="text-sm text-gray-400">Full program. Click "Send" to send the next highlighted command to your server.</p>
                        <textarea id="full-gcode-output" rows="8" readonly class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg shadow-inner focus:outline-none text-gray-200 resize-y font-mono text-sm" placeholder="G-Code program will appear here..."></textarea>
                        
                        <div class="grid grid-cols-2 gap-3">
                            <button id="reset-gcode-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">
                                Reset
                            </button>
                            <button id="send-gcode-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200" disabled>
                                Send Next Command
                            </button>
                        </div>
                    </div>
                </div>

            </div>

            <div class="lg:col-span-2 bg-gray-800 p-4 rounded-2xl shadow-xl">
                <canvas id="ik-canvas"></canvas>
            </div>

        </div>
    </div>

    <script type="module">
        // == ARM PARAMETERS ==
        const L1 = 101.3;
        const L2 = 101.3;
        const MAX_REACH = L1 + L2;
        const GCODE_FACTOR = 360 / 3200; // G-Code conversion factor
        const CANVAS_WORLD_SIZE = MAX_REACH * 2;
        const HOME_POINT = { x: 0, y: 150 };
        let DYNAMIC_ANIMATION_SPEED = 4;
        const STEPS_PER_SEGMENT_INTERPOLATION = 50;

        // --- 1. SERVER URL UPDATED ---
        // This now points to your new manual-mode endpoint
       const SERVER_URL = '/send_single_gcode_line';

        // == DOM ELEMENTS ==
        const canvas = document.getElementById('ik-canvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('time-slider');
        const playBtn = document.getElementById('play-btn');
        const coordsInput = document.getElementById('coords-input');
        const addCoordsBtn = document.getElementById('add-coords-btn');
        const commandListContainer = document.getElementById('command-list-container');
        const m1Out = document.getElementById('m1-output');
        const m2Out = document.getElementById('m2-output');
        const gcodeTextArea = document.getElementById('full-gcode-output');
        const sendGcodeBtn = document.getElementById('send-gcode-btn');
        const resetGcodeBtn = document.getElementById('reset-gcode-btn');

        // == STATE ==
        let path = [];
        let commandList = [];
        let precalculatedPath = [];
        let isPlaying = false;
        let animationFrameId = null;
        let canvasSize = 500;
        let origin = { x: 0, y: 0 };
        let scale = 1.0;
        let lastHighlightedSegment = -1;
        let homeJointAngles = { a1: Math.PI/2, a2: 0 };
        let gcodeSendIndex = 0; // State for G-Code sending

        // == CORE FUNCTIONS ==
        // (IK, solveMotorCommands, setupCanvas, draw, etc. are unchanged)
        
        function shortestAngleDist(a0, a1) {
            const max = Math.PI * 2;
            const da = (a1 - a0) % max;
            return 2 * da % max - da;
        }

        function solveIK(targetX, targetY, previousA1, previousA2) {
            let x = targetX;
            let y = targetY;
            let clamped = false;

            const D_sq = x * x + y * y;
            let D = Math.sqrt(D_sq);

            if (D > MAX_REACH && D < MAX_REACH + 0.001) {
                D = MAX_REACH;
            }

            if (D > MAX_REACH) {
                clamped = true;
                const ratio = MAX_REACH / D; 
                x *= ratio; 
                y *= ratio; 
                D = MAX_REACH;
            }
            
            if (D < 0.1) { 
                const stableA1 = previousA1;
                const stableA2 = previousA2 + shortestAngleDist(previousA2, Math.PI);
                return { a1: stableA1, a2: stableA2, clamped: false };
            }

            let cos_a2 = (D_sq - L1 * L1 - L2 * L2) / (2 * L1 * L2);
            cos_a2 = Math.max(-1, Math.min(1, cos_a2)); 
            
            const a2_rad_up = Math.acos(cos_a2); 
            const a2_rad_down = -a2_rad_up;

            const k1_up = L1 + L2 * Math.cos(a2_rad_up);
            const k2_up = L2 * Math.sin(a2_rad_up);
            const a1_rad_up_raw = Math.atan2(y, x) - Math.atan2(k2_up, k1_up);

            const k1_down = L1 + L2 * Math.cos(a2_rad_down);
            const k2_down = L2 * Math.sin(a2_rad_down);
            const a1_rad_down_raw = Math.atan2(y, x) - Math.atan2(k2_down, k1_down);
            
            const a1_up_cont = previousA1 + shortestAngleDist(previousA1, a1_rad_up_raw);
            const a2_up_cont = previousA2 + shortestAngleDist(previousA2, a2_rad_up);
            
            const a1_down_cont = previousA1 + shortestAngleDist(previousA1, a1_rad_down_raw);
            const a2_down_cont = previousA2 + shortestAngleDist(previousA2, a2_rad_down);

            const cost_up = (a1_up_cont - previousA1)**2 + (a2_up_cont - previousA2)**2;
            const cost_down = (a1_down_cont - previousA1)**2 + (a2_down_cont - previousA2)**2;

            if (cost_up <= cost_down) {
                return { a1: a1_up_cont, a2: a2_up_cont, clamped, endX: x, endY: y };
            } else {
                return { a1: a1_down_cont, a2: a2_down_cont, clamped, endX: x, endY: y };
            }
        }
        
        function solveMotorCommands(a1, a2) {
            const m1 = a1;
            const m2 = a2 - (a1 / 8.0);
            return { m1, m2 };
        }

        function setupCanvas() {
            canvasSize = canvas.parentElement.clientWidth;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            origin.x = canvasSize / 2;
            origin.y = canvasSize / 2;
            scale = canvasSize / CANVAS_WORLD_SIZE;
            
            homeJointAngles = solveIK(HOME_POINT.x, HOME_POINT.y, Math.PI/2, 0);
            
            const homeMotorCommands = solveMotorCommands(homeJointAngles.a1, homeJointAngles.a2);
            precalculatedPath = [
                { 
                    x: HOME_POINT.x, 
                    y: HOME_POINT.y, 
                    ...homeJointAngles, 
                    ...homeMotorCommands, 
                    clamped: false, 
                    segment: -1, 
                    t_in_segment: 0 
                }
            ];
            draw();
        }

        function draw() {
            if (!ctx) return;

            const globalT_val = parseInt(slider.value);
            const state = precalculatedPath[Math.min(globalT_val, precalculatedPath.length - 1)];

            let a1, a2, clamped, endX, endY;
            let currentSegment = -1;
            let t_in_segment = 0;

            if (state && commandList.length > 0) {
                a1 = state.a1;
                a2 = state.a2;
                clamped = state.clamped;
                currentSegment = state.segment;
                t_in_segment = state.t_in_segment;
                endX = state.endX; 
                endY = state.endY; 
            } else {
                a1 = homeJointAngles.a1;
                a2 = homeJointAngles.a2;
                clamped = false;
                const j1_x_home = L1 * Math.cos(homeJointAngles.a1);
                const j1_y_home = L1 * Math.sin(homeJointAngles.a1);
                endX = j1_x_home + L2 * Math.cos(homeJointAngles.a1 + homeJointAngles.a2);
                endY = j1_y_home + L2 * Math.sin(homeJointAngles.a1 + homeJointAngles.a2);
            }
            
            if (currentSegment !== -1 && commandList.length > currentSegment) {
                const command = commandList[currentSegment];
                const remainingT = 1.0 - t_in_segment;
                
                const m1Remaining = command.m1_delta_deg * remainingT; // Base
                const m2Remaining = command.m2_delta_deg * remainingT; // Elbow

                m1Out.textContent = m1Remaining.toFixed(2) + '°';
                m2Out.textContent = m2Remaining.toFixed(2) + '°';

            } else {
                m1Out.textContent = '0.00°';
                m2Out.textContent = '0.00°';
            }
            
            highlightCommand(currentSegment);

            ctx.clearRect(0, 0, canvasSize, canvasSize);
            ctx.save();
            ctx.translate(origin.x, origin.y);
            ctx.scale(scale, -scale);
            
            const line_width_scaled = 2 / scale;
            const joint_radius_scaled = 5 / scale;
            const end_effector_radius_scaled = 6 / scale;

            ctx.strokeStyle = "#4b5563"; 
            ctx.lineWidth = 1 / scale;
            ctx.beginPath();
            const gridMax = CANVAS_WORLD_SIZE / 2;
            for (let i = -gridMax; i <= gridMax; i += 50) {
                ctx.moveTo(i, -gridMax); ctx.lineTo(i, gridMax);
                ctx.moveTo(-gridMax, i); ctx.lineTo(gridMax, i);
            }
            ctx.stroke();

            ctx.strokeStyle = "#9ca3af";
            ctx.lineWidth = line_width_scaled;
            ctx.beginPath();
            ctx.moveTo(-gridMax, 0); ctx.lineTo(gridMax, 0);
            ctx.moveTo(0, -gridMax); ctx.lineTo(0, gridMax);
            ctx.stroke();
            
            if (path.length > 0) {
                ctx.strokeStyle = "#3b82f6"; 
                ctx.lineWidth = line_width_scaled;
                ctx.setLineDash([5 / scale, 5 / scale]);
                ctx.beginPath();
                ctx.moveTo(HOME_POINT.x, HOME_POINT.y);
                path.forEach(p => ctx.lineTo(p.x, p.y)); 
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = "#3b82f6";
                [HOME_POINT, ...path].forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, joint_radius_scaled, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            
            const j1_x = L1 * Math.cos(a1);
            const j1_y = L1 * Math.sin(a1);
            const j2_x = endX;
            const j2_y = endY;

            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; 
            ctx.lineWidth = line_width_scaled;
            ctx.beginPath();
            if (precalculatedPath.length > 0) {
                for(let i=0; i <= globalT_val; i++) {
                    if (!precalculatedPath[i]) continue;
                    const p = precalculatedPath[i];
                    if (i === 0) ctx.moveTo(p.endX, p.endY);
                    else ctx.lineTo(p.endX, p.endY);
                }
            }
            ctx.stroke();

            ctx.strokeStyle = "white";
            ctx.lineWidth = 6 / scale;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(j1_x, j1_y);
            ctx.stroke();
            
            ctx.strokeStyle = "#2dd4bf";
            ctx.lineWidth = 6 / scale;
            ctx.beginPath();
            ctx.moveTo(j1_x, j1_y);
            ctx.lineTo(j2_x, j2_y);
            ctx.stroke();
            
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(0, 0, joint_radius_scaled * 1.5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(j1_x, j1_y, joint_radius_scaled, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = "#2dd4bf";
            if (clamped) { 
                ctx.fillStyle = "#ef4444";
            }
            ctx.beginPath();
            ctx.arc(j2_x, j2_y, end_effector_radius_scaled, 0, 2 * Math.PI);
            ctx.fill();

            ctx.restore();
        }

        function parseCoordinates() {
            addCoordsBtn.textContent = "Calculating...";
            addCoordsBtn.disabled = true;

            setTimeout(() => {
                const text = coordsInput.value;
                
                path = text.split('\n')
                    .filter(line => line.trim() !== '')
                    .map(line => {
                        line = line.trim();
                        const gcodeMatch = line.match(/X\s*(-?[\d.]+)\s+Y\s*(-?[\d.]+)/i);
                        if (gcodeMatch && gcodeMatch[1] != null && gcodeMatch[2] != null) {
                            const x = parseFloat(gcodeMatch[1]);
                            const y = parseFloat(gcodeMatch[2]);
                            if (!isNaN(x) && !isNaN(y)) return { x, y };
                        }
                        const commaMatch = line.match(/^(-?[\d.]+)\s*,\s*(-?[\d.]+)$/);
                        if (commaMatch && commaMatch[1] != null && commaMatch[2] != null) {
                            const x = parseFloat(commaMatch[1]);
                            const y = parseFloat(commaMatch[2]);
                            if (!isNaN(x) && !isNaN(y)) return { x, y };
                        }
                        return null;
                    })
                    .filter(p => p !== null);

                
                commandList = [];
                if (path.length === 0) {
                    updateCommandListUI();
                    updateFullGcodeOutput(); 
                    stopAnimation();
                    slider.value = "0";
                    slider.max = 1;
                    homeJointAngles = solveIK(HOME_POINT.x, HOME_POINT.y, Math.PI/2, 0);
                    const homeMotorCommands = solveMotorCommands(homeJointAngles.a1, homeJointAngles.a2);
                    precalculatedPath = [
                        { x: HOME_POINT.x, y: HOME_POINT.y, ...homeJointAngles, ...homeMotorCommands, clamped: false, segment: -1, t_in_segment: 0 }
                    ];
                    draw();
                } else {
                    const pointList = [HOME_POINT, ...path];
                    let previousA1 = homeJointAngles.a1;
                    let previousA2 = homeJointAngles.a2;
                    precalculatedPath = [];
                    
                    for (let i = 0; i < pointList.length - 1; i++) {
                        const p_start = pointList[i];
                        const p_end = pointList[i+1];
                        let segmentName = (i === 0) ? `HOME -> P0` : `P${i-1} -> P${i}`;
                        let segmentStartM1 = 0, segmentStartM2 = 0;

                        for (let step = 0; step <= STEPS_PER_SEGMENT_INTERPOLATION; step++) {
                            const t_in_segment = step / STEPS_PER_SEGMENT_INTERPOLATION;
                            const interpolatedX = p_start.x + (p_end.x - p_start.x) * t_in_segment;
                            const interpolatedY = p_start.y + (p_end.y - p_start.y) * t_in_segment;
                            const { a1, a2, clamped, endX, endY } = solveIK(interpolatedX, interpolatedY, previousA1, previousA2);
                            const { m1, m2 } = solveMotorCommands(a1, a2);
                            if (step === 0) { segmentStartM1 = m1; segmentStartM2 = m2; }
                            precalculatedPath.push({ x: interpolatedX, y: interpolatedY, a1, a2, m1, m2, clamped, segment: i, t_in_segment, endX, endY });
                            previousA1 = a1; previousA2 = a2;
                        }
                        
                        const finalSegmentPoint = precalculatedPath[precalculatedPath.length - 1];
                        const m1_delta = finalSegmentPoint.m1 - segmentStartM1;
                        const m2_delta = finalSegmentPoint.m2 - segmentStartM2;

                        commandList.push({
                            segment: segmentName,
                            m1_delta_deg: m1_delta * 180 / Math.PI,
                            m2_delta_deg: m2_delta * 180 / Math.PI,
                            clamped: finalSegmentPoint.clamped
                        });
                    }
                    
                    slider.max = precalculatedPath.length - 1;
                    DYNAMIC_ANIMATION_SPEED = Math.max(1, Math.ceil((precalculatedPath.length -1) / 250)); 
                    stopAnimation();
                    slider.value = "0";
                    lastHighlightedSegment = -1;
                    draw();
                }

                updateCommandListUI();
                updateFullGcodeOutput();
                gcodeSendIndex = 0;
                updateSendButtonState();
                highlightGcodeTextareaLine(gcodeSendIndex);

                addCoordsBtn.textContent = "Set Path & Calculate Motor Commands";
                addCoordsBtn.disabled = false;
            }, 10);
        }

        function updateCommandListUI() {
            commandListContainer.innerHTML = '';
            if (commandList.length === 0) {
                commandListContainer.innerHTML = '<p class="text-gray-400">Add 1 or more points to create a path from HOME.</p>';
                return;
            }
            commandList.forEach((cmd, i) => {
                const el = document.createElement('div');
                el.id = `command-segment-${i}`;
                el.className = 'command-item p-2 rounded-md';
                const m1Sign = cmd.m1_delta_deg >= 0 ? '+' : '';
                const m2Sign = cmd.m2_delta_deg >= 0 ? '+' : '';
                el.innerHTML = `
                    <div class="font-bold text-white">${i}: ${cmd.segment} ${cmd.clamped ? '<span class="text-red-400 font-normal">(Out of reach)</span>' : ''}</div>
                    <div class="font-mono text-sm ml-4 flex flex-col">
                        <span class="text-cyan-300">Motor 1 (Base): ${m1Sign}${cmd.m1_delta_deg.toFixed(2)}°</span>
                        <span class="text-purple-300">Motor 2 (Elbow): ${m2Sign}${cmd.m2_delta_deg.toFixed(2)}°</span>
                    </div>
                `;
                commandListContainer.appendChild(el);
            });
        }

        function updateFullGcodeOutput() {
            if (commandList.length === 0) {
                gcodeTextArea.value = 'G-Code program will appear here...';
                return;
            }
            const gcodeCommands = commandList.map(cmd => {
                const base_gcode = cmd.m1_delta_deg * GCODE_FACTOR;
                const elbow_gcode = cmd.m2_delta_deg * GCODE_FACTOR;
                return `G1 ${elbow_gcode.toFixed(3)} ${base_gcode.toFixed(3)} 1000`;
            }).join('\n');
            gcodeTextArea.value = gcodeCommands;
        }


        function highlightCommand(segmentIndex) {
            if (segmentIndex === lastHighlightedSegment) return; 
            if (lastHighlightedSegment !== -1) {
                const oldEl = document.getElementById(`command-segment-${lastHighlightedSegment}`);
                if (oldEl) oldEl.classList.remove('highlight');
            }
            if (segmentIndex !== -1 && commandList.length > segmentIndex) {
                const newEl = document.getElementById(`command-segment-${segmentIndex}`);
                if (newEl) {
                    newEl.classList.add('highlight');
                    newEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            lastHighlightedSegment = segmentIndex;
        }
        
        // --- G-CODE SENDER LOGIC ---

        function highlightGcodeTextareaLine(index) {
            if (commandList.length === 0 || index < 0 || index >= commandList.length) {
                gcodeTextArea.blur();
                return;
            }
            
            const lines = gcodeTextArea.value.split('\n');
            let start = 0;
            for(let i=0; i < index; i++) {
                start += lines[i].length + 1; // +1 for the \n
            }
            const end = start + lines[index].length;
            
            gcodeTextArea.focus();
            gcodeTextArea.setSelectionRange(start, end);
            gcodeTextArea.scrollTop = gcodeTextArea.offsetHeight * (index / lines.length);
        }

        function updateSendButtonState() {
            if (commandList.length === 0 || gcodeSendIndex >= commandList.length) {
                sendGcodeBtn.disabled = true;
                sendGcodeBtn.textContent = (commandList.length > 0) ? 'All Sent' : 'Send Next Command';
            } else {
                sendGcodeBtn.disabled = false;
                sendGcodeBtn.textContent = `Send (${gcodeSendIndex + 1}/${commandList.length})`;
            }
        }

        async function sendNextGcode() {
            if (gcodeSendIndex >= commandList.length) {
                console.log("No more commands to send.");
                return;
            }

            // Get the G-code string directly from the text area line
            const gcodeString = gcodeTextArea.value.split('\n')[gcodeSendIndex];

            sendGcodeBtn.disabled = true;
            sendGcodeBtn.textContent = 'Sending...';
            
            gcodeTextArea.classList.remove('highlight-line-success', 'highlight-line-error');

            try {
                const response = await fetch(SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // --- 2. JSON BODY UPDATED ---
                    // This now uses "gcode_line" to match your Python code
                    body: JSON.stringify({ gcode_line: gcodeString })
                });

                const result = await response.json(); // Get JSON response from server

                if (!response.ok || !result.success) {
                    throw new Error(result.error || `Server error: ${response.statusText}`);
                }

                console.log('Server response:', result);
                
                // Success
                gcodeTextArea.classList.add('highlight-line-success');
                highlightCommand(gcodeSendIndex); // Highlight in Section 4
                gcodeSendIndex++; // Move to next command
                
            } catch (error) {
                console.error('Error sending command:', error);
                alert(`Failed to send command.\nIs the Python server running?\nError: ${error.message}`);
                gcodeTextArea.classList.add('highlight-line-error');
            }
            
            updateSendButtonState();
            if (gcodeSendIndex < commandList.length) {
                highlightGcodeTextareaLine(gcodeSendIndex); // Highlight next line
            }
        }

        // --- (Animation loop, stop, play logic is unchanged) ---
        
        function animationLoop() {
            if (!isPlaying) return;
            let currentVal = parseInt(slider.value);
            currentVal += DYNAMIC_ANIMATION_SPEED; 
            if (currentVal >= slider.max) { 
                currentVal = slider.max;
                stopAnimation();
            }
            slider.value = currentVal;
            draw();
            animationFrameId = requestAnimationFrame(animationLoop);
        }

        function stopAnimation() {
            isPlaying = false;
            playBtn.textContent = 'Play';
            playBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            playBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            draw();
        }
        
        function togglePlay() {
            if (commandList.length === 0) return; 
            if (isPlaying) {
                stopAnimation();
            } else {
                if (parseInt(slider.value) >= slider.max) { 
                    slider.value = "0";
                    lastHighlightedSegment = -1; 
                }
                isPlaying = true;
                playBtn.textContent = 'Pause';
                playBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                playBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                animationFrameId = requestAnimationFrame(animationLoop);
            }
        }

        // == EVENT LISTENERS ==
        window.addEventListener('load', () => {
            coordsInput.value = `G1 X-202.600 Y-202.600
G1 X-192.247 Y-202.600
G1 X-202.600 Y-163.963
G1 X-202.600 Y-125.326
G1 X-181.894 Y-202.600
G1 X-171.542 Y-202.600
G1 X-202.600 Y-86.689
G1 X-202.600 Y-48.052
GS1 X-161.189 Y-202.600
G1 X-150.836 Y-202.600
G1 X-202.600 Y-9.415
G1 X-202.600 Y29.222
G1 X-140.483 Y-202.600
G1 X-130.131 Y-202.600
G1 X-202.600 Y67.859
G1 X-202.600 Y106.496
G1 X-119.778 Y-202.600
G1 X-109.425 Y-202.600
G1 X-202.600 Y145.133
G1 X-202.600 Y183.770
G1 X-99.072 Y-202.600
G1 X-88.720 Y-202.600
G1 X-197.293 Y202.600
G1 X-186.940 Y202.600
G1 X-78.367 Y-202.600
G1 X-68.014 Y-202.600
G1 X-176.587 Y202.600
G1 X-166.234 Y202.600
G1 X-57.661 Y-202.600
G1 X-47.309 Y-202.600
G1 X-155.882 Y202.600
G1 X-145.529 Y202.600
G1 X-36.956 Y-202.600
G1 X-26.603 Y-202.600
G1 X-135.176 Y202.600
G1 X-124.823 Y202.600
G1 X-16.250 Y-202.600
G1 X-5.898 Y-202.600
G1 X-114.471 Y202.600
G1 X-104.118 Y202.600
G1 X4.455 Y-202.600
G1 X14.808 Y-202.600
G1 X-93.765 Y202.600
G1 X-83.412 Y202.600
G1 X25.161 Y-202.600
G1 X35.514 Y-202.600
G1 X-73.059 Y202.600
G1 X-62.707 Y202.600
G1 X45.866 Y-202.600
G1 X56.219 Y-202.600
G1 X-52.354 Y202.600
G1 X-42.001 Y202.600
G1 X66.572 Y-202.600
G1 X76.925 Y-202.600
G1 X-31.648 Y202.600
G1 X-21.296 Y202.600
G1 X87.277 Y-202.600
G1 X97.630 Y-202.600
G1 X-10.943 Y202.600
G1 X-0.590 Y202.600
G1 X107.983 Y-202.600
G1 X118.336 Y-202.600
G1 X9.763 Y202.600
G1 X20.115 Y202.600
G1 X128.688 Y-202.600
G1 X139.041 Y-202.600
G1 X30.468 Y202.600
G1 X40.821 Y202.600
G1 X149.394 Y-202.600
G1 X159.747 Y-202.600
G1 X51.174 Y202.600
G1 X61.526 Y202.600
G1 X170.099 Y-202.600
G1 X180.452 Y-202.600
G1 X71.879 Y202.600
G1 X82.232 Y202.600
G1 X190.805 Y-202.600
G1 X201.158 Y-202.600
G1 X92.585 Y202.600
G1 X102.937 Y202.600
G1 X202.600 Y-169.346
G1 X202.600 Y-130.709
G1 X113.290 Y202.600
G1 X123.643 Y202.600
G1 X202.600 Y-92.072
G1 X202.600 Y-53.435
G1 X133.996 Y202.600
G1 X144.349 Y202.Type="text"
G1 X202.600 Y-14.798
G1 X202.600 Y23.840
G1 X154.701 Y202.600
G1 X165.054 Y202.600
G1 X202.600 Y62.477
G1 X202.600 Y101.114
G1 X175.407 Y202.600
G1 X185.760 Y202.600
G1 X202.600 Y139.751
GBlock"
G1 X196.112 Y202.600`;
            setupCanvas();
            parseCoordinates();
        });

        window.addEventListener('resize', setupCanvas);
        addCoordsBtn.addEventListener('click', parseCoordinates);
        slider.addEventListener('input', () => { draw(); });
        playBtn.addEventListener('click', togglePlay);

        // G-Code button listeners
        sendGcodeBtn.addEventListener('click', sendNextGcode);
        
        resetGcodeBtn.addEventListener('click', () => {
            gcodeSendIndex = 0;
            updateSendButtonState();
            highlightGcodeTextareaLine(0);
            highlightCommand(-1); // Clear section 4 highlight
            gcodeTextArea.classList.remove('highlight-line-success', 'highlight-line-error');
            console.log("Reset send index to 0.");
        });

    </script>
</body>
</html>
