<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2DOF Arm Kinematic Simulator & G-Code Converter</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
body {
    font-family: 'Inter', sans-serif;
}
canvas {
    width: 100%;
    /* height: 100%; <-- THIS LINE WAS REMOVED */
    aspect-ratio: 1/1;
    display: block;
    border-radius: 0.5rem;
}
textarea {
    scrollbar-width: thin;
    scrollbar-color: #4b5563 #1f2937;
}
input[type=number]::-webkit-inner-spin-button,
input[type=number]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
}
input[type=number] {
    -moz-appearance: textfield;
}

/* Main Buttons: Indigo */
#convertGCodeBtn, #loadCommandsBtn, #alert-modal button {
    background-color: #4f46e5; /* bg-indigo-600 */
}
#convertGCodeBtn:hover, #loadCommandsBtn:hover, #alert-modal button:hover {
    background-color: #4338ca; /* bg-indigo-700 */
}
/* Playback Buttons */
#playBtn { background-color: #0d9488; } /* bg-teal-600 */
#playBtn:hover { background-color: #0f766e; } /* bg-teal-700 */
#playLoopBtn { background-color: #4f46e5; } /* bg-indigo-600 */
#playLoopBtn:hover { background-color: #4338ca; } /* bg-indigo-700 */
#pauseBtn { background-color: #f97316; } /* bg-orange-500 */
#pauseBtn:hover { background-color: #ea580c; } /* bg-orange-600 */
</style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased">

<div class="max-w-7xl mx-auto p-4 lg:p-8">
    <header class="mb-6">
        <h1 class="text-3xl font-bold text-white">2DOF Arm Kinematic Simulator & G-Code Converter</h1>
        <p class="text-lg text-gray-400">Simulating a 2-motor arm with 101.3mm links and 9/8 gearing.</p>
    </header>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        
        <div class="lg:col-span-1 bg-gray-800 p-6 rounded-xl shadow-lg flex flex-col gap-6">
            
            <div class="bg-gray-900 p-4 rounded-lg border border-gray-700">
                <label for="gcodeConverterInput" class="block text-sm font-medium text-gray-300 mb-2">
                    1. Paste Cartesian (X, Y) G-Code
                </label>
                <textarea id="gcodeConverterInput" rows="8" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-gray-200 font-mono text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., G1 X100 Y100"></textarea>
                
                <div class="grid grid-cols-2 gap-3 mt-4">
                    <div>
                        <label for="gcodeCenterX" class="block text-xs font-medium text-gray-400">G-Code Center X</label>
                        <input type="number" id="gcodeCenterX" value="202.6" class="w-full mt-1 p-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-200 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="gcodeCenterY" class="block text-xs font-medium text-gray-400">G-Code Center Y</label>
                        <input type="number" id="gcodeCenterY" value="202.6" class="w-full mt-1 p-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-200 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-3 mt-4">
                    <div>
                        <label for="stepDelayInput" class="block text-xs font-medium text-gray-400">Delay (μs)</label>
                        <input type="number" id="stepDelayInput" value="1000" class="w-full mt-1 p-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-200 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="smoothingSensitivity" class="block text-xs font-medium text-gray-400">Smooth (ε)</label>
                        <input type="number" id="smoothingSensitivity" value="0.000001" step="0.000001" class="w-full mt-1 p-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-200 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>
                <button id="convertGCodeBtn" class="w-full mt-4 font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md">
                    Convert, Smooth & Load
                </button>
            </div>
            <div>
                <label for="commandsInput" class="block text-sm font-medium text-gray-300 mb-2">
                    2. Arm Commands (G1 Elbow Base StepDelay_μs)
                </label>
                <textarea id="commandsInput" rows="8" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-gray-200 font-mono text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., G1 0 800 1000&#10;G1 1600 0 500&#10;..."></textarea>
Example G-Code (Hilbert Curve):
G1 X100 Y100
...
            </div>

            <button id="loadCommandsBtn" class="w-full text-white font-semibold py-2 px-4 rounded-lg transition duration-200 shadow-md">
                Load & Reset Simulation
            </button>

            <div>
                <label class="block text-sm font-medium text-gray-300 mb-2">Playback</label>
                <div class="flex items-center gap-4 mb-2">
                    <button id="playBtn" class="text-white p-2 rounded-full disabled:opacity-50" title="Step Forward">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8.002v3.996a1 1 0 001.555.832l3.197-1.998a1 1 0 000-1.664l-3.197-1.998z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    
                    <button id="playLoopBtn" class="text-white p-2 rounded-full disabled:opacity-50" title="Play and Loop">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.89.633A5.002 5.002 0 005.001 9.029V11a1 1 0 11-2 0V3a1 1 0 011-1zm12 14a1 1 0 01-1 1v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 111.89-.633A5.002 5.002 0 0014.999 10.97V9a1 1 0 112 0v8a1 1 0 01-1 1z" clip-rule="evenodd" />
                        </svg>
                    </button>

                    <button id="pauseBtn" class="text-white p-2 rounded-full" title="Pause">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9 6a1 1 0 00-1 1v6a1 1 0 002 0V7a1 1 0 00-1-1zm2 0a1 1 0 00-1 1v6a1 1 0 002 0V7a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <span id="stepDisplay" class="font-mono text-sm text-gray-400">Step: 0 / 0</span>
                </div>
                <input id="commandSlider" type="range" min="0" max="0" value="0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50">
            </div>
            
        </div>

        <div class="lg:col-span-2 flex flex-col gap-6">
            
            <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
                <canvas id="armCanvas" class="bg-gray-900"></canvas>
            </div>
            
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const canvas = document.getElementById('armCanvas');
        const ctx = canvas.getContext('2d');
        const commandsInput = document.getElementById('commandsInput');
        const loadCommandsBtn = document.getElementById('loadCommandsBtn');
        const commandSlider = document.getElementById('commandSlider');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const playLoopBtn = document.getElementById('playLoopBtn');
        const stepDisplay = document.getElementById('stepDisplay');
        
        // Converter DOM elements
        const gcodeConverterInput = document.getElementById('gcodeConverterInput');
        const convertGCodeBtn = document.getElementById('convertGCodeBtn');
        const stepDelayInput = document.getElementById('stepDelayInput');
        const smoothingSensitivity = document.getElementById('smoothingSensitivity');
        
        // *** NEW: Offset Elements ***
        // (Note: The elements gcodeCenterX and gcodeCenterY are fetched inside convertGCode)
        // *** END NEW ***

        // --- Simulation Constants ---
        const L1 = 101.3; // mm (Upper arm)
        const L2 = 101.3; // mm (Lower arm)
        const GEAR_RATIO = 9 / 8; // 1.125
        
        const STEPS_PER_DEG = 3200 / 360;
        const STEPS_PER_RAD = (3200 / 360) * (180 / Math.PI); // 1600 / PI

        // --- Simulation State ---
        let commands = []; // List of {base, elbow} steps
        let cumulativeStates = []; // List of all arm states (pos, angles)
        let currentStep = 0; // The index of the *target* state
        let isAutoPlaying = false;
        let isLooping = false;
        
        let animationFrameId = null;
        let animationStartTime = 0;
        let animationFromState = null;
        let animationToState = null;
        
        let origin = { x: 0, y: 0 };
        let worldScale = 1; // pixels per mm
        let tracePath = [];
        
        const lerp = (a, b, t) => a + (b - a) * t;

        // --- Core Functions ---

        function init() {
            // Set up event listeners
            loadCommandsBtn.addEventListener('click', loadCommands);

            commandSlider.addEventListener('input', (e) => {
                isLooping = false;
                handleSliderInput(e);
            });
            playBtn.addEventListener('click', () => {
                isLooping = false; 
                playFrame(); // "Step Forward"
            });
            pauseBtn.addEventListener('click', () => {
                isLooping = false;
                pause();
            });
            playLoopBtn.addEventListener('click', playLoop);
            
            window.addEventListener('resize', debounce(resizeAndRedraw, 250));
            
            // Converter listener
            convertGCodeBtn.addEventListener('click', convertGCode);
            
            // Initial setup
            resizeCanvas();
            loadCommands(); // Load default commands from textarea
        }

        function resizeCanvas() {
            const parent = canvas.parentElement;
            const parentWidth = parent.clientWidth;
            const size = parentWidth > 32 ? parentWidth - 32 : parentWidth;
            
            canvas.width = size;
            canvas.height = size;
            origin.x = canvas.width / 2;
            origin.y = canvas.height / 2;
            
            const maxReach = (L1 + L2) * 1.1;
            worldScale = Math.min(canvas.width, canvas.height) / (maxReach * 2);

            ctx.resetTransform();
            ctx.translate(origin.x, origin.y);
            ctx.scale(worldScale, -worldScale); // Scale and flip Y
        }

        function resizeAndRedraw() {
            resizeCanvas();
            if (cumulativeStates.length > 0) {
                drawState(currentStep);
            }
        }

        // --- G-Code Converter Functions ---

        // *** --- MODIFIED FUNCTION --- ***
        /**
         * Converts G-code (X, Y) to arm commands, applying a center offset.
         */
        function convertGCode() {
            const gcodeText = gcodeConverterInput.value;
            const lines = gcodeText.split('\n');
            const xyRegex = /G1\s+X(-?[\d.]+)\s+Y(-?[\d.]+)/i;
            
            // *** NEW: Get offset values ***
            const gcodeCenterX = parseFloat(document.getElementById('gcodeCenterX').value) || 0;
            const gcodeCenterY = parseFloat(document.getElementById('gcodeCenterY').value) || 0;
            
            let coords = [];

            // --- 1. Parse all coords and apply offset ---
            for (const line of lines) {
                const match = line.trim().match(xyRegex);
                if (match) {
                    const x_gcode = parseFloat(match[1]);
                    const y_gcode = parseFloat(match[2]);
                    
                    // Apply the offset to re-center the pattern
                    const x_cart = x_gcode - gcodeCenterX;
                    const y_cart = y_gcode - gcodeCenterY;
                    
                    coords.push({ x: x_cart, y: y_cart });
                }
            }
            // *** END MODIFICATION ***

            if (coords.length < 2) {
                 if(coords.length === 1) { /* Just one point, not enough for a line */ }
                 else {
                    showModal("No valid 'G1 X... Y...' commands found.");
                    return;
                 }
            }

            // --- 2. Pre-process coords to remove co-linear points ---
            const collinearity_epsilon = 1e-6;
            let reducedCoords = [];
            
            if (coords.length > 0) {
                reducedCoords.push(coords[0]);
            }

            let p1_index = 0;
            let p2_index = 1;

            while (p2_index < coords.length) {
                const p1 = coords[p1_index];
                const p2 = coords[p2_index];

                if (p2_index === coords.length - 1) {
                    reducedCoords.push(p2);
                    break;
                }
                
                const p3 = coords[p2_index + 1];
                const cross_product = (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y);

                if (Math.abs(cross_product) < collinearity_epsilon) {
                    p2_index++;
                } else {
                    reducedCoords.push(p2);
                    p1_index = p2_index;
                    p2_index++;
                }
            }

            // --- 3. Convert *reduced* coords to relative arm commands ---
            let generatedCommands = [];
            
            const first_coord = reducedCoords[0];
            let start_theta1;

            if (Math.hypot(first_coord.x, first_coord.y) < 0.1) {
                start_theta1 = 0;
            } else {
                start_theta1 = Math.atan2(first_coord.y, first_coord.x);
            }

            const start_alpha_rad = start_theta1;
            const start_beta_rad = GEAR_RATIO * start_alpha_rad;
            let prev_base_steps = Math.round(-start_alpha_rad * STEPS_PER_RAD);
            let prev_elbow_steps = Math.round(-start_beta_rad * STEPS_PER_RAD);

            const step_delay_us = parseInt(stepDelayInput.value, 10) || 1000;
            
            try {
                for (const coord of reducedCoords) {
                    const curr_x = coord.x;
                    const curr_y = coord.y;

                    const { base_steps, elbow_steps } = calculateIK(curr_x, curr_y, prev_base_steps);
                    
                    const rel_base = Math.round(base_steps - prev_base_steps);
                    const rel_elbow = Math.round(elbow_steps - prev_elbow_steps);
                    
                    if (rel_base !== 0 || rel_elbow !== 0) {
                        generatedCommands.push({ elbow: rel_elbow, base: rel_base, delay: step_delay_us });
                    }

                    prev_base_steps = base_steps;
                    prev_elbow_steps = elbow_steps;
                }
            } catch (e) {
                showModal(`Conversion Error: ${e.message}`);
                return;
            }

            // --- 4. Smooth the commands ---
            let commandsToSmooth = generatedCommands;
            let smoothedCommands = [];
            let lastLength = -1; 
            const sensitivity = parseFloat(smoothingSensitivity.value) || 1e-6;

            while (smoothedCommands.length !== lastLength) {
                lastLength = commandsToSmooth.length;
                smoothedCommands = smoothCommands(commandsToSmooth, sensitivity);
                commandsToSmooth = smoothedCommands;
            }

            // --- 5. Load into simulator ---
            const commandStrings = smoothedCommands.map(cmd => `G1 ${cmd.elbow} ${cmd.base} ${cmd.delay}`);
            commandsInput.value = commandStrings.join('\n');
            loadCommandsBtn.click();
        }
        // *** --- END MODIFIED FUNCTION --- ***


        /**
         * Combines consecutive commands with the same ratio and speed.
         */
        function smoothCommands(commands, sensitivity) {
            if (commands.length === 0) {
                return [];
            }

            const smoothedCommands = [];
            let current_command = { ...commands[0] };

            for (let i = 1; i < commands.length; i++) {
                const next_command = commands[i];
                
                let canCombine = false;
                
                if (current_command.delay === next_command.delay) {
                    const cmd1 = current_command;
                    const cmd2 = next_command;

                    if (cmd1.base === 0 && cmd2.base === 0) {
                        canCombine = true;
                    } 
                    else if (cmd1.elbow === 0 && cmd2.elbow === 0) {
                        canCombine = true;
                    }
                    else if (cmd1.base !== 0 && cmd2.base !== 0 && cmd1.elbow !== 0 && cmd2.elbow !== 0) {
                        const ratio1 = cmd1.elbow / cmd1.base;
                        const ratio2 = cmd2.elbow / cmd2.base;
                        
                        if (Math.abs(ratio1 - ratio2) < sensitivity) {
                            canCombine = true;
                        }
                    }
                }

                if (canCombine) {
                    current_command.elbow += next_command.elbow;
                    current_command.base += next_command.base;
                } else {
                    if (current_command.elbow !== 0 || current_command.base !== 0) {
                        smoothedCommands.push(current_command);
                    }
                    current_command = { ...next_command };
                }
            }
            
            if (current_command.elbow !== 0 || current_command.base !== 0) {
                smoothedCommands.push(current_command);
            }
            
            return smoothedCommands;
        }


        /**
         * Inverse Kinematics: Calculates arm motor steps from (X, Y) position.
         */
        function calculateIK(x, y, last_base_steps = 0) {
            let D = Math.hypot(x, y);
            const arm_max_reach = L1 + L2;
            let clamped_x = x;
            let clamped_y = y;

            if (D > arm_max_reach) { 
                clamped_x = x * arm_max_reach / D;
                clamped_y = y * arm_max_reach / D;
                D = arm_max_reach;
            }

            let theta1, theta_bend;

            if (D < 0.1) {
                theta_bend = -Math.PI;
                const alpha_rad = -last_base_steps / STEPS_PER_RAD;
                theta1 = alpha_rad;
                clamped_x = 0;
                clamped_y = 0;
            } else {
                const D_sq = D*D;
                let cos_theta_bend = (D_sq - L1*L1 - L2*L2) / (2 * L1 * L2);
                cos_theta_bend = Math.max(-1, Math.min(1, cos_theta_bend)); 
                
                theta_bend = -Math.acos(cos_theta_bend);

                const k1 = L1 + L2 * Math.cos(theta_bend);
                const k2 = L2 * Math.sin(theta_bend);
                
                let raw_theta1 = Math.atan2(clamped_y, clamped_x) - Math.atan2(k2, k1);

                const last_theta1 = -last_base_steps / STEPS_PER_RAD;
                let rotation_diff = (raw_theta1 - last_theta1) / (2 * Math.PI);
                let nearest_rotation_offset = Math.round(rotation_diff);
                theta1 = raw_theta1 - (nearest_rotation_offset * 2 * Math.PI);
            }

            const alpha_rad = theta1;
            const beta_rad = theta_bend + (GEAR_RATIO * alpha_rad);

            const base_steps = -alpha_rad * STEPS_PER_RAD;
            const elbow_steps = -beta_rad * STEPS_PER_RAD;

            return { 
                base_steps: base_steps, 
                elbow_steps: elbow_steps,
                clamped_x: clamped_x,
                clamped_y: clamped_y
            };
        }
        // --- END: G-Code Converter Functions ---


        /**
         * Parses commands from the textarea, calculates all states, and resets the UI.
         */
        function loadCommands() {
            pause();
            
            const text = commandsInput.value;
            
            commands = text.split('\n')
                .filter(line => line.trim().startsWith('G1'))
                .map(line => {
                    const parts = line.trim().substring(2).trim().split(/\s+/).map(s => parseInt(s.trim(), 10));
                    return { 
                        elbow: parts[0] || 0, 
                        base: parts[1] || 0, 
                        step_delay_us: parts[2] !== undefined ? parts[2] : 1000 
                    };
                });

            calculateAllStates();
            calculateTracePath();
            
            commandSlider.max = cumulativeStates.length - 1;
            commandSlider.value = 0;
            currentStep = 0;
            
            drawState(0);
            setControlsEnabled(cumulativeStates.length > 1);
        }

        function setControlsEnabled(enabled) {
            playBtn.disabled = !enabled;
            playLoopBtn.disabled = !enabled;
            commandSlider.disabled = !enabled;
        }

        /**
         * Pre-calculates the arm's position and angles for every step.
         */
        function calculateAllStates() {
            cumulativeStates = [];
            let total_base_steps = 0;
            let total_elbow_steps = 0;
            const p0 = { x: 0, y: 0 };

            cumulativeStates.push(calculateFK(p0, 0, 0));

            for (const cmd of commands) {
                total_base_steps += cmd.base;
                total_elbow_steps += cmd.elbow;
                
                const state = calculateFK(p0, total_base_steps, total_elbow_steps);
                state.command = cmd;
                cumulativeStates.push(state);
            }
        }

        /**
         * Pre-calculates the high-resolution path for the trace line.
         */
        function calculateTracePath() {
            tracePath = [];
            if (cumulativeStates.length < 2) return;

            tracePath.push(cumulativeStates[0].p2); 

            for (let i = 0; i < cumulativeStates.length - 1; i++) {
                const fromState = cumulativeStates[i];
                const toState = cumulativeStates[i+1];

                const base_delta = Math.abs(toState.target_base_steps - fromState.target_base_steps);
                const elbow_delta = Math.abs(toState.target_elbow_steps - fromState.target_elbow_steps);
                const max_step_delta = Math.max(base_delta, elbow_delta);

                const stepsPerSegment = Math.max(20, Math.ceil(max_step_delta / 100));

                for (let j = 1; j <= stepsPerSegment; j++) {
                    const progress = j / stepsPerSegment;
                    const interpolatedState = getInterpolatedState(fromState, toState, progress);
                    tracePath.push(interpolatedState.p2);
                }
            }
        }

        /**
         * Forward Kinematics: Calculates arm position from motor steps.
         */
        function calculateFK(p0, base_steps, elbow_steps) {
            const alpha_rad = -base_steps / STEPS_PER_RAD;
            const beta_rad = -elbow_steps / STEPS_PER_RAD;
            
            const theta1 = alpha_rad;
            const theta_bend = beta_rad - (GEAR_RATIO * alpha_rad);
            const theta2_global = theta1 + theta_bend;

            const p1 = {
                x: (p0 ? p0.x : 0) + L1 * Math.cos(theta1),
                y: (p0 ? p0.y : 0) + L1 * Math.sin(theta1)
            };
            const p2 = {
                x: p1.x + L2 * Math.cos(theta2_global),
                y: p1.y + L2 * Math.sin(theta2_global)
            };

            return {
                p0: p0 || {x:0, y:0}, p1, p2,
                target_base_steps: base_steps,
                target_elbow_steps: elbow_steps,
                theta1_rad: theta1,
                theta_bend_rad: theta_bend,
                theta2_global_rad: theta2_global
            };
        }


        function handleSliderInput(e) {
            pause();
            const newStep = parseInt(e.target.value, 10);
            drawState(newStep);
        }
        
        function playFrame() {
            if (isAutoPlaying) {
                pause();
            }
            isLooping = false;
            
            if (currentStep < cumulativeStates.length - 1) {
                currentStep++;
                drawState(currentStep);
            }
        }
        
        function drawState(index) {
            cancelAnimation();
            currentStep = index;
            const state = cumulativeStates[index];
            if (!state) return;

            clearCanvas();
            drawGrid();
            drawTrace();
            drawArm(state.p0, state.p1, state.p2);
            
            updateUIForStep(index);
        }

        function updateUIForStep(index) {
            const state = cumulativeStates[index];
            if (!state) return;
            
            commandSlider.value = index;
            stepDisplay.textContent = `Step: ${index} / ${cumulativeStates.length - 1}`;
        }

        function clearCanvas() {
            ctx.save();
            ctx.resetTransform();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        function drawGrid() {
            const maxRange = L1 + L2;
            const lineWidth = 1 / worldScale;
            
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = lineWidth;
            ctx.arc(0, 0, L1, 0, 2 * Math.PI);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, maxRange, 0, 2 * Math.PI);
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = lineWidth;
            ctx.moveTo(-maxRange * 1.1, 0);
            ctx.lineTo(maxRange * 1.1, 0);
            ctx.moveTo(0, -maxRange * 1.1);
            ctx.lineTo(0, maxRange * 1.1);
            ctx.stroke();
        }

        function drawTrace() {
            if (tracePath.length < 2) return;
            const traceWidth = 2 / worldScale;
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.75)';
            ctx.lineWidth = traceWidth;
            ctx.moveTo(tracePath[0].x, tracePath[0].y);
            for (let i = 1; i < tracePath.length; i++) {
                ctx.lineTo(tracePath[i].x, tracePath[i].y);
            }
            ctx.stroke();
        }

        function drawArm(p0, p1, p2) {
            const armWidth = 6 / worldScale;
            const jointRadius = 8 / worldScale;
            
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = armWidth;
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = '#06b6d4';
            ctx.lineWidth = armWidth;
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(p0.x, p0.y, jointRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(p1.x, p1.y, jointRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#f43f5e';
            ctx.beginPath();
            ctx.arc(p2.x, p2.y, jointRadius, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function getInterpolatedState(from, to, progress) {
            const theta1_rad = lerp(from.theta1_rad, to.theta1_rad, progress);
            const theta_bend_rad = lerp(from.theta_bend_rad, to.theta_bend_rad, progress);
            
            const p0 = from.p0;
            const p1 = {
                x: p0.x + L1 * Math.cos(theta1_rad),
                y: p0.y + L1 * Math.sin(theta1_rad)
            };
            const theta2_global_rad = theta1_rad + theta_bend_rad;
            const p2 = {
                x: p1.x + L2 * Math.cos(theta2_global_rad),
                y: p1.y + L2 * Math.sin(theta2_global_rad)
            };
            return { p0, p1, p2 };
        }

        function drawInterpolatedState(from, to, progress) {
            const state = getInterpolatedState(from, to, progress);
            clearCanvas();
            drawGrid();
            drawTrace();
            drawArm(state.p0, state.p1, state.p2);
        }
        
        // --- Playback Controls ---

        function playFullAnimation() {
            if (isAutoPlaying) return;
            if (currentStep >= cumulativeStates.length - 1) {
                currentStep = 0;
                drawState(0);
            }
            isAutoPlaying = true;
            playNextCommand();
        }
        
        function cancelAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        function pause() {
            isAutoPlaying = false;
            isLooping = false;
            cancelAnimation();
        }
        
        function playLoop() {
            if (isAutoPlaying) {
                pause();
            }
            isLooping = true;
            currentStep = 0;
            drawState(0);
            playFullAnimation();
        }

        function playNextCommand() {
            if (!isAutoPlaying) return;
            
            if (currentStep >= cumulativeStates.length - 1) {
                if (isLooping) {
                    currentStep = 0;
                    drawState(0);
                    setTimeout(playFullAnimation, 50);
                    return;
                } else {
                    isAutoPlaying = false;
                    return;
                }
            }
            
            animationFromState = cumulativeStates[currentStep];
            animationToState = cumulativeStates[currentStep + 1];
            animationStartTime = performance.now();
            currentStep++;
            
            const currentCommand = animationToState.command;
            const { elbow, base, step_delay_us } = currentCommand;
            const max_steps = Math.max(Math.abs(elbow), Math.abs(base));
            let duration_ms = (max_steps * step_delay_us) / 1000.0;
            if (duration_ms === 0) duration_ms = 1;
            
            commandSlider.value = currentStep;
            stepDisplay.textContent = `Step: ${currentStep} / ${cumulativeStates.length - 1}`;
            
            animationFrameId = requestAnimationFrame((t) => animateStep(t, duration_ms));
        }

        function animateStep(timestamp, duration_ms) {
            const elapsed = timestamp - animationStartTime;
            let progress = elapsed / duration_ms;

            if (progress >= 1) {
                progress = 1;
                drawState(currentStep);
                if (isAutoPlaying) {
                    playNextCommand();
                }
            } else {
                drawInterpolatedState(animationFromState, animationToState, progress);
                animationFrameId = requestAnimationFrame((t) => animateStep(t, duration_ms));
            }
        }

        // --- Utilities ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function showModal(message) {
            let modal = document.getElementById('alert-modal');
            if (modal) {
                modal.querySelector('p').textContent = message;
                modal.style.display = 'flex';
                return;
            }
            modal = document.createElement('div');
            modal.id = 'alert-modal';
            modal.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50';
            const modalContent = document.createElement('div');
            modalContent.className = 'bg-gray-800 p-6 rounded-lg shadow-xl text-gray-200 max-w-sm w-full mx-4';
            const modalTitle = document.createElement('h3');
            modalTitle.className = 'text-lg font-medium text-white mb-2';
            modalTitle.textContent = 'Conversion Notice';
            const modalText = document.createElement('p');
            modalText.className = 'text-sm mb-4';
            modalText.textContent = message;
            const closeButton = document.createElement('button');
            closeButton.className = 'w-full text-white font-semibold py-2 px-4 rounded-lg transition duration-200';
            closeButton.textContent = 'OK';
            closeButton.onclick = () => {
                modal.style.display = 'none';
            };
            modalContent.appendChild(modalTitle);
            modalContent.appendChild(modalText);
            modalContent.appendChild(closeButton);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }

        // --- Start the App ---
        init();
    });
</script>
</body>
</html>