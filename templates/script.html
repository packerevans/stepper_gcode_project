<script>
// --- CONFIGURATION ---
const L1 = 101.3;
const L2 = 101.3;
const GEAR_RATIO = 9/8;
const STEPS_PER_DEG = 3200/360;
const STEPS_PER_RAD = STEPS_PER_DEG * (180 / Math.PI);

// --- STATE ---
let commands = [];
let cumulativeStates = [];
let currentStep = 0;
let isAutoPlaying = false;
let isLooping = false;
let animationFrameId = null;
let animationStartTime = 0;
let animationFromState = null;
let animationToState = null;
let origin = {x: 0, y: 0 };
let worldScale = 1;
let tracePath = [];

// Utility
const lerp = (a, b, t) => a + (b - a) * t;

// --- DOM ---
const canvas = document.getElementById('armCanvas');
const ctx = canvas.getContext('2d');
const slider = document.getElementById('commandSlider');
const stepDisp = document.getElementById('stepDisplay');

// --- INIT ---
function init() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.body.setAttribute('data-theme', savedTheme);
    document.getElementById('themeIcon').textContent = savedTheme === 'dark' ? '‚òÄÔ∏è' : 'üåó';

    document.getElementById('loadCommandsBtn').addEventListener('click', loadCommands);
    document.getElementById('convertGCodeBtn').addEventListener('click', convertGCode);
    document.getElementById('autoCalibrateBtn').addEventListener('click', autoCalibrate);

    document.getElementById('fileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            document.getElementById('gcodeConverterInput').value = e.target.result;
        };
        reader.readAsText(file);
    });

    slider.addEventListener('input', (e) => {
        isLooping = false;
        pause();
        drawState(parseInt(e.target.value));
    });

    document.getElementById('playBtn').addEventListener('click', () => {
        isLooping = false;
        playFrame();
    });

    document.getElementById('playLoopBtn').addEventListener('click', () => {
        if(isAutoPlaying) pause();
        isLooping = true;
        currentStep = 0;
        drawState(0);
        playFullAnimation();
    });

    document.getElementById('pauseBtn').addEventListener('click', pause);

    window.addEventListener('resize', () => { 
        resizeCanvas(); 
        if(cumulativeStates.length) drawState(currentStep); 
    });

    resizeCanvas();
    loadCommands();
}

// --- CANVAS ---
function resizeCanvas() {
    const parent = canvas.parentElement;
    const size = parent.clientWidth;
    canvas.width = size;
    canvas.height = size;
    origin.x = size / 2;
    origin.y = size / 2;
    const maxReach = (L1 + L2) * 1.1;
    worldScale = size / (maxReach * 2);
    ctx.resetTransform();
    ctx.translate(origin.x, origin.y);
    ctx.scale(worldScale, -worldScale);
}

function clearCanvas() {
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}

function drawGrid() {
    const max = L1 + L2;
    const lw = 1 / worldScale;
    ctx.strokeStyle = document.body.getAttribute('data-theme') === 'dark' ? 
        'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
    ctx.lineWidth = lw;
    ctx.beginPath(); ctx.arc(0,0,L1,0,2*Math.PI); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,max,0,2*Math.PI); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-max*1.1, 0); ctx.lineTo(max*1.1, 0);
    ctx.moveTo(0, -max*1.1); ctx.lineTo(0, max*1.1);
    ctx.stroke();
}

function drawTrace() {
    if(tracePath.length < 2) return;
    ctx.beginPath();
    ctx.strokeStyle = document.body.getAttribute('data-theme') === 'dark' ? 
        'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 2 / worldScale;
    ctx.moveTo(tracePath[0].x, tracePath[0].y);
    for(let i=1; i<tracePath.length; i++) ctx.lineTo(tracePath[i].x, tracePath[i].y);
    ctx.stroke();
}

function drawArm(p0, p1, p2) {
    const w = 6 / worldScale;
    const r = 8 / worldScale;
    const jointColor = '#b08d5c';
    ctx.lineWidth = w; 
    ctx.lineCap = 'round';
    ctx.strokeStyle = '#d2b48c';
    ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.stroke();
    ctx.strokeStyle = '#b08d5c'; 
    ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
    ctx.fillStyle = jointColor;
    ctx.beginPath(); ctx.arc(p0.x, p0.y, r, 0, 2*Math.PI); ctx.fill();
    ctx.beginPath(); ctx.arc(p1.x, p1.y, r, 0, 2*Math.PI); ctx.fill();
    ctx.beginPath(); ctx.arc(p2.x, p2.y, r, 0, 2*Math.PI); ctx.fill();
}

function drawState(idx) {
    cancelAnimation();
    currentStep = idx;
    const state = cumulativeStates[idx];
    if(!state) return;
    clearCanvas();
    drawGrid();
    drawTrace();
    drawArm(state.p0, state.p1, state.p2);
    slider.value = idx;
    stepDisp.textContent = `Step: ${idx} / ${cumulativeStates.length-1}`;
}

function drawInterpolatedState(from, to, prog) {
    const t1 = lerp(from.theta1_rad, to.theta1_rad, prog);
    const tb = lerp(from.theta_bend_rad, to.theta_bend_rad, prog);
    const p0 = from.p0;
    const p1 = {x: p0.x + L1*Math.cos(t1), y: p0.y + L1*Math.sin(t1) };
    const t2 = t1 + tb;
    const p2 = {x: p1.x + L2*Math.cos(t2), y: p1.y + L2*Math.sin(t2) };
    clearCanvas();
    drawGrid();
    drawTrace();
    drawArm(p0, p1, p2);
}

// --- KINEMATICS ---
function getShortestRotation(raw, last) {
    let diff = (raw - last) / (2*Math.PI);
    let offset = Math.round(diff);
    return raw - (offset * 2 * Math.PI);
}

function calculateIK(x, y, lastBase = 0, lastElbow = 0) {
    let D = Math.hypot(x, y);
    const maxR = L1 + L2;
    let cx = x, cy = y;
    if(D > maxR) { 
        cx = x * maxR / D; 
        cy = y * maxR / D; 
        D = maxR; 
    }
    const lastT1 = -lastBase / STEPS_PER_RAD;
    const lastBend = (-lastElbow / STEPS_PER_RAD) - (GEAR_RATIO * lastT1);
    let finalT1, finalBend;

    if (D < 0.1) {
        finalBend = lastBend > 0 ? Math.PI : -Math.PI;
        let rawT1 = (D < 1e-6) ? lastT1 : Math.atan2(y,x);
        finalT1 = getShortestRotation(rawT1, lastT1);
        cx=0; cy=0;
    } else {
        let cosBend = (D*D - L1*L1 - L2*L2) / (2*L1*L2);
        cosBend = Math.max(-1, Math.min(1, cosBend));
        const bend1 = Math.acos(cosBend);
        const k1_1 = L1 + L2 * Math.cos(bend1);
        const k2_1 = L2 * Math.sin(bend1);
        const rawT1_1 = Math.atan2(cy, cx) - Math.atan2(k2_1, k1_1);
        const t1_1 = getShortestRotation(rawT1_1, lastT1);
        const bend2 = -Math.acos(cosBend);
        const k1_2 = L1 + L2 * Math.cos(bend2);
        const k2_2 = L2 * Math.sin(bend2);
        const rawT1_2 = Math.atan2(cy, cx) - Math.atan2(k2_2, k1_2);
        const t1_2 = getShortestRotation(rawT1_2, lastT1);
        const b1 = -t1_1 * STEPS_PER_RAD;
        const e1 = -(bend1 + GEAR_RATIO * t1_1) * STEPS_PER_RAD;
        const b2 = -t1_2 * STEPS_PER_RAD;
        const e2 = -(bend2 + GEAR_RATIO * t1_2) * STEPS_PER_RAD;
        const cost1 = Math.abs(b1 - lastBase) + Math.abs(e1 - lastElbow);
        const cost2 = Math.abs(b2 - lastBase) + Math.abs(e2 - lastElbow);
        if(cost1 <= cost2) { finalT1 = t1_1; finalBend = bend1; }
        else { finalT1 = t1_2; finalBend = bend2; }
    }
    const alpha = finalT1;
    const beta = finalBend + (GEAR_RATIO * alpha);
    return { base_steps: -alpha * STEPS_PER_RAD, elbow_steps: -beta * STEPS_PER_RAD, clamped_x: cx, clamped_y: cy };
}

function calculateFK(p0, b, e) {
    const a = -b / STEPS_PER_RAD;
    const beta = -e / STEPS_PER_RAD;
    const t1 = a;
    const tb = beta - (GEAR_RATIO * a);
    const t2 = t1 + tb;
    const p1 = {x: p0.x + L1*Math.cos(t1), y: p0.y + L1*Math.sin(t1) };
    const p2 = {x: p1.x + L2*Math.cos(t2), y: p1.y + L2*Math.sin(t2) };
    return { p0, p1, p2, target_base_steps: b, target_elbow_steps: e, theta1_rad: t1, theta_bend_rad: tb };
}

// --- AUTO CALIBRATION LOGIC UPDATE ---
function autoCalibrate() {
    const text = document.getElementById('gcodeConverterInput').value;
    if(!text.trim()) { alert("Please upload or paste G-Code first."); return; }
    
    const lines = text.split('\n');
    const format = document.querySelector('input[name="gcodeFormat"]:checked').value;
    let totalDist = 0;
    let count = 0;
    let lastP = null;

    for(let line of lines) {
        line = line.trim();
        if(!line) continue;
        let p = null;
        if(format === 'cartesian') {
            const m = line.match(/G1\s+X(-?[\d.]+)\s+Y(-?[\d.]+)/i);
            if(m) p = {x: parseFloat(m[1]), y: parseFloat(m[2])};
        } else {
            const m = line.match(/G1\s+R(-?[\d.]+)\s+A(-?[\d.]+)/i);
            if(m) {
                let r = parseFloat(m[1]);
                let rad = parseFloat(m[2]) * (Math.PI/180);
                p = {x: r*Math.cos(rad), y: r*Math.sin(rad)};
            }
        }
        if(p) {
            if(lastP) {
                totalDist += Math.hypot(p.x - lastP.x, p.y - lastP.y);
                count++;
            }
            lastP = p;
        }
    }

    if(count === 0) return;
    const avgSegment = totalDist / count;
    
    // IMPROVED LOGIC: 
    // Typical Sandify output is 3mm - 5mm segments.
    // To properly reproduce the shape without wobbles, we should NOT interpolate these.
    // We set resolution HIGHER than the segment length to disable interpolation.
    
    let recRes, recSmooth;

    if (avgSegment < 10.0) {
        // High Detail File (Sandify Spirals, etc.)
        // Disable Interpolation: Set Res > Avg Segment
        recRes = 12.0; 
        // Minimal Smoothing: Keep vertices, just merge redundant straights
        recSmooth = 0.0005; 
    } else {
        // Low Detail File (Square, Triangle)
        // Needs Interpolation to curve gracefully
        recRes = 1.0;       
        recSmooth = 0.00001; 
    }

    document.getElementById('linearResolution').value = recRes;
    document.getElementById('smoothingSensitivity').value = recSmooth;
    document.getElementById('stepDelayInput').value = "800";

    convertGCode();
}

// --- CONVERTER ---
function convertGCode() {
    const text = document.getElementById('gcodeConverterInput').value;
    const lines = text.split('\n');
    const format = document.querySelector('input[name="gcodeFormat"]:checked').value;
    const res = parseFloat(document.getElementById('linearResolution').value) || 1.0;
    
    // Center Offset
    const tableRadius = 202.6; 

    let coords = [];
    for(let line of lines) {
        line = line.trim();
        if(!line) continue;
        if(format === 'cartesian') {
            const m = line.match(/G1\s+X(-?[\d.]+)\s+Y(-?[\d.]+)/i);
            if(m) { 
                let rawX = parseFloat(m[1]); 
                let rawY = parseFloat(m[2]); 
                let x = rawX - tableRadius;
                let y = rawY - tableRadius;
                coords.push({x,y}); 
            }
        } else {
            const m = line.match(/G1\s+R(-?[\d.]+)\s+A(-?[\d.]+)/i);
            if(m) {
                let r = parseFloat(m[1]);
                let deg = parseFloat(m[2]);
                let rad = deg * (Math.PI/180);
                r = Math.abs(r);
                coords.push({x: r*Math.cos(rad), y: r*Math.sin(rad) });
            }
        }
    }

    if(coords.length === 0) { alert("No valid G-Code found."); return; }

    let interp = [coords[0]];
    for(let i=0; i<coords.length-1; i++) {
        const p1 = coords[i], p2 = coords[i+1];
        const dist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
        const steps = Math.max(1, Math.ceil(dist/res));
        for(let j=1; j<=steps; j++) {
            let t = j/steps;
            interp.push({x: lerp(p1.x,p2.x,t), y: lerp(p1.y,p2.y,t) });
        }
    }

    let genCmds = [];
    let prevB = 0, prevE = 0;
    const start = calculateIK(interp[0].x, interp[0].y, 0, 0);
    prevB = start.base_steps; 
    prevE = start.elbow_steps;
    const delay = document.getElementById('stepDelayInput').value;

    for(let i=1; i<interp.length; i++) {
        const ik = calculateIK(interp[i].x, interp[i].y, prevB, prevE);
        const rb = Math.round(ik.base_steps - prevB);
        const re = Math.round(ik.elbow_steps - prevE);
        if(rb !== 0 || re !== 0) {
            genCmds.push({elbow:re, base:rb, delay:delay});
        }
        prevB = ik.base_steps; 
        prevE = ik.elbow_steps;
    }

    const sens = parseFloat(document.getElementById('smoothingSensitivity').value);
    let smoothed = genCmds;
    let lastLen = -1;
    while(smoothed.length !== lastLen) {
        lastLen = smoothed.length;
        smoothed = smoothCommands(smoothed, sens);
    }

    document.getElementById('commandsInput').value = smoothed.map(c => 
        `G1 ${c.elbow} ${c.base} ${c.delay}`
    ).join('\n');
    
    loadCommands();
}

function smoothCommands(cmds, sensitivity) {
    if(cmds.length === 0) return [];
    const out = [];
    let curr = {...cmds[0]};
    for(let i=1; i<cmds.length; i++) {
        const next = cmds[i];
        let combine = false;
        if(curr.delay == next.delay) {
            const sB1 = Math.sign(curr.base), sB2 = Math.sign(next.base);
            const sE1 = Math.sign(curr.elbow), sE2 = Math.sign(next.elbow);
            if(curr.base === 0 && next.base === 0 && sE1 === sE2) combine = true;
            else if(curr.elbow === 0 && next.elbow === 0 && sB1 === sB2) combine = true;
            else if(curr.base !== 0 && next.base !== 0 && curr.elbow !== 0 && next.elbow !== 0) {
                const r1 = curr.elbow / curr.base;
                const r2 = next.elbow / next.base;
                if(Math.abs(r1-r2) < sensitivity && sB1 === sB2) combine = true;
            }
        }
        if(combine) {
            curr.elbow += next.elbow;
            curr.base += next.base;
        } else {
            out.push(curr);
            curr = {...next};
        }
    }
    out.push(curr);
    return out;
}

// --- SIMULATION LOAD ---
function loadCommands() {
    pause();
    const text = document.getElementById('commandsInput').value;
    commands = text.split('\n').filter(l=>l.trim().startsWith('G1')).map(l => {
        const p = l.trim().substring(2).trim().split(/\s+/).map(Number);
        return { elbow: p[0]||0, base: p[1]||0, step_delay_us: p[2]||1000 };
    });

    cumulativeStates = [];
    const p0 = {x:0, y:0};
    cumulativeStates.push(calculateFK(p0, 0, 0));

    let tb = 0, te = 0;
    for(let c of commands) {
        tb += c.base; 
        te += c.elbow;
        const s = calculateFK(p0, tb, te);
        s.command = c;
        cumulativeStates.push(s);
    }

    tracePath = [];
    if(cumulativeStates.length > 1) {
        tracePath.push(cumulativeStates[0].p2);
        for(let i=0; i<cumulativeStates.length-1; i++) {
            const from = cumulativeStates[i], to = cumulativeStates[i+1];
            const max = Math.max(Math.abs(to.target_base_steps - from.target_base_steps), 
                                 Math.abs(to.target_elbow_steps - from.target_elbow_steps));
            const segs = Math.max(2, Math.ceil(max/100));
            for(let j=1; j<=segs; j++) {
                const t = j/segs;
                const t1 = lerp(from.theta1_rad, to.theta1_rad, t);
                const tb = lerp(from.theta_bend_rad, to.theta_bend_rad, t);
                const t2 = t1 + tb;
                const p1 = {x: L1*Math.cos(t1), y: L1*Math.sin(t1) };
                tracePath.push({x: p1.x + L2*Math.cos(t2), y: p1.y + L2*Math.sin(t2) });
            }
        }
    }

    slider.max = cumulativeStates.length - 1;
    slider.value = 0;
    slider.disabled = cumulativeStates.length <= 1;
    drawState(0);
}

function playFrame() {
    if(isAutoPlaying) pause();
    isLooping = false;
    if(currentStep < cumulativeStates.length-1) {
        currentStep++;
        drawState(currentStep);
    }
}

function playFullAnimation() {
    if(isAutoPlaying) return;
    if(currentStep >= cumulativeStates.length-1) {
        currentStep = 0;
        drawState(0);
    }
    isAutoPlaying = true;
    playNext();
}

function pause() {
    isAutoPlaying = false; isLooping = false;
    cancelAnimation();
}

function cancelAnimation() {
    if(animationFrameId) { 
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null; 
    }
}

function playNext() {
    if(!isAutoPlaying) return;
    if(currentStep >= cumulativeStates.length-1) {
        if(isLooping) { 
            currentStep = 0; 
            drawState(0); 
            setTimeout(playFullAnimation, 50);
        } else {
            isAutoPlaying = false;
        }
        return;
    }

    animationFromState = cumulativeStates[currentStep];
    animationToState = cumulativeStates[currentStep+1];
    animationStartTime = performance.now();
    currentStep++;

    const c = animationToState.command;
    const steps = Math.max(Math.abs(c.elbow), Math.abs(c.base));
    let dur = (steps * c.step_delay_us) / 1000.0;
    if(dur === 0) dur = 1;

    slider.value = currentStep;
    stepDisp.textContent = `Step: ${currentStep} / ${cumulativeStates.length-1}`;

    animationFrameId = requestAnimationFrame(t => animate(t, dur));
}

function animate(time, dur) {
    const elapsed = time - animationStartTime;
    let p = elapsed / dur;
    if(p >= 1) {
        drawState(currentStep);
        if(isAutoPlaying) playNext();
    } else {
        drawInterpolatedState(animationFromState, animationToState, p);
        animationFrameId = requestAnimationFrame(t => animate(t, dur));
    }
}

// --- SIDEBAR ---
function openNav() {
    document.getElementById("mySidebar").style.width = "200px";
    if(window.innerWidth > 900) 
        document.querySelector(".main-content").style.marginLeft = "200px";
}

function closeNav() {
    document.getElementById("mySidebar").style.width = "0";
    document.querySelector(".main-content").style.marginLeft = "0";
}

function toggleDarkMode() {
    const b = document.body;
    const n = b.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
    b.setAttribute('data-theme', n); 
    localStorage.setItem('theme', n);
    document.getElementById('themeIcon').textContent = n === 'dark' ? '‚òÄÔ∏è' : 'üåó';
    drawState(currentStep);
}

init();
</script>
