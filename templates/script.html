<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coupled Arm Command Executor (End Effector Path)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use the Inter font family */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Import Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        /* Custom styles for a better-looking range slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #374151; /* gray-700 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #ffffff;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }
        /* Style for the command list */
        .command-item {
            transition: all 0.2s ease-in-out;
            border-left: 4px solid transparent;
        }
        .command-item.highlight {
            background-color: #3b82f633; /* blue-500 with 20% opacity */
            border-left-color: #3b82f6; /* blue-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-inter antialiased">

    <div class="max-w-7xl mx-auto p-4 md:p-8">
        <h1 class="text-3xl font-bold text-center text-white mb-8">
            Coupled Arm Command Executor (End Effector Path)
        </h1>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <div class="lg:col-span-1 bg-gray-800 p-6 rounded-2xl shadow-xl space-y-6">
                
                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">1. Coordinates (G-Code or X,Y)</h2>
                    <p class="text-sm text-gray-400 mb-2">Enter G1 X... Y... or X, Y pairs.</p>
                    <textarea id="coords-input" rows="5" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-200 resize-none" placeholder="G1 X50 Y50&#10;G1 X0 Y0&#10;G1 X-50 Y80"></textarea>
                    <button id="add-coords-btn" class="mt-3 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">
                        Set Path & Calculate Motor Commands
                    </button>
                </div>
                
                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">2. Arm Parameters</h2>
                    <div class="space-y-2">
                        <div class="flex justify-between items-center">
                            <label class="text-gray-400">Arm 1 Length (L1):</label>
                            <input type="text" value="101.3 mm" disabled class="bg-gray-700 text-gray-300 px-3 py-1 rounded-md w-28 text-right">
                        </div>
                        <div class="flex justify-between items-center">
                            <label class="text-gray-400">Arm 2 Length (L2):</label>
                            <input type="text" value="101.3 mm" disabled class="bg-gray-700 text-gray-300 px-3 py-1 rounded-md w-28 text-right">
                        </div>
                        <div class="flex justify-between items-center pt-2">
                            <label class="text-gray-400">Gearing:</label>
                            <input type="text" value="A2 = M2 + (M1 / 8)" disabled class="bg-gray-700 text-gray-300 px-3 py-1 rounded-md w-auto text-right">
                        </div>
                         <div class="flex justify-between items-center pt-2">
                            <label class="text-gray-400">Motor Solver:</label>
                            <input type="text" value="M2 = A2 - (M1 / 8)" disabled class="bg-gray-700 text-gray-300 px-3 py-1 rounded-md w-auto text-right">
                        </div>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">3. Animation Control</h2>
                    <div class="flex items-center space-x-4">
                        <button id="play-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all duration-200">
                            Play
                        </button>
                        <input type="range" id="time-slider" min="0" max="1000" value="0" step="1" class="w-full">
                    </div>
                    <p class="text-sm text-gray-400 mt-3 p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                        <strong>Animation Logic:</strong> The animation executes the commands by interpolating in <strong>Cartesian (X, Y) space</strong>, then solving for joint angles at each tiny step. This results in the arm's end-effector following a <strong>straight path</strong> (solid white line) between your target points, matching the dashed target path.
                    </p>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">4. Motor Command List</h2>
                    <div id="command-list-container" class="max-h-60 overflow-y-auto bg-gray-900/50 p-3 rounded-lg border border-gray-700 text-sm space-y-2">
                        <p class="text-gray-400">Commands will appear here...</p>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">5. Live Motor Command Status</h2>
                    <div class="bg-gray-900/50 p-4 rounded-lg border border-gray-700 space-y-3">
                        <div class="flex justify-between items-center text-lg">
                            <span class="text-gray-300 font-medium">Motor 1 (Base) Remaining:</span>
                            <span id="m1-output" class="font-mono text-cyan-300 text-xl font-bold">0.00°</span>
                        </div>
                        <div class="flex justify-between items-center text-lg">
                            <span class="text-gray-300 font-medium">Motor 2 (Elbow) Remaining:</span>
                            <span id="m2-output" class="font-mono text-purple-300 text-xl font-bold">0.00°</span>
                        </div>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-semibold mb-3 text-blue-300">6. G-Code Output</h2>
                    <div class="bg-gray-900/50 p-4 rounded-lg border border-gray-700 space-y-3">
                        <div class="flex justify-between items-center text-lg">
                            <span class="text-gray-300 font-medium">Command:</span>
                            <span id="gcode-output" class="font-mono text-indigo-300 text-lg font-bold">G1 0.000 0.000 1000</span>
                        </div>
                        <button id="send-gcode-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">
                            Send Command
                        </button>
                    </div>
                </div>

            </div>

            <div class="lg:col-span-2 bg-gray-800 p-4 rounded-2xl shadow-xl">
                <canvas id="ik-canvas"></canvas>
            </div>

        </div>
    </div>

    <script type="module">
        // == ARM PARAMETERS ==
        const L1 = 101.3;
        const L2 = 101.3;
        const MAX_REACH = L1 + L2; // This is 202.6
        const GCODE_FACTOR = 360 / 3200; // NEW: G-Code conversion factor
        // [MODIFIED] Set canvas size to the max reach
        const CANVAS_WORLD_SIZE = MAX_REACH * 2; // 405.2, so it shows +/- 202.6
        const HOME_POINT = { x: 0, y: 150 }; // Default "ready" position
        const SLIDER_MAX = 1000;
        let DYNAMIC_ANIMATION_SPEED = 4; // Will be updated based on command count
        const STEPS_PER_SEGMENT_INTERPOLATION = 50; // New: How many interpolation steps per G-code segment

        // == DOM ELEMENTS ==
        const canvas = document.getElementById('ik-canvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('time-slider');
        const playBtn = document.getElementById('play-btn');
        const coordsInput = document.getElementById('coords-input');
        const addCoordsBtn = document.getElementById('add-coords-btn');
        const commandListContainer = document.getElementById('command-list-container');
        const m1Out = document.getElementById('m1-output');
        const m2Out = document.getElementById('m2-output');
        const gcodeOut = document.getElementById('gcode-output'); // NEW: G-Code output element

        // == STATE ==
        let path = []; // Array of {x, y} objects from user input
        let commandList = []; // Array of calculated command objects
        let precalculatedPath = []; // Array[SLIDER_MAX + 1] of full arm states
        let isPlaying = false;
        let animationFrameId = null;
        let canvasSize = 500;
        let origin = { x: 0, y: 0 };
        let scale = 1.0;
        let lastHighlightedSegment = -1;
        let homeJointAngles = { a1: Math.PI/2, a2: 0 };

        // == CORE FUNCTIONS ==

        /**
         * Calculates the shortest angular distance between two angles (in radians).
         */
        function shortestAngleDist(a0, a1) {
            const max = Math.PI * 2;
            const da = (a1 - a0) % max;
            return 2 * da % max - da;
        }

        /**
         * [ROBUST IK SOLVER]
         * Solves for the required JOINT angles (A1, A2) to reach (x, y).
         */
        function solveIK(targetX, targetY, previousA1, previousA2) {
            let x = targetX;
            let y = targetY;
            let clamped = false;

            const D_sq = x * x + y * y;
            let D = Math.sqrt(D_sq);

            // Check if it's *just* over the max reach (floating point errors)
            if (D > MAX_REACH && D < MAX_REACH + 0.001) {
                D = MAX_REACH;
            }

            // This is the "out of boundary" logic you asked for.
            if (D > MAX_REACH) {
                clamped = true;
                const ratio = MAX_REACH / D; // Get ratio
                x *= ratio; // Scale x along the same vector
                y *= ratio; // Scale y along the same vector
                D = MAX_REACH;
            }
            
            // [SINGULARITY FIX]
            // If at or very near origin, just fold the elbow and hold the base
            if (D < 0.1) { 
                const stableA1 = previousA1;
                // Fold the elbow completely
                const stableA2 = previousA2 + shortestAngleDist(previousA2, Math.PI);
                return { a1: stableA1, a2: stableA2, clamped: false };
            }

            // --- Standard IK Calculation ---
            let cos_a2 = (D_sq - L1 * L1 - L2 * L2) / (2 * L1 * L2);
            cos_a2 = Math.max(-1, Math.min(1, cos_a2)); 
            
            const a2_rad_up = Math.acos(cos_a2); 
            const a2_rad_down = -a2_rad_up;

            const k1_up = L1 + L2 * Math.cos(a2_rad_up);
            const k2_up = L2 * Math.sin(a2_rad_up);
            const a1_rad_up_raw = Math.atan2(y, x) - Math.atan2(k2_up, k1_up);

            const k1_down = L1 + L2 * Math.cos(a2_rad_down);
            const k2_down = L2 * Math.sin(a2_rad_down);
            const a1_rad_down_raw = Math.atan2(y, x) - Math.atan2(k2_down, k1_down);
            
            // [CONTINUITY FIX]
            const a1_up_cont = previousA1 + shortestAngleDist(previousA1, a1_rad_up_raw);
            const a2_up_cont = previousA2 + shortestAngleDist(previousA2, a2_rad_up);
            
            const a1_down_cont = previousA1 + shortestAngleDist(previousA1, a1_rad_down_raw);
            const a2_down_cont = previousA2 + shortestAngleDist(previousA2, a2_rad_down);

            const cost_up = (a1_up_cont - previousA1)**2 + (a2_up_cont - previousA2)**2;
            const cost_down = (a1_down_cont - previousA1)**2 + (a2_down_cont - previousA2)**2;

            if (cost_up <= cost_down) {
                return { a1: a1_up_cont, a2: a2_up_cont, clamped, endX: x, endY: y };
            } else {
                return { a1: a1_down_cont, a2: a2_down_cont, clamped, endX: x, endY: y };
            }
        }
        
        /**
         * [SOLVER LOGIC - Corrected]
         * Physics: A2_Joint = M2_Motor + (M1_Motor / 8)
         * Solver: M2_Motor = A2_Joint - (M1_Motor / 8)
         */
        function solveMotorCommands(a1, a2) {
            const m1 = a1;
            const m2 = a2 - (a1 / 8.0);
            return { m1, m2 };
        }

        /**
         * Sets up the canvas dimensions and coordinate system.
         */
        function setupCanvas() {
            canvasSize = canvas.parentElement.clientWidth;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            origin.x = canvasSize / 2;
            origin.y = canvasSize / 2;
            scale = canvasSize / CANVAS_WORLD_SIZE;
            
            // Calculate and store home joint angles
            homeJointAngles = solveIK(HOME_POINT.x, HOME_POINT.y, Math.PI/2, 0);
            
            // Draw home pose
            const homeMotorCommands = solveMotorCommands(homeJointAngles.a1, homeJointAngles.a2);
            precalculatedPath = [
                { 
                    x: HOME_POINT.x, 
                    y: HOME_POINT.y, 
                    ...homeJointAngles, 
                    ...homeMotorCommands, 
                    clamped: false, 
                    segment: -1, 
                    t_in_segment: 0 
                }
            ];
            draw();
        }

        /**
         * Draws the entire scene (grid, path, arm).
         */
        function draw() {
            // Check if canvas is ready
            if (!ctx) return;

            const globalT_val = parseInt(slider.value);
            
            // Get the pre-calculated state. 
            // If scrubbing past the end, hold the last frame.
            const state = precalculatedPath[Math.min(globalT_val, precalculatedPath.length - 1)];

            let a1, a2, clamped, endX, endY;
            let currentSegment = -1;
            let t_in_segment = 0;

            if (state && commandList.length > 0) {
                a1 = state.a1;
                a2 = state.a2;
                clamped = state.clamped;
                currentSegment = state.segment;
                t_in_segment = state.t_in_segment;
                endX = state.endX; // End effector X
                endY = state.endY; // End effector Y
            } else {
                // No path, just draw arm in home pose
                a1 = homeJointAngles.a1;
                a2 = homeJointAngles.a2;
                clamped = false;
                // Calculate end effector position for home pose
                const j1_x_home = L1 * Math.cos(homeJointAngles.a1);
                const j1_y_home = L1 * Math.sin(homeJointAngles.a1);
                endX = j1_x_home + L2 * Math.cos(homeJointAngles.a1 + homeJointAngles.a2);
                endY = j1_y_home + L2 * Math.sin(homeJointAngles.a1 + homeJointAngles.a2);
            }
            
            // Update UI based on this segment
            if (currentSegment !== -1 && commandList.length > currentSegment) {
                const command = commandList[currentSegment];
                const remainingT = 1.0 - t_in_segment;
                
                // [MOTOR COMMAND LOGIC]
                const m1Remaining = command.m1_delta_deg * remainingT; // Base
                const m2Remaining = command.m2_delta_deg * remainingT; // Elbow

                m1Out.textContent = m1Remaining.toFixed(2) + '°';
                m2Out.textContent = m2Remaining.toFixed(2) + '°';

                // [NEW G-CODE LOGIC]
                const base_gcode = m1Remaining * GCODE_FACTOR;
                const elbow_gcode = m2Remaining * GCODE_FACTOR;
                gcodeOut.textContent = `G1 ${elbow_gcode.toFixed(3)} ${base_gcode.toFixed(3)} 1000`;

            } else {
                m1Out.textContent = '0.00°';
                m2Out.textContent = '0.00°';
                
                // [NEW G-CODE LOGIC]
                gcodeOut.textContent = 'G1 0.000 0.000 1000';
            }
            
            highlightCommand(currentSegment); // Update highlight

            // --- Clear and Setup Context ---
            ctx.clearRect(0, 0, canvasSize, canvasSize);
            ctx.save();
            ctx.translate(origin.x, origin.y);
            ctx.scale(scale, -scale); // Flip Y-axis so +y is up
            
            const line_width_scaled = 2 / scale;
            const joint_radius_scaled = 5 / scale;
            const end_effector_radius_scaled = 6 / scale;

            // --- Draw Grid ---
            ctx.strokeStyle = "#4b5563"; // gray-600
            ctx.lineWidth = 1 / scale;
            ctx.beginPath();
            // Use CANVAS_WORLD_SIZE / 2 for grid lines
            const gridMax = CANVAS_WORLD_SIZE / 2; // This is 202.6
            for (let i = -gridMax; i <= gridMax; i += 50) {
                ctx.moveTo(i, -gridMax); ctx.lineTo(i, gridMax);
                ctx.moveTo(-gridMax, i); ctx.lineTo(gridMax, i);
            }
            ctx.stroke();

            // --- Draw Axes ---
            ctx.strokeStyle = "#9ca3af"; // gray-400
            ctx.lineWidth = line_width_scaled;
            ctx.beginPath();
            ctx.moveTo(-gridMax, 0); ctx.lineTo(gridMax, 0);
            ctx.moveTo(0, -gridMax); ctx.lineTo(0, gridMax);
            ctx.stroke();
            
            // --- Draw Target Path (the straight lines) ---
            if (path.length > 0) {
                ctx.strokeStyle = "#3b82f6"; // blue-500
                ctx.lineWidth = line_width_scaled;
                ctx.setLineDash([5 / scale, 5 / scale]); // Dashed line
                ctx.beginPath();
                ctx.moveTo(HOME_POINT.x, HOME_POINT.y);
                path.forEach(p => ctx.lineTo(p.x, p.y)); 
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw path vertices
                ctx.fillStyle = "#3b82f6";
                [HOME_POINT, ...path].forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, joint_radius_scaled, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            
            // --- Draw Arm ---
            const j1_x = L1 * Math.cos(a1);
            const j1_y = L1 * Math.sin(a1);
            // End effector position is now directly from state.endX/endY
            const j2_x = endX;
            const j2_y = endY;

            // --- Draw Actual Path (Straight lines via Cartesian Interpolation) ---
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; // Faded white
            ctx.lineWidth = line_width_scaled;
            ctx.beginPath();
            if (precalculatedPath.length > 0) {
                // Ensure we draw up to the current slider position
                for(let i=0; i <= globalT_val; i++) {
                    if (!precalculatedPath[i]) continue;
                    const p = precalculatedPath[i];
                    
                    // [MODIFIED] Draw using the actual end effector coordinates (p.endX, p.endY)
                    if (i === 0) ctx.moveTo(p.endX, p.endY);
                    else ctx.lineTo(p.endX, p.endY);
                }
            }
            ctx.stroke();

            // Arm 1
            ctx.strokeStyle = "white";
            ctx.lineWidth = 6 / scale;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(j1_x, j1_y);
            ctx.stroke();
            
            // Arm 2
            ctx.strokeStyle = "#2dd4bf"; // teal-400
            ctx.lineWidth = 6 / scale;
            ctx.beginPath();
            ctx.moveTo(j1_x, j1_y);
            ctx.lineTo(j2_x, j2_y);
            ctx.stroke();
            
            // Joints
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(0, 0, joint_radius_scaled * 1.5, 0, 2 * Math.PI); // Base
            ctx.fill();
            ctx.beginPath();
            ctx.arc(j1_x, j1_y, joint_radius_scaled, 0, 2 * Math.PI); // Elbow
            ctx.fill();
            
            // End Effector
            ctx.fillStyle = "#2dd4bf";
            // This is the "out of boundary" visualization
            if (clamped) { 
                ctx.fillStyle = "#ef4444"; // red-500
            }
            ctx.beginPath();
            ctx.arc(j2_x, j2_y, end_effector_radius_scaled, 0, 2 * Math.PI);
            ctx.fill();

            // --- Restore Context ---
            ctx.restore();
        }

        /**
         * [NEW G-CODE PARSER and CARTESIAN INTERPOLATION LOGIC]
         */
        function parseCoordinates() {
            // Show loading state
            addCoordsBtn.textContent = "Calculating...";
            addCoordsBtn.disabled = true;

            // Run calculation asynchronously to allow UI to update
            setTimeout(() => {
                const text = coordsInput.value;
                
                // 1. Parse all points first
                path = text.split('\n') // 'path' is now the raw user path
                    .filter(line => line.trim() !== '')
                    .map(line => {
                        line = line.trim();
                
                        // [ROBUST REGEX]
                        const gcodeMatch = line.match(/X\s*(-?[\d.]+)\s+Y\s*(-?[\d.]+)/i);
                        if (gcodeMatch && gcodeMatch[1] != null && gcodeMatch[2] != null) {
                            const x = parseFloat(gcodeMatch[1]);
                            const y = parseFloat(gcodeMatch[2]);
                            if (!isNaN(x) && !isNaN(y)) return { x, y };
                        }

                        // Try comma-separated format
                        const commaMatch = line.match(/^(-?[\d.]+)\s*,\s*(-?[\d.]+)$/);
                        if (commaMatch && commaMatch[1] != null && commaMatch[2] != null) {
                            const x = parseFloat(commaMatch[1]);
                            const y = parseFloat(commaMatch[2]);
                            if (!isNaN(x) && !isNaN(y)) return { x, y };
                        }

                        return null; // Failed to parse
                    })
                    .filter(p => p !== null);

                
                // 2. Build Command List (No Nudge, Just Solve)
                commandList = [];
                if (path.length === 0) {
                    // ... (reset logic)
                    updateCommandListUI();
                    stopAnimation();
                    slider.value = "0";
                    slider.max = 1;
                    homeJointAngles = solveIK(HOME_POINT.x, HOME_POINT.y, Math.PI/2, 0);
                    const homeMotorCommands = solveMotorCommands(homeJointAngles.a1, homeJointAngles.a2);
                    precalculatedPath = [
                        { x: HOME_POINT.x, y: HOME_POINT.y, ...homeJointAngles, ...homeMotorCommands, clamped: false, segment: -1, t_in_segment: 0 }
                    ];
                    draw();
                    addCoordsBtn.textContent = "Set Path & Pre-Calculate Motor Commands";
                    addCoordsBtn.disabled = false;
                    return;
                }
                
                // Create a full list of points including HOME
                const pointList = [HOME_POINT, ...path];
                
                let previousA1 = homeJointAngles.a1;
                let previousA2 = homeJointAngles.a2;

                // --- 3. Pre-calculate the entire animation path (Cartesian Interpolation) ---
                precalculatedPath = [];
                
                for (let i = 0; i < pointList.length - 1; i++) {
                    const p_start = pointList[i];
                    const p_end = pointList[i+1];
                    let segmentName = (i === 0) ? `HOME -> P0` : `P${i-1} -> P${i}`;

                    let segmentStartM1 = 0; // Temp, will calculate from first point
                    let segmentStartM2 = 0; // Temp

                    for (let step = 0; step <= STEPS_PER_SEGMENT_INTERPOLATION; step++) {
                        const t_in_segment = step / STEPS_PER_SEGMENT_INTERPOLATION;
                        
                        // Linear interpolation in Cartesian space
                        const interpolatedX = p_start.x + (p_end.x - p_start.x) * t_in_segment;
                        const interpolatedY = p_start.y + (p_end.y - p_start.y) * t_in_segment;
                        
                        // Solve IK for each interpolated point
                        // [MODIFIED] store endX, endY from IK to trace the actual path
                        const { a1, a2, clamped, endX, endY } = solveIK(interpolatedX, interpolatedY, previousA1, previousA2);
                        const { m1, m2 } = solveMotorCommands(a1, a2);

                        if (step === 0) { // Store starting motor positions for this segment
                             segmentStartM1 = m1;
                             segmentStartM2 = m2;
                        }

                        precalculatedPath.push({ 
                            x: interpolatedX, 
                            y: interpolatedY, 
                            a1, a2, m1, m2, 
                            clamped, 
                            segment: i, 
                            t_in_segment,
                            endX, endY // Store actual end effector position
                        });
                        
                        previousA1 = a1;
                        previousA2 = a2;
                    }
                    
                    // After the segment, we have the final motor angles for this segment.
                    // Use these to calculate the *total* motor deltas for the command list.
                    const finalSegmentPoint = precalculatedPath[precalculatedPath.length - 1];
                    const m1_delta = finalSegmentPoint.m1 - segmentStartM1;
                    const m2_delta = finalSegmentPoint.m2 - segmentStartM2;

                    commandList.push({
                        segment: segmentName,
                        p_start: p_start,
                        p_end: p_end,
                        startJointAngles: commandList.length > 0 ? commandList[commandList.length - 1].endJointAngles : homeJointAngles,
                        endJointAngles: { a1: finalSegmentPoint.a1, a2: finalSegmentPoint.a2 },
                        startMotorCommands: commandList.length > 0 ? commandList[commandList.length - 1].endMotorCommands : solveMotorCommands(homeJointAngles.a1, homeJointAngles.a2),
                        endMotorCommands: { m1: finalSegmentPoint.m1, m2: finalSegmentPoint.m2 },
                        m1_delta_deg: m1_delta * 180 / Math.PI,
                        m2_delta_deg: m2_delta * 180 / Math.PI,
                        clamped: finalSegmentPoint.clamped
                    });
                }
                
                // Update slider max based on the new, longer precalculatedPath
                slider.max = precalculatedPath.length - 1;
                DYNAMIC_ANIMATION_SPEED = Math.max(1, Math.ceil((precalculatedPath.length -1) / 250)); // Re-calculate speed for ~4-5 sec animation

                // Update UI
                updateCommandListUI();

                // Reset animation
                stopAnimation();
                slider.value = "0";
                lastHighlightedSegment = -1; // Reset highlight
                draw();

                // Restore button
                addCoordsBtn.textContent = "Set Path & Pre-Calculate Motor Commands";
                addCoordsBtn.disabled = false;
            }, 10); // 10ms timeout
        }

        /**
         * Updates the HTML for the command list.
         */
        function updateCommandListUI() {
            commandListContainer.innerHTML = '';
            if (commandList.length === 0) {
                commandListContainer.innerHTML = '<p class="text-gray-400">Add 1 or more points to create a path from HOME.</p>';
                return;
            }

            commandList.forEach((cmd, i) => {
                const el = document.createElement('div');
                el.id = `command-segment-${i}`;
                el.className = 'command-item p-2 rounded-md';
                
                const m1Sign = cmd.m1_delta_deg >= 0 ? '+' : '';
                const m2Sign = cmd.m2_delta_deg >= 0 ? '+' : '';
                
                el.innerHTML = `
                    <div class="font-bold text-white">${i}: ${cmd.segment} ${cmd.clamped ? '<span class="text-red-400 font-normal">(Out of reach)</span>' : ''}</div>
                    <div class="font-mono text-sm ml-4 flex flex-col">
                        <span class="text-cyan-300">Motor 1 (Base): ${m1Sign}${cmd.m1_delta_deg.toFixed(2)}°</span>
                        <span class="text-purple-300">Motor 2 (Elbow): ${m2Sign}${cmd.m2_delta_deg.toFixed(2)}°</span>
                    </div>
                `;
                commandListContainer.appendChild(el);
            });
        }

        /**
         * Highlights a command in the list.
         */
        function highlightCommand(segmentIndex) {
            if (segmentIndex === lastHighlightedSegment) return; // No change

            // Remove old highlight
            if (lastHighlightedSegment !== -1) {
                const oldEl = document.getElementById(`command-segment-${lastHighlightedSegment}`);
                if (oldEl) oldEl.classList.remove('highlight');
            }

            // Add new highlight
            if (segmentIndex !== -1 && commandList.length > segmentIndex) {
                const newEl = document.getElementById(`command-segment-${segmentIndex}`);
                if (newEl) newEl.classList.add('highlight');
            }
            
            lastHighlightedSegment = segmentIndex;
        }

        /**
         * The main animation loop.
         */
        function animationLoop() {
            if (!isPlaying) return;

            let currentVal = parseInt(slider.value);
            currentVal += DYNAMIC_ANIMATION_SPEED; // Use dynamic speed

            if (currentVal >= slider.max) { // Use slider.max here
                currentVal = slider.max;
                stopAnimation();
            }

            slider.value = currentVal;
            draw();
            animationFrameId = requestAnimationFrame(animationLoop);
        }

        function stopAnimation() {
            isPlaying = false;
            playBtn.textContent = 'Play';
            playBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            playBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            // Ensure the final state is drawn correctly
            draw();
        }
        
        /**
         * Toggles the play/pause state.
         */
        function togglePlay() {
            if (commandList.length === 0) return; // Don't play if no commands

            if (isPlaying) {
                stopAnimation();
            } else {
                // If at the end, restart
                if (parseInt(slider.value) >= slider.max) { // Use slider.max
                    slider.value = "0";
                    lastHighlightedSegment = -1; // Reset highlight
                }
                
                isPlaying = true;
                playBtn.textContent = 'Pause';
                playBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                playBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                animationFrameId = requestAnimationFrame(animationLoop);
            }
        }

        // == EVENT LISTENERS ==
        window.addEventListener('load', () => {
            // [NEW] Set the text area to the user's new G-code path
            coordsInput.value = `G1 X-202.600 Y-202.600
G1 X-192.247 Y-202.600
G1 X-202.600 Y-163.963
G1 X-202.600 Y-125.326
G1 X-181.894 Y-202.600
G1 X-171.542 Y-202.600
G1 X-202.600 Y-86.689
G1 X-202.600 Y-48.052
G1 X-161.189 Y-202.600
G1 X-150.836 Y-202.600
G1 X-202.600 Y-9.415
G1 X-202.600 Y29.222
G1 X-140.483 Y-202.600
G1 X-130.131 Y-202.600
G1 X-202.600 Y67.859
G1 X-202.600 Y106.496
G1 X-119.778 Y-202.600
G1 X-109.425 Y-202.600
G1 X-202.600 Y145.133
G1 X-202.600 Y183.770
G1 X-99.072 Y-202.600
G1 X-88.720 Y-202.600
G1 X-197.293 Y202.600
G1 X-186.940 Y202.600
G1 X-78.367 Y-202.600
G1 X-68.014 Y-202.600
G1 X-176.587 Y202.600
G1 X-166.234 Y202.600
G1 X-57.661 Y-202.600
G1 X-47.309 Y-202.600
G1 X-155.882 Y202.600
G1 X-145.529 Y202.600
G1 X-36.956 Y-202.600
G1 X-26.603 Y-202.600
G1 X-135.176 Y202.600
G1 X-124.823 Y202.600
G1 X-16.250 Y-202.600
G1 X-5.898 Y-202.600
G1 X-114.471 Y202.600
G1 X-104.118 Y202.600
G1 X4.455 Y-202.600
G1 X14.808 Y-202.600
G1 X-93.765 Y202.600
G1 X-83.412 Y202.600
G1 X25.161 Y-202.600
G1 X35.514 Y-202.600
G1 X-73.059 Y202.600
G1 X-62.707 Y202.600
G1 X45.866 Y-202.600
G1 X56.219 Y-202.600
G1 X-52.354 Y202.600
G1 X-42.001 Y202.600
G1 X66.572 Y-202.600
G1 X76.925 Y-202.600
G1 X-31.648 Y202.600
G1 X-21.296 Y202.600
G1 X87.277 Y-202.600
G1 X97.630 Y-202.600
G1 X-10.943 Y202.600
G1 X-0.590 Y202.600
G1 X107.983 Y-202.600
G1 X118.336 Y-202.600
G1 X9.763 Y202.600
G1 X20.115 Y202.600
G1 X128.688 Y-202.600
G1 X139.041 Y-202.600
G1 X30.468 Y202.600
G1 X40.821 Y202.600
G1 X149.394 Y-202.600
G1 X159.747 Y-202.600
G1 X51.174 Y202.600
G1 X61.526 Y202.600
G1 X170.099 Y-202.600
G1 X180.452 Y-202.600
G1 X71.879 Y202.600
G1 X82.232 Y202.600
G1 X190.805 Y-202.600
G1 X201.158 Y-202.600
G1 X92.585 Y202.600
G1 X102.937 Y202.600
G1 X202.600 Y-169.346
G1 X202.600 Y-130.709
G1 X113.290 Y202.600
G1 X123.643 Y202.600
G1 X202.600 Y-92.072
G1 X202.600 Y-53.435
G1 X133.996 Y202.600
G1 X144.349 Y202.600
G1 X202.600 Y-14.798
G1 X202.600 Y23.840
G1 X154.701 Y202.600
G1 X165.054 Y202.600
G1 X202.600 Y62.477
G1 X202.600 Y101.114
G1 X175.407 Y202.600
G1 X185.760 Y202.600
G1 X202.600 Y139.751
G1 X202.600 Y178.388
G1 X196.112 Y202.600`;
            setupCanvas();
            parseCoordinates(); // Load default path
        });
        window.addEventListener('resize', setupCanvas);
        
        addCoordsBtn.addEventListener('click', parseCoordinates);
        
        slider.addEventListener('input', () => {
            draw(); // Just draw the pre-calculated frame
        });
        
        playBtn.addEventListener('click', togglePlay);

        // You can add an event listener for the new send button if needed
        // const sendBtn = document.getElementById('send-gcode-btn');
        // sendBtn.addEventListener('click', () => {
        //     const gcodeCommand = gcodeOut.textContent;
        //     console.log("Sending command:", gcodeCommand);
        //     // Add your send logic here (e.g., fetch, WebSocket)
        // });

    </script>
</body>
</html>
