<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sand Table Controller</title>
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <style>
        /* --- Modern Variables --- */
        :root {
            --color-accent: #d2b48c; 
            --color-selected: #4ade80; /* Vibrant Light Green */
            --color-selected-ring: #22c55e; /* Slightly darker green for border */
            
            --color-bg: #f8f9fa;
            --color-surface: #ffffff;
            --color-text: #222222;
            
            --shadow-subtle: 0 4px 6px -1px rgba(0,0,0,0.05);
            --shadow-float: 0 10px 15px -3px rgba(0,0,0,0.1);
            --radius: 16px;
        }

        body[data-theme='dark'] {
            --color-bg: #121212;
            --color-surface: #1e1e1e;
            --color-text: #e0e0e0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            margin: 0;
            padding-bottom: 100px;
            transition: background 0.3s, color 0.3s;
        }

        /* --- Header --- */
        header {
            position: sticky; top: 0; z-index: 100;
            background: rgba(255, 255, 255, 0.90);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0,0,0,0.05);
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; height: 60px;
        }
        
        body[data-theme='dark'] header { 
            background: rgba(30, 30, 30, 0.90); 
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .header-title { font-weight: 700; font-size: 1.1rem; letter-spacing: -0.5px; }
        .icon-btn { background: none; border: none; font-size: 1.2rem; cursor: pointer; color: var(--color-text); }

        /* --- Hero Image --- */
        .hero-container {
            width: 100%; max-width: 1200px; margin: 0 auto;
            padding: 20px 15px 0;
        }
        .hero-image {
            width: 100%; height: 200px; object-fit: cover;
            border-radius: var(--radius);
            box-shadow: var(--shadow-subtle);
        }

        /* --- Controls --- */
        .controls-wrapper {
            max-width: 1200px; margin: 20px auto 10px; padding: 0 15px;
        }
        
        .status-pill {
            background: var(--color-accent); color: #fff;
            padding: 4px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;
            opacity: 0; transition: opacity 0.3s; display: inline-block; margin-bottom: 10px;
        }

        .main-actions {
            display: flex; gap: 10px; overflow-x: auto; padding-bottom: 5px;
        }
        
        select, button.action-btn {
            background: var(--color-surface); color: var(--color-text);
            border: 1px solid rgba(0,0,0,0.1); padding: 10px 16px;
            border-radius: 12px; font-weight: 600; font-size: 0.9rem;
            cursor: pointer; box-shadow: var(--shadow-subtle);
            white-space: nowrap;
        }
        
        button.action-btn:active { transform: scale(0.98); }
        .btn-primary { background: var(--color-accent) !important; color: white !important; border: none !important; }

        /* --- Grid --- */
        .grid {
            display: grid; gap: 16px; padding: 15px;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            max-width: 1200px; margin: 0 auto;
        }

        .card {
            background: var(--color-surface); border-radius: var(--radius);
            overflow: hidden; position: relative;
            box-shadow: var(--shadow-subtle);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            border: 2px solid transparent; /* Prepare for border */
        }

        .card:hover { transform: translateY(-2px); }
        
        /* SELECTED STATE (Green) */
        .card.selected { 
            border-color: var(--color-selected-ring); 
            background-color: rgba(74, 222, 128, 0.05);
            transform: scale(0.98); 
        }

        .card-img-wrap { 
            position: relative; 
            aspect-ratio: 1/1; 
            background: #fff; 
            width: 100%;
        }
        
        .card canvas { 
            width: 100%; 
            height: 100%; 
            display: block; 
        }
        
        /* Select Dot */
        .select-dot {
            position: absolute; top: 10px; right: 10px;
            width: 24px; height: 24px; border-radius: 50%;
            background: rgba(0,0,0,0.2); border: 2px solid #fff;
            z-index: 10; transition: 0.2s;
        }
        
        /* Dot when selected */
        .card.selected .select-dot {
            background: var(--color-selected);
            box-shadow: 0 0 0 2px var(--color-surface);
            border-color: var(--color-selected);
        }
        
        .card-body { padding: 12px; }
        .card-title {
            margin: 0; font-size: 0.9rem; font-weight: 600;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .card-meta { font-size: 0.75rem; opacity: 0.6; margin-top: 4px; }

        /* --- Floating Selection Bar --- */
        .selection-bar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(150px);
            background: var(--color-text); color: var(--color-bg);
            padding: 12px 20px; border-radius: 50px;
            display: flex; gap: 15px; align-items: center;
            box-shadow: var(--shadow-float); z-index: 1000;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            min-width: 300px; justify-content: space-between;
        }
        
        .selection-bar.active { transform: translateX(-50%) translateY(0); }
        
        .bar-actions { display: flex; gap: 10px; }
        .bar-btn {
            background: rgba(255,255,255,0.2); border: none; color: inherit;
            padding: 8px 16px; border-radius: 20px; cursor: pointer; font-size: 0.9rem; font-weight: 600;
        }
        .bar-btn.danger { background: #ff4d4d; color: white; }

        /* --- Sidebar --- */
        .sidebar {
            height: 100%; width: 0; position: fixed; top: 0; left: 0;
            background: var(--color-surface); overflow-x: hidden; z-index: 1100;
            transition: 0.3s; padding-top: 20px;
            border-right: 1px solid rgba(0,0,0,0.1);
        }
        .sidebar a {
            padding: 15px 25px; text-decoration: none; font-size: 1.1rem;
            color: var(--color-text); display: block; font-weight: 600;
        }
        .overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.5); z-index: 1050; display: none;
        }

    </style>
</head>
<body data-theme="light">

    <header>
        <button class="icon-btn" onclick="openNav()">☰</button>
        <div class="header-title">Design Library <span id="q-badge" style="font-size:0.8em; opacity:0.5; margin-left:5px;"></span></div>
        <button class="icon-btn" onclick="toggleTheme()">◑</button>
    </header>

    <div id="overlay" class="overlay" onclick="closeNav()"></div>
    <div id="mySidebar" class="sidebar">
        <div style="padding:0 25px; margin-bottom:20px; opacity:0.5; font-size:0.9rem;">MENU</div>
        <a href="/">Designs</a>
        <a href="/AI_builder">AI Builder</a>
        <a href="/led_controls">LED Controls</a>
        <a href="/terminal">Terminal</a>
    </div>

    <div class="hero-container">
        <img src="/static/sand.png" alt="Sand Table" class="hero-image">
    </div>

    <div class="controls-wrapper">
        <div id="status-pill" class="status-pill">Ready</div>
        
        <div class="main-actions">
            <select id="speedSelect">
                <option value="0.5">Speed: Fast</option>
                <option value="1.0" selected>Speed: Normal</option>
                <option value="2.0">Speed: Slow</option>
            </select>
            <button class="action-btn btn-primary" onclick="resumeDesign()">Resume</button>
            <button class="action-btn" onclick="pauseDesign()">Pause</button>
            <button class="action-btn" onclick="clearQueue()">Clear Queue</button>
        </div>
    </div>

    <div id="grid" class="grid">
        </div>
    <div style="text-align:center; margin-top:20px;">
        <button id="more-btn" class="action-btn" style="display:none;" onclick="showAll()">Show All Designs</button>
    </div>

    <div id="selection-bar" class="selection-bar">
        <span style="font-weight:600; padding-left:5px;" id="sel-count">0 Selected</span>
        <div class="bar-actions">
            <button class="bar-btn" onclick="copySelected()">Copy Code</button>
            <button class="bar-btn danger" onclick="deleteSelected()">Delete</button>
        </div>
    </div>

    <script>
        const BASE_URL = `${window.location.protocol}//${window.location.host}`;
        let selectedFiles = new Set();
        let allFiles = [];

        // --- KINEMATIC VARIABLES ---
        const L1 = 101.3;
        const L2 = 101.3;
        const GEAR_RATIO = 9/8;
        const STEPS_PER_DEG = 3200/360;
        const STEPS_PER_RAD = STEPS_PER_DEG * (180 / Math.PI);
        const lerp = (a, b, t) => a + (b - a) * t;

        // --- OBSERVER FOR LAZY LOADING ---
        // This makes the page load instantly by only calculating math for visible cards
        const observer = new IntersectionObserver((entries, obs) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const canvas = entry.target;
                    const filename = canvas.dataset.filename;
                    loadPreviewForCanvas(canvas, filename);
                    obs.unobserve(canvas); // Only load once
                }
            });
        }, { rootMargin: "100px" });

        function calculateFK(p0, base_steps, elbow_steps) {
            const alpha_rad = -base_steps / STEPS_PER_RAD;
            const beta_rad = -elbow_steps / STEPS_PER_RAD;
            const theta1 = alpha_rad;
            const theta_bend = beta_rad - (GEAR_RATIO * alpha_rad);
            const theta2_global = theta1 + theta_bend;
            const p1 = { x: p0.x + L1 * Math.cos(theta1), y: p0.y + L1 * Math.sin(theta1) };
            const p2 = { x: p1.x + L2 * Math.cos(theta2_global), y: p1.y + L2 * Math.sin(theta2_global) };
            return { p1, p2, target_base_steps: base_steps, target_elbow_steps: elbow_steps, theta1_rad: theta1, theta2_global_rad: theta2_global };
        }

        function getInterpolatedState(from, to, progress) {
            const theta1_rad = lerp(from.theta1_rad, to.theta1_rad, progress);
            const theta2_global_rad = lerp(from.theta2_global_rad, to.theta2_global_rad, progress);
            const p0 = {x:0, y:0};
            const p1 = { x: p0.x + L1 * Math.cos(theta1_rad), y: p0.y + L1 * Math.sin(theta1_rad) };
            const p2 = { x: p1.x + L2 * Math.cos(theta2_global_rad), y: p1.y + L2 * Math.sin(theta2_global_rad) };
            return { p2 };
        }

        function calculateTracePath(commands) {
            let tracePath = [];
            let cumulativeStates = [];
            let total_base_steps = 0;
            let total_elbow_steps = 0;
            const p0 = {x:0, y:0};

            cumulativeStates.push(calculateFK(p0, 0, 0));

            for (const cmd of commands) {
                total_base_steps += cmd.base;
                total_elbow_steps += cmd.elbow;
                cumulativeStates.push(calculateFK(p0, total_base_steps, total_elbow_steps));
            }

            if (cumulativeStates.length < 2) return [];
            tracePath.push(cumulativeStates[0].p2);

            for (let i = 0; i < cumulativeStates.length - 1; i++) {
                const fromState = cumulativeStates[i];
                const toState = cumulativeStates[i+1];
                
                const base_delta = Math.abs(toState.target_base_steps - fromState.target_base_steps);
                const elbow_delta = Math.abs(toState.target_elbow_steps - fromState.target_elbow_steps);
                const max_step_delta = Math.max(base_delta, elbow_delta);

                // --- OPTIMIZATION: Reduce resolution for faster rendering ---
                // Previous: / 200. New: / 600. Draws 3x fewer points per line. 
                // Still looks smooth on mobile screens.
                const stepsPerSegment = Math.max(2, Math.ceil(max_step_delta / 600)); 

                for (let j = 1; j <= stepsPerSegment; j++) {
                    const progress = j / stepsPerSegment;
                    const interpolatedState = getInterpolatedState(fromState, toState, progress);
                    tracePath.push(interpolatedState.p2);
                }
            }
            return tracePath;
        }

        function drawTrace(canvas, text) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height); // Transparent background

            const commands = text.split('\n')
                .filter(line => line.trim().toUpperCase().startsWith('G1'))
                .map(line => {
                    const parts = line.trim().substring(2).trim().split(/\s+/).map(s => parseInt(s.trim(), 10));
                    return { elbow: parts[0] || 0, base: parts[1] || 0 };
                });

            if (commands.length === 0) return;

            const tracePath = calculateTracePath(commands);

            // --- AUTO-SCALING LOGIC (Fixing Squish) ---
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            for (const p of tracePath) {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
            }

            // Calculate width and height of the drawing itself
            const drawingW = maxX - minX || 1;
            const drawingH = maxY - minY || 1;

            // Use the LARGER dimension to determine scale. 
            // This ensures aspect ratio is 1:1.
            const maxDim = Math.max(drawingW, drawingH);
            const scale = (width / maxDim) * 0.9; // 90% fill

            const cx = (minX + maxX)/2;
            const cy = (minY + maxY)/2;
            const w2 = width/2;
            const h2 = height/2;

            ctx.beginPath();
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1.5;

            // Draw with optimized path
            if(tracePath.length > 0) {
                 const startX = w2 + (tracePath[0].x - cx) * scale;
                 const startY = h2 + (tracePath[0].y - cy) * -scale; 
                 ctx.moveTo(startX, startY);
            }

            for (let i = 1; i < tracePath.length; i++) {
                const p = tracePath[i];
                const x = w2 + (p.x - cx) * scale;
                const y = h2 + (p.y - cy) * -scale; 
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // --- APP LOGIC ---

        function toggleTheme() {
            let b = document.body;
            let n = b.getAttribute('data-theme')==='dark'?'light':'dark';
            b.setAttribute('data-theme', n);
        }

        function showStatus(msg) {
            let el = document.getElementById('status-pill');
            el.textContent = msg; el.style.opacity = '1';
            setTimeout(()=>el.style.opacity='0', 3000);
        }

        function toggleSelect(filename, event) {
            event.stopPropagation();
            if(selectedFiles.has(filename)) selectedFiles.delete(filename);
            else selectedFiles.add(filename);
            renderSelectionState();
        }

        function renderSelectionState() {
            document.querySelectorAll('.card').forEach(card => {
                let fname = card.getAttribute('data-name');
                if(selectedFiles.has(fname)) card.classList.add('selected');
                else card.classList.remove('selected');
            });

            let bar = document.getElementById('selection-bar');
            let count = document.getElementById('sel-count');
            
            if(selectedFiles.size > 0) {
                bar.classList.add('active');
                count.textContent = `${selectedFiles.size} Selected`;
            } else {
                bar.classList.remove('active');
            }
        }

        async function deleteSelected() {
            let filesToDelete = [];
            let protectedCount = 0;

            for(let f of selectedFiles) {
                let card = document.querySelector(`.card[data-name="${f}"]`);
                if(card && card.dataset.hasPng === "true") {
                    protectedCount++;
                } else {
                    filesToDelete.push(f);
                }
            }

            if(filesToDelete.length === 0) {
                if(protectedCount > 0) alert("Selected designs are protected (they have PNGs).");
                return;
            }

            let confirmMsg = `Delete ${filesToDelete.length} designs?`;
            if(protectedCount > 0) confirmMsg += `\n(${protectedCount} skipped because protected).`;
            
            if(!confirm(confirmMsg)) return;
            
            for(let f of filesToDelete) {
                try {
                    await fetch(`${BASE_URL}/delete_design`, {
                        method: "POST", headers:{"Content-Type":"application/json"},
                        body: JSON.stringify({filename: f})
                    });
                } catch(e) { console.error(e); }
            }
            
            selectedFiles.clear();
            renderSelectionState();
            loadLibrary(); 
            showStatus("Deletion Complete");
        }

        async function copySelected() {
            let fullText = "";
            showStatus("Fetching code...");
            
            for(let f of selectedFiles) {
                try {
                    let res = await fetch(`${BASE_URL}/designs/${f}`);
                    let txt = await res.text();
                    fullText += `; ${f}\n${txt}\n`;
                } catch(e) {}
            }
            
            navigator.clipboard.writeText(fullText).then(() => {
                showStatus("Copied!");
                selectedFiles.clear();
                renderSelectionState();
            });
        }

        async function runDesign(filename) {
            let spd = document.getElementById('speedSelect').value;
            showStatus("Queueing...");
            
            try {
                let res = await fetch(`${BASE_URL}/designs/${filename}`);
                let txt = await res.text();
                
                let modLines = [];
                for(let line of txt.split('\n')) {
                    let trim = line.trim();
                    if(trim.toUpperCase().startsWith('G1')) {
                        let parts = trim.substring(2).trim().split(/\s+/);
                        let d = parts[2] ? parseInt(parts[2]) : 1000;
                        d = Math.round(d * parseFloat(spd));
                        modLines.push(`G1 ${parts[0]} ${parts[1]} ${d}`);
                    } else {
                        modLines.push(trim);
                    }
                }
                
                await fetch(`${BASE_URL}/send_gcode_block`, {
                    method:"POST", headers:{"Content-Type":"application/json"},
                    body: JSON.stringify({ gcode: modLines.join('\n'), filename: filename })
                });
                
                showStatus("Added to Queue");
                updateQ();
            } catch(e) { showStatus("Error"); }
        }

        function sendCmd(c) { 
            fetch(`${BASE_URL}/send`, {
                method:"POST",headers:{"Content-Type":"application/json"},
                body:JSON.stringify({command:c})
            }).then(()=>showStatus("Sent: "+c)); 
        }
        function pauseDesign() { sendCmd('PAUSE'); }
        function resumeDesign() { sendCmd('RESUME'); }
        function clearQueue() { sendCmd('CLEAR'); updateQ(); }
        
        async function updateQ() {
            try {
                let r = await fetch(`${BASE_URL}/queue_count`);
                let d = await r.json();
                document.getElementById('q-badge').textContent = d.count > 0 ? `Q: ${d.count}` : '';
            } catch(e){}
        }

        async function loadLibrary() {
            let g = document.getElementById('grid');
            g.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:40px;">Loading...</div>';
            
            try {
                let res = await fetch(`${BASE_URL}/api/designs`);
                let files = await res.json();
                allFiles = files;
                renderGrid(files.slice(0, 15)); 
                if(files.length > 15) document.getElementById('more-btn').style.display='inline-block';
            } catch(e) {
                g.innerHTML = 'Error loading files.';
            }
        }
        
        function showAll() {
            renderGrid(allFiles);
            document.getElementById('more-btn').style.display='none';
        }

        // --- RENDER GRID WITH LAZY LOADING ---
        function renderGrid(files) {
            let g = document.getElementById('grid');
            g.innerHTML = '';
            
            files.forEach(f => {
                let clean = f.replace('.txt','');
                let div = document.createElement('div');
                div.className = 'card';
                div.setAttribute('data-name', f);
                div.dataset.hasPng = "false"; 

                div.onclick = (e) => {
                   if(e.target.className !== 'select-dot') runDesign(f);
                };
                
                let dot = document.createElement('div');
                dot.className = 'select-dot';
                dot.onclick = (e) => toggleSelect(f, e);
                
                div.innerHTML = `
                    <div class="card-img-wrap">
                        <canvas id="cvs-${clean}" data-filename="${f}" width="300" height="300"></canvas>
                    </div>
                    <div class="card-body">
                        <h3 class="card-title">${clean}</h3>
                        <div class="card-meta">Est: <span id="time-${clean}">...</span></div>
                    </div>
                `;
                div.querySelector('.card-img-wrap').appendChild(dot);
                g.appendChild(div);

                // Observe the canvas for lazy loading
                const canvas = div.querySelector('canvas');
                observer.observe(canvas);
            });
            renderSelectionState();
        }

        // Called when canvas scrolls into view
        function loadPreviewForCanvas(canvas, filename) {
            const clean = filename.replace('.txt', '');
            const card = canvas.closest('.card');
            
            const img = new Image();
            img.src = `${BASE_URL}/designs/${clean}.png`;
            
            img.onload = () => {
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                card.dataset.hasPng = "true";
            };
            
            img.onerror = () => {
                card.dataset.hasPng = "false";
                // Fetch text and calculate trace
                fetch(`${BASE_URL}/designs/${filename}`)
                    .then(r => r.text())
                    .then(t => {
                        drawTrace(canvas, t);
                        // Calc time only if we had to fetch the text anyway
                        let time=0;
                        t.split('\n').forEach(l=>{
                             if(l.toUpperCase().startsWith('G1')) {
                                 let p=l.substring(2).split(/\s+/);
                                 let s=Math.max(Math.abs(parseInt(p[0])||0), Math.abs(parseInt(p[1])||0));
                                 time += s*(parseInt(p[2])||1000);
                             }
                        });
                        document.getElementById(`time-${clean}`).textContent = Math.ceil(time/60000000) + " min";
                    });
            };
        }

        function openNav() { document.getElementById('mySidebar').style.width="250px"; document.getElementById('overlay').style.display="block"; }
        function closeNav() { document.getElementById('mySidebar').style.width="0"; document.getElementById('overlay').style.display="none"; }

        // Init
        loadLibrary();
        updateQ(); setInterval(updateQ, 5000);
    </script>
</body>
</html>
