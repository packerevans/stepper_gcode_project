<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Packers Sand Table Designs</title>
    
    <link rel="icon" type="image/png" sizes="192x192" href="/static/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icons/icon-512.png">
    
<style>
    /* --- Root Variables (Light Mode) --- */
    :root {
        --color-primary: #d2b48c; /* Khaki/Tan (Button/Sidebar Background) */
        --color-secondary: #b08d5c; /* Darker Tan (Button Hover/Accent) */
        --color-background: #f0f0f0; /* Light Gray Background */
        --color-surface: #ffffff; /* White Card/Container Background */
        --color-text: #333333;
        --color-shadow: rgba(0, 0, 0, 0.08);
        --color-icon: #000000;
        
        --border-radius: 12px;
    }

    /* --- Dark Mode Variables --- */
    body[data-theme='dark'] {
        --color-background: #1e1e1e;
        --color-surface: #2c2c2c;
        --color-text: #e0e0e0;
        --color-shadow: rgba(255, 255, 255, 0.08);
        --color-icon: #ffffff;
    }
    
    /* --- Base Styles --- */
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: var(--color-background);
        color: var(--color-text);
        padding: 0;
        margin: 0;
        transition: background 0.3s, color 0.3s;
    }

    /* --- Sidebar & Header (Copied from your example) --- */
    .sidebar {
        height: 100%; width: 0; position: fixed; top: 0; left: 0;
        background-color: var(--color-primary); overflow-x: hidden;
        transition: 0.3s; padding-top: 60px; z-index: 1000;
        box-shadow: 2px 0 5px var(--color-shadow);
    }

    .sidebar a {
        padding: 15px 24px; text-decoration: none; font-size: 18px;
        color: var(--color-text); display: block; transition: 0.2s;
        font-weight: 500;
    }

    .sidebar a:hover {
        background-color: var(--color-secondary);
        color: var(--color-surface);
    }

    .openbtn {
        font-size: 26px; cursor: pointer; background-color: var(--color-primary);
        color: var(--color-text); padding: 10px 20px; border: none;
        border-radius: 0 0 var(--border-radius) 0; position: fixed;
        top: 0; left: 0; z-index: 1100; box-shadow: 0 2px 5px var(--color-shadow);
    }
    
    /* --- Theme Toggle Button (Copied) --- */
    #themeToggle {
        position: fixed; top: 15px; right: 15px; background: var(--color-surface);
        color: var(--color-icon); border: 1px solid var(--color-icon);
        /* OLD: padding: 8px 15px; */
        padding: 6px 12px; /* NEW: Reduced padding */
        border-radius: 20px; z-index: 1200;
        transition: background 0.3s, color 0.3s, border-color 0.3s;
        
        /* NEW: Control the emoji size and line height */
        font-size: 14px;
        line-height: 1.2;
    }
    
    .main-content {
        margin-left: 0; transition: margin-left 0.3s; padding: 20px;
        max-width: 1200px; /* Wider for a grid */
        margin: 0 auto;
    }

    h1 {
        text-align: center; margin-top: 20px; margin-bottom: 30px;
        font-weight: 300; color: var(--color-secondary);
    }

    .header-image {
        width: 100%; max-height: 250px; object-fit: cover;
        border-radius: var(--border-radius); margin-bottom: 30px;
        box-shadow: 0 4px 15px var(--color-shadow);
    }
    
    /* --- NEW: Status Message Bar --- */
    .status-message {
        padding: 15px 20px;
        border-radius: var(--border-radius);
        margin-bottom: 24px;
        font-weight: 600;
        display: none; /* Hidden by default */
        border: 2px solid;
        text-align: center;
    }
    .status-success {
        background: #e6f4e6;
        color: #2e7d32;
        border-color: #2e7d32;
    }
    .status-error {
        background: #fde6e6;
        color: #c62828;
        border-color: #c62828;
    }
    body[data-theme='dark'] .status-success {
        background: #2c3a2c;
        color: #a5d6a7;
        border-color: #a5d6a7;
    }
    body[data-theme='dark'] .status-error {
        background: #3a2c2c;
        color: #ef9a9a;
        border-color: #ef9a9a;
    }
    /* --- End Status Message --- */

    /* --- Design Grid Styles --- */
    .design-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 24px;
    }

    .design-card {
        background-color: var(--color-surface);
        border-radius: var(--border-radius);
        box-shadow: 0 4px 10px var(--color-shadow);
        overflow: hidden; 
        display: flex;
        flex-direction: column;
        transition: box-shadow 0.2s;
    }

    .design-card:hover {
        box-shadow: 0 8px 20px var(--color-shadow);
    }
    
    .design-card canvas {
        width: 100%;
        aspect-ratio: 1 / 1;
        display: block;
        background-color: #fff; 
    }

    .design-card .card-content {
        padding: 20px;
        display: flex;
        flex-direction: column;
        flex-grow: 1; 
    }

    .design-card h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-weight: 600;
        color: var(--color-text);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    /* --- Button Style (Copied) --- */
    button {
        background-color: var(--color-primary);    
        color: var(--color-text);
        border: none; padding: 12px 25px; border-radius: 8px; font-size: 16px;
        cursor: pointer; transition: background-color 0.2s, box-shadow 0.2s, opacity 0.2s;
        font-weight: 600;
        width: 100%;
        margin-top: auto; /* Pushes button to the bottom */
    }

    button:hover {
        background-color: var(--color-secondary);
        box-shadow: 0 2px 8px var(--color-shadow);
    }
    
    /* --- NEW: Disabled button style --- */
    button:disabled {
        background-color: var(--color-secondary);
        opacity: 0.6;
        cursor: not-allowed;
    }
    
    /* --- Mobile Responsiveness (Copied) --- */
    @media (max-width: 600px) {
        .main-content {
            padding: 10px;
        }
        .header-image {
            max-height: 120px;
            margin-bottom: 15px;
        }
        h1, h2 {
            font-size: 1.5em;
            margin-bottom: 15px;
        }
        .design-grid {
            grid-template-columns: 1fr;
            gap: 15px;
        }
        .design-card .card-content {
            padding: 15px;
        }
    }
</style>
    
</head>
<body data-theme="light">
    <!-- Sidebar (Copied) -->
    <div id="mySidebar" class="sidebar">
        <a href="javascript:void(0)" onclick="closeNav()">‚úñ Close</a>
        <a href="/">Controls</a>
        <a href="/designs">Designs</a> 
        <a href="/led_controls">Led Controls</a>
        <a href="/terminal">Terminal</a>
    </div>

    <!-- Header Buttons (Copied) -->
    <button class="openbtn" onclick="openNav()">‚ò∞</button>
    <button id="themeToggle" onclick="toggleDarkMode()">
        <span id="themeIcon">‚òÄÔ∏è</span>
    </button>

    <!-- Main Content -->
    <div class="main-content">
        <img src="/static/sand.png" alt="Sand Table Header" class="header-image">
        <h1>Design Library</h1>
        
        <!-- NEW: Status message placeholder -->
        <div id="statusMessage" class="status-message"></div>

        <div id="designGridContainer" class="design-grid">
            <!-- 
              Design cards will be inserted here dynamically.
              Example structure:
              <div class="design-card">
                  <canvas id="canvas-spiral.txt" width="400" height="400"></canvas>
                  <div class="card-content">
                      <h3>spiral.txt</h3>
                      <button onclick="runDesign('spiral.txt', this)">Run Design</button>
                  </div>
              </div>
            -->
        </div>
    </div>

<script>
    // ######################################################################
    // ##  START: KINEMATIC SIMULATOR LOGIC (Unchanged)
    // ######################################################################

    // --- Simulation Constants ---
    const L1 = 101.3;
    const L2 = 101.3;
    const GEAR_RATIO = 9 / 8;
    const STEPS_PER_DEG = 3200 / 360;
    const STEPS_PER_RAD = STEPS_PER_DEG * (180 / Math.PI);

    function generateTracePathFromText(commandText) {
        const commands = commandText.split('\n')
            .filter(line => line.trim().startsWith('G1'))
            .map(line => {
                const parts = line.trim().substring(2).trim().split(/\s+/).map(s => parseInt(s.trim(), 10));
                return { 
                    elbow: parts[0] || 0, 
                    base: parts[1] || 0, 
                    step_delay_us: parts[2] !== undefined ? parts[2] : 1000 
                };
            });
        if (commands.length === 0) return [];
        const cumulativeStates = calculateAllStates(commands);
        const tracePath = calculateTracePath(cumulativeStates);
        return tracePath;
    }

    function calculateAllStates(commands) {
        let cumulativeStates = [];
        let total_base_steps = 0;
        let total_elbow_steps = 0;
        const p0 = { x: 0, y: 0 };
        cumulativeStates.push(calculateFK(p0, 0, 0));
        for (const cmd of commands) {
            total_base_steps += cmd.base;
            total_elbow_steps += cmd.elbow;
            const state = calculateFK(p0, total_base_steps, total_elbow_steps);
            cumulativeStates.push(state);
        }
        return cumulativeStates;
    }

    function calculateTracePath(cumulativeStates) {
        let tracePath = [];
        if (cumulativeStates.length < 2) return;
        tracePath.push(cumulativeStates[0].p2); 
        for (let i = 0; i < cumulativeStates.length - 1; i++) {
            const fromState = cumulativeStates[i];
            const toState = cumulativeStates[i+1];
            const base_delta = Math.abs(toState.target_base_steps - fromState.target_base_steps);
            const elbow_delta = Math.abs(toState.target_elbow_steps - fromState.target_elbow_steps);
            const max_step_delta = Math.max(base_delta, elbow_delta);
            const stepsPerSegment = Math.max(20, Math.ceil(max_step_delta / 100));
            for (let j = 1; j <= stepsPerSegment; j++) {
                const progress = j / stepsPerSegment;
                const interpolatedState = getInterpolatedState(fromState, toState, progress);
                tracePath.push(interpolatedState.p2);
            }
        }
        return tracePath;
    }

    function calculateFK(p0, base_steps, elbow_steps) {
        const alpha_rad = -base_steps / STEPS_PER_RAD;
        const beta_rad = -elbow_steps / STEPS_PER_RAD;  
        const theta1 = alpha_rad;
        const theta_bend = beta_rad - (GEAR_RATIO * alpha_rad);
        const theta2_global = theta1 + theta_bend;
        const p1 = { x: p0.x + L1 * Math.cos(theta1), y: p0.y + L1 * Math.sin(theta1) };
        const p2 = { x: p1.x + L2 * Math.cos(theta2_global), y: p1.y + L2 * Math.sin(theta2_global) };
        return { p0, p1, p2, target_base_steps: base_steps, target_elbow_steps: elbow_steps, theta1_rad: theta1, theta_bend_rad: theta_bend, theta2_global_rad: theta2_global };
    }

    const lerp = (a, b, t) => a + (b - a) * t;

    function getInterpolatedState(from, to, progress) {
        const theta1_rad = lerp(from.theta1_rad, to.theta1_rad, progress);
        const theta_bend_rad = lerp(from.theta_bend_rad, to.theta_bend_rad, progress);
        const theta2_global_rad = lerp(from.theta2_global_rad, to.theta2_global_rad, progress);
        const p0 = from.p0;
        const p1 = { x: p0.x + L1 * Math.cos(theta1_rad), y: p0.y + L1 * Math.sin(theta1_rad) };
        const p2 = { x: p1.x + L2 * Math.cos(theta2_global_rad), y: p1.y + L2 * Math.sin(theta2_global_rad) };
        return { p0, p1, p2 };
    }

    function drawTraceOnCanvas(canvas, tracePath) {
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);
        if (tracePath.length < 2) return;
        let minX = tracePath[0].x, maxX = tracePath[0].x;
        let minY = tracePath[0].y, maxY = tracePath[0].y;
        for (const p of tracePath) {
            if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
        }
        const drawingWidth = (maxX - minX) || 1;
        const drawingHeight = (maxY - minY) || 1;
        const padding = 0.1;
        const scale = Math.min(width / drawingWidth, height / drawingHeight) * (1 - padding);
        const drawCenterX = (minX + maxX) / 2;
        const drawCenterY = (minY + maxY) / 2;
        const canvasCenterX = width / 2;
        const canvasCenterY = height / 2;
        ctx.beginPath();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        for (let i = 0; i < tracePath.length; i++) {
            const p = tracePath[i];
            const canvasX = canvasCenterX + (p.x - drawCenterX) * scale;
            const canvasY = canvasCenterY + (p.y - drawCenterY) * -scale; 
            if (i === 0) ctx.moveTo(canvasX, canvasY);
            else ctx.lineTo(canvasX, canvasY);
        }
        ctx.stroke();
    }

    // ######################################################################
    // ##  END: KINEMATIC SIMULATOR LOGIC
    // ######################################################################


    // ######################################################################
    // ##  START: PAGE UI & FETCH LOGIC (UPDATED)
    // ######################################################################

    // --- Sidebar Functions (Copied) ---
    function openNav() {
        document.getElementById("mySidebar").style.width = "200px";
        const main = document.querySelector(".main-content");
        if (main) main.style.marginLeft = "200px";
    }

    function closeNav() {
        document.getElementById("mySidebar").style.width = "0";
        const main = document.querySelector(".main-content");
        if (main) main.style.marginLeft = "0";
    }

    // --- Dark Mode Toggle (Copied) ---
    function updateThemeIcon(theme) {
        document.getElementById('themeIcon').textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
    }

    function toggleDarkMode() {
        const body = document.body;
        const currentTheme = body.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        body.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        updateThemeIcon(newTheme);
    }
    
    /**
     * NEW: Displays a status message at the top of the grid.
     */
    function showStatusMessage(message, isError = false) {
        const statusEl = document.getElementById('statusMessage');
        if (!statusEl) return;

        statusEl.textContent = message;
        statusEl.className = isError ? 'status-message status-error' : 'status-message status-success';
        statusEl.style.display = 'block'; // Make it visible

        // Hide it after 5 seconds
        setTimeout(() => {
            statusEl.style.display = 'none';
        }, 5000);
    }

    /**
     * UPDATED: This function now sends the G-code to your server.
     * It's called by the "Run Design" button.
     */
    async function runDesign(filename, buttonElement) {
        // 1. Disable button to prevent double-clicks
        buttonElement.disabled = true;
        buttonElement.textContent = 'Sending...';

        // This path must match the route in your app.py
        const txtPath = `/designs/${filename}`;

        try {
            // 2. Fetch the .txt file content from the server
            const response = await fetch(txtPath);
            if (!response.ok) {
                throw new Error(`File not found: ${filename}. Check server logs.`);
            }
            const gcodeBlock = await response.text();

            // 3. Send the G-code block to your server's auto-drip endpoint
            const apiResponse = await fetch("/send_gcode_block", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ gcode: gcodeBlock })
            });

            const result = await apiResponse.json();

            if (!apiResponse.ok || result.success === false) {
                // This error is from your app.py (e.g., "Arduino not connected.")
                throw new Error(result.error || "Failed to send block to server.");
            }

            // 4. Show success message
            showStatusMessage(`Successfully sent "${filename}" to the sand table. It is now running.`);

        } catch (error) {
            // 5. Show error message
            console.error("Error running design:", error);
            showStatusMessage(`Error: ${error.message}`, true);
        } finally {
            // 6. Re-enable the button, whether it succeeded or failed
            buttonElement.disabled = false;
            buttonElement.textContent = 'Run Design';
        }
    }

    /**
     * Main function to fetch and display all designs.
     */
    async function loadDesignLibrary() {
        const gridContainer = document.getElementById('designGridContainer');
        if (!gridContainer) return;

        try {
            // --- 1. Get list of design files (MOCK) ---
            // !!! REMEMBER to replace 'fetchMockDesignList' with a real API call
            // that returns a list of your .txt filenames.
            const designFiles = await fetchMockDesignList(); 
            
            // --- 2. Process each file ---
            for (const filename of designFiles) {
                const card = document.createElement('div');
                card.className = 'design-card';
                
                const canvasSize = 400; 
                
                // UPDATED: Button text changed to "Run Design"
                // UPDATED: onclick calls runDesign() and passes 'this' (the button)
                card.innerHTML = `
                    <canvas id="canvas-${filename}" width="${canvasSize}" height="${canvasSize}"></canvas>
                    <div class="card-content">
                        <h3>${filename}</h3>
                        <button onclick="runDesign('${filename}', this)">Run Design</button>
                    </div>
                `;
                gridContainer.appendChild(card);
                
                // --- 3. Load preview (PNG or generate from TXT) ---
                loadPreview(filename);
            }
            
        } catch (error) {
            console.error("Failed to load design library:", error);
            gridContainer.innerHTML = "<p>Error loading design library. See console for details.</p>";
        }
    }
    
    /**
     * Tries to load a .png preview. If it fails, generates one from .txt.
     * (Unchanged)
     */
    function loadPreview(filename) {
        const canvas = document.getElementById(`canvas-${filename}`);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const baseName = filename.replace('.txt', '');
        // This path must match the route in your app.py
        const pngPath = `/designs/${baseName}.png`;
        const txtPath = `/designs/${baseName}.txt`;

        const img = new Image();
        img.src = pngPath;

        img.onload = () => {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };

        img.onerror = () => {
            console.log(`No .png found for ${filename}, generating from .txt...`);
            fetch(txtPath)
                .then(response => {
                    if (!response.ok) throw new Error(`File not found: ${txtPath}`);
                    return response.text();
                })
                .then(commandText => {
                    const tracePath = generateTracePathFromText(commandText);
                    drawTraceOnCanvas(canvas, tracePath);
                })
                .catch(err => {
                    console.error(`Failed to generate preview for ${filename}:`, err);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'red';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Error loading file', canvas.width / 2, canvas.height / 2);
                });
        };
    }
    
    // ######################################################################
    // ##  MOCK FUNCTIONS (Replace with your server logic)
    // ######################################################################

    /**
     * MOCK: Simulates fetching the list of .txt files from your server.
     * REPLACE this with a real `fetch('/api/designs')` call.
     * * In your app.py, you would add a new route like:
     * @app.route('/api/designs')
     * def get_design_list():
     * designs_dir = os.path.join(app.root_path, 'templates', 'designs')
     * try:
     * files = [f for f in os.listdir(designs_dir) if f.endswith('.txt')]
     * return jsonify(files)
     * except Exception as e:
     * return jsonify(error=str(e)), 500
     */
    function fetchMockDesignList() {
        console.warn("Using MOCK design list. Replace 'fetchMockDesignList' with a real API call.");
        // This mock list should match the files you're mocking below
        return Promise.resolve([
            "spiral.txt",
            "square.txt",
            "star.txt",
            "wave.txt",
            "chaos.txt",
            "missing_preview.txt" // This one will force a .txt load
        ]);
    }
    
    /**
     * MOCK: Overriding `fetch` for this demo to provide fake .txt files.
     * REMOVE this entire `window.fetch` block when you deploy.
     * Your real server (app.py) will handle all requests.
     */
    const originalFetch = window.fetch;
    window.fetch = function(url, options) {
        const urlString = url.toString();
        
        // This block is for MOCKING .txt files.
        // Your /designs/<file> route in app.py makes this block unnecessary
        // once you remove the mock list.
        const mockTxtData = { };
        
        if (mockTxtData[urlString] && !options) { // !options ensures it's a GET
            return Promise.resolve(new Response(mockTxtData[urlString], { status: 200 }));
        }

        // This block MOCKS the /send_gcode_block API call
        if (urlString === '/send_gcode_block') {
            console.log("MOCK: Sending G-code block to server", options.body);
            // Return a mock success response
            return Promise.resolve(new Response(JSON.stringify({ success: true, message: "Mock success" }), { status: 200 }));
        }

        // For all other requests (like .png files), use the original fetch
        // This will let them 404 naturally, triggering the .onerror logic
        return originalFetch(url, options);
    };


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.body.setAttribute('data-theme', savedTheme);
        updateThemeIcon(savedTheme);
        loadDesignLibrary();
    });
</script>

</body>
</html>
